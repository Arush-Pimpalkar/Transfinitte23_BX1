{"doc": "The `pw.io.minio.read()` function reads a table from one or several objects in CSV format from an S3 bucket in MinIO. It takes in parameters like path, minio_settings, value_columns, id_columns, csv_settings, mode, types, default_values, autocommit_duration_ms, persistent_id, and debug_data. It returns a Table object, which contains the data from the CSV files. An example usage of this function is also provided.\npw.io.minio.read(path, minio_settings, value_columns, id_columns=None, csv_settings=None, mode='streaming', types=None, default_values=None, autocommit_duration_ms=None, persistent_id=None, debug_data=None, \\*\\*kwargs)\nReads a table from one or several objects in CSV format from S3 bucket in MinIO.\n\nIn case the prefix is specified, and there are several objects lying under this\nprefix, their order is determined according to their modification times: the smaller\nthe modification time is, the earlier the file will be passed to the engine.\n\n\n* Parameters\n\n    * path (`str`) \u2013 Path to an object or to a folder of objects in MinIO S3 bucket.\n\n    * minio_settings (`MinIOSettings`) \u2013 Connection parameters for the MinIO account and the bucket.\n\n    * value_columns (`List`\\[`str`\\]) \u2013 Names of the columns to be extracted from the files.\n\n    * id_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated randomly.\n\n    * csv_settings (`Optional`\\[`CsvParserSettings`\\]) \u2013 The settings for the CSV parser.\n\n    * mode (`str`) \u2013 If set to \u201cstreaming\u201d, the engine will wait for the new input files in the bucket, which fall under the path prefix. Set it to \u201cstatic\u201d, it will onlyconsider the available data and ingest all of it in one commit. Default value is\u201dstreaming\u201d.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nExample:\n\nConsider that there is a table, which is stored in CSV format in the min.io S3\nbucket. Then, you can use this method in order to connect and acquire its contents.\n\nIt may look as follows:\n\n\n```python\nimport os\nimport pathway as pw\nt = pw.io.minio.read(\n    \"animals/\",\n    minio_settings=pw.io.minio.MinIOSettings(\n        bucket_name=\"datasets\",\n        endpoint=\"avv749.stackhero-network.com\",\n        access_key=os.environ[\"MINIO_S3_ACCESS_KEY\"],\n        secret_access_key=os.environ[\"MINIO_S3_SECRET_ACCESS_KEY\"],\n    ),\n    value_columns=[\"owner\", \"pet\"],\n)\n```\n"}
{"doc": "This documentation describes the DateTimeNamespace class in the Pathway framework. It contains methods related to DateTimes, which can be accessed using the \"dt\" attribute of an expression. The example code demonstrates how to use these methods to create a table with datetime values and then extract the day values from them.\nclass  pw.DateTimeNamespace(expression)\n\nA module containing methods related to DateTimes.\nThey can be called using a dt attribute of an expression.\n\nTypical use:\n\n\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |         t1\n   1 | 2023-05-15T14:13:00\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S\"))\ntable_with_days = table_with_datetime.select(day=table_with_datetime.t1.dt.day())\n```\n"}
{"doc": "The `add_duration_in_timezone` function is defined in the pathway framework. It adds a given duration to a datetime value while taking into account the specified timezone. It takes two parameters, `duration` and `timezone` which can be either a `ColumnExpression` or a `Duration` object and a string respectively. The function returns a `DateTimeNaive` or `DateTimeUtc` object depending on the type of object the method was called upon. The example code demonstrates how to use the function to add two hours to a datetime value and convert it to a new timezone.\nadd_duration_in_timezone(duration, timezone)\nAdds Duration to DateTime taking into account time zone.\n\n\n* Parameters\n\n    * duration (`Union`\\[`ColumnExpression`, `Duration`\\]) \u2013 Duration to be added to DateTime.\n\n    * timezone (`Union`\\[`ColumnExpression`, `str`\\]) \u2013 The time zone to perform addition in.\n\n\n\n* Returns\n\n    DateTimeNaive or DateTimeUtc depending on the type of an object                 the method was called on\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nimport datetime\nt1 = pw.debug.table_from_markdown(\n    '''\n     |        date\n   1 | 2023-03-26T01:23:00\n   2 | 2023-03-27T01:23:00\n   3 | 2023-10-29T01:23:00\n   4 | 2023-10-30T01:23:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\nt2 = t1.select(date=pw.this.date.dt.strptime(fmt=fmt))\nt3 = t2.with_columns(\n    new_date=pw.this.date.dt.add_duration_in_timezone(\n        datetime.timedelta(hours=2), timezone=\"Europe/Warsaw\"\n    ),\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\ndate                | new_date\n2023-03-26 01:23:00 | 2023-03-26 04:23:00\n2023-03-27 01:23:00 | 2023-03-27 03:23:00\n2023-10-29 01:23:00 | 2023-10-29 02:23:00\n2023-10-30 01:23:00 | 2023-10-30 03:23:00\n```\n::\n::\n"}
{"doc": "The `day()` function is part of the pathway framework and is used to extract the day from a given DateTime object. The function returns an integer value representing the day of the month (1 to 31). The documentation also provides an example of how to use the function with a sample code snippet and its output.\nday()\nExtracts day from a DateTime.\n\n\n* Returns\n\n    Day as int. 1 <= day <= 31 (depending on a month)\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 1974-03-12T00:00:00\n   2 | 2023-03-25T12:00:00\n   3 | 2023-05-15T14:13:00\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S\"))\ntable_with_days = table_with_datetime.select(day=table_with_datetime.t1.dt.day())\npw.debug.compute_and_print(table_with_days, include_id=False)\n```\n::\nResult\n```\nday\n12\n15\n25\n```\n::\n::\n"}
{"doc": "The documentation describes the `days()` function in the Pathway framework which returns the total number of days in a duration. The function takes no parameters and returns an integer value representing the number of days. The example provided demonstrates how to use the function in a table with datetime values. It subtracts two datetime values to obtain a duration and then applies the `days()` function to compute the number of days in the duration. The result is a table with a new column \"days\" containing the number of days represented as integers.\ndays()\nThe total number of days in a Duration.\n\n\n* Returns\n\n    Days as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |         t1          |         t2\n   0 | 2023-03-15T00:00:00 | 2023-05-15T10:13:23\n   1 | 2023-04-15T00:00:00 | 2023-05-15T10:00:00\n   2 | 2023-05-01T10:00:00 | 2023-05-15T10:00:00\n   3 | 2023-05-15T10:00:00 | 2023-05-15T09:00:00\n   4 | 2023-05-15T10:00:00 | 2023-05-15T11:00:00\n   5 | 2023-05-16T12:13:00 | 2023-05-15T10:00:00\n   6 | 2024-05-15T14:13:23 | 2023-05-15T10:00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_days = table_with_diff.select(days=pw.this[\"diff\"].dt.days())\npw.debug.compute_and_print(table_with_days, include_id=False)\n```\n::\nResult\n```\ndays\n-61\n-30\n-14\n0\n0\n1\n366\n```\n::\n::\n"}
{"doc": "The `floor(duration)` function in Pathway framework truncates a DateTime object to the precision specified by the `duration` argument. The function returns a DateTimeNaive or a DateTimeUtc object depending on the type of the object the method was called on. The function takes one parameter, the `duration` (which can be a `ColumnExpression` or a `Duration`). The documentation also provides an example code snippet to demonstrate how the function can be used to truncate DateTime objects to hours, 10-minute intervals, and 15-second intervals.\nfloor(duration)\nTruncates DateTime to precision specified by duration argument.\n\n\n* Parameters\n\n    duration (`Union`\\[`ColumnExpression`, `Duration`\\]) \u2013 truncation precision\n\n\n\n* Returns\n\n    DateTimeNaive or DateTimeUtc depending on the type of an object                 the method was called on\n\n\nExamples:\n\n\n\nCode\n```python\nimport pathway as pw\nimport datetime\nt1 = pw.debug.table_from_markdown(\n    '''\n     |         date\n   1 | 2023-05-15T12:23:12\n   2 | 2023-05-15T12:33:21\n   3 | 2023-05-15T13:20:35\n   4 | 2023-05-15T13:51:41\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\nt2 = t1.select(date=pw.this.date.dt.strptime(fmt=fmt))\nres = t2.with_columns(\n    truncated_to_hours=pw.this.date.dt.floor(datetime.timedelta(hours=1)),\n    truncated_to_10_min=pw.this.date.dt.floor(datetime.timedelta(minutes=10)),\n    truncated_to_15_s=pw.this.date.dt.floor(datetime.timedelta(seconds=15)),\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\ndate                | truncated_to_hours  | truncated_to_10_min | truncated_to_15_s\n2023-05-15 12:23:12 | 2023-05-15 12:00:00 | 2023-05-15 12:20:00 | 2023-05-15 12:23:00\n2023-05-15 12:33:21 | 2023-05-15 12:00:00 | 2023-05-15 12:30:00 | 2023-05-15 12:33:15\n2023-05-15 13:20:35 | 2023-05-15 13:00:00 | 2023-05-15 13:20:00 | 2023-05-15 13:20:30\n2023-05-15 13:51:41 | 2023-05-15 13:00:00 | 2023-05-15 13:50:00 | 2023-05-15 13:51:30\n```\n::\n::\n"}
{"doc": "The `from_timestamp()` function in the Pathway framework is used to convert a timestamp, represented as an integer, to a `DateTime` object. The function takes two parameters: the integer timestamp value and a string unit indicating the unit of the timestamp (seconds, milliseconds, microseconds, or nanoseconds). The function returns a `DateTime` object. \n\nAn example usage of the function is shown in the code block, where the `from_timestamp()` function is used to convert timestamps in seconds to `DateTime` objects and store them in a new column called \"date\". The resulting output shows the converted `DateTime` objects.\nfrom_timestamp(unit)\nConverts timestamp represented as an in to DateTime.\n\n\n* Parameters\n\n    * timestamp \u2013 value to be converted to DateTime\n\n    * unit (`str`) \u2013 unit of a timestamp. It has to be one of \u2018s\u2019, \u2018ms\u2019, \u2018us\u2019, \u2018ns\u2019\n\n\nReturns\n\n    DateTime\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nfmt = \"%Y-%m-%dT%H:%M:%S\"\nt1 = pw.debug.table_from_markdown(\n    '''\n  | timestamp\n1 |    10\n2 | 1685969950\n'''\n)\nt2 = t1.select(date=pw.this.timestamp.dt.from_timestamp(unit=\"s\"))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\ndate\n1970-01-01 00:00:10\n2023-06-05 12:59:10\n```\n::\n::\n"}
{"doc": "The `hour()` function is an attribute of the DateTime data type in the Pathway Framework. It extracts the hour from a DateTime value and returns an integer between 0 and 23. The documentation provides an example of how to use the `hour()` function with a table of DateTime values in Python, using the `pathway` library. The example shows how to create a new table with an additional column containing the hours from the DateTime values in the original table.\nhour()\nExtracts hour from a DateTime.\n\n\n* Returns\n\n    Hour as int. 0 <= hour < 24\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 2023-05-15T00:00:00\n   2 | 2023-05-15T12:00:00\n   3 | 2023-05-15T14:13:00\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S\"))\ntable_with_hours = table_with_datetime.select(hour=table_with_datetime.t1.dt.hour())\npw.debug.compute_and_print(table_with_hours, include_id=False)\n```\n::\nResult\n```\nhour\n0\n12\n14\n```\n::\n::\n"}
{"doc": "The documentation describes the `hours()` function in the Pathway framework. This function is used to calculate the total number of hours in a `Duration` object. The function returns the hours as an integer. The documentation provides an example code that imports the Pathway library, creates a table with datetime values, calculates the time difference between two columns, and then uses the `hours()` function to calculate the total number of hours in the duration column. The resulting table shows the total number of hours for each row.\nhours()\nThe total number of hours in a Duration.\n\n\n* Returns\n\n    Hours as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |         t1          |         t2\n   0 | 2023-05-15T00:00:00 | 2023-05-15T10:13:23\n   1 | 2023-05-15T00:00:00 | 2023-05-15T10:00:00\n   2 | 2023-05-15T10:00:00 | 2023-05-15T10:00:00\n   3 | 2023-05-15T10:00:23 | 2023-05-15T10:00:00\n   4 | 2023-05-15T12:13:00 | 2023-05-15T10:00:00\n   5 | 2023-05-15T14:13:23 | 2023-05-15T10:00:00\n   6 | 2023-05-16T10:13:23 | 2023-05-15T10:00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_hours = table_with_diff.select(hours=pw.this[\"diff\"].dt.hours())\npw.debug.compute_and_print(table_with_hours, include_id=False)\n```\n::\nResult\n```\nhours\n-10\n-10\n0\n0\n2\n4\n24\n```\n::\n::\n"}
{"doc": "The `microsecond()` function is an attribute of the DateTime class in the pathway framework. It extracts the microseconds from a given DateTime object and returns an integer between 0 and 999999. The example given demonstrates its usage by creating a table with DateTime objects and then using the `microsecond()` function to extract and display the microseconds for each row of the table.\nmicrosecond()\nExtracts microseconds from a DateTime.\n\n\n* Returns\n\n    Microsecond as int. 0 <= microsecond < 1_000_000\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.000012000\n   3 | 2023-05-15T10:13:00.123456789\n   4 | 2023-05-15T10:13:23.123456789\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S.%f\"))\ntable_with_microseconds = table_with_datetime.select(\n    microsecond=table_with_datetime.t1.dt.microsecond()\n)\npw.debug.compute_and_print(table_with_microseconds, include_id=False)\n```\n::\nResult\n```\nmicrosecond\n0\n12\n123456\n123456\n```\n::\n::\n"}
{"doc": "The `microseconds()` function is a method of the `Duration` class in the Pathway framework. This function returns the total number of microseconds in a duration as an integer. The documentation provides an example of how to use this function in Pathway using a table with datetime columns. The example performs datetime operations on the table and calculates the difference between two datetime columns. The `microseconds()` function is applied on the resulting duration object to extract the total number of microseconds in the duration. The output shows the number of microseconds for each row in the table.\nmicroseconds()\nThe total number of microseconds in a Duration.\n\n\n* Returns\n\n    Microseconds as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1              |               t2\n   0 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:23.123456789\n   1 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.000012000 | 2023-05-15T10:13:00.000000000\n   3 | 2023-05-15T10:13:00.123456789 | 2023-05-15T10:13:00.000000000\n   4 | 2023-05-15T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n   5 | 2023-05-16T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S.%f\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_microseconds = table_with_diff.select(\n    microseconds=pw.this[\"diff\"].dt.microseconds()\n)\npw.debug.compute_and_print(table_with_microseconds, include_id=False)\n```\n::\nResult\n```\nmicroseconds\n-23123456\n0\n12\n123456\n23123456\n86423123456\n```\n::\n::\n"}
{"doc": "The `millisecond()` function is a part of the pathway framework that extracts the milliseconds from a DateTime object and returns it as an integer between 0 and 999. The documentation provides an example of how to use the function with a table containing DateTime values. The result of the function call is printed alongside the original DateTime values in the table.\nmillisecond()\nExtracts milliseconds from a DateTime.\n\n\n* Returns\n\n    Millisecond as int. 0 <= millisecond < 1_000\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.012000000\n   3 | 2023-05-15T10:13:00.123456789\n   4 | 2023-05-15T10:13:23.123456789\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S.%f\"))\ntable_with_milliseconds = table_with_datetime.select(\n    millisecond=table_with_datetime.t1.dt.millisecond()\n)\npw.debug.compute_and_print(table_with_milliseconds, include_id=False)\n```\n::\nResult\n```\nmillisecond\n0\n12\n123\n123\n```\n::\n::\n"}
{"doc": "The `milliseconds()` function is an attribute of the `Duration` class in the Pathway framework. It returns the total number of milliseconds in a duration as an integer. The example code imports the Pathway framework, creates a table with datetime values, calculates the difference between two datetimes, converts the difference to milliseconds using the `milliseconds()` function, and finally prints the resulting table with the milliseconds column added. The resulting table includes the milliseconds between each pair of datetime values.\nmilliseconds()\nThe total number of milliseconds in a Duration.\n\n\n* Returns\n\n    Milliseconds as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1              |               t2\n   0 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:23.123456789\n   1 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.012000000 | 2023-05-15T10:13:00.000000000\n   3 | 2023-05-15T10:13:00.123456789 | 2023-05-15T10:13:00.000000000\n   4 | 2023-05-15T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n   5 | 2023-05-16T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S.%f\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_milliseconds = table_with_diff.select(\n    milliseconds=pw.this[\"diff\"].dt.milliseconds()\n)\npw.debug.compute_and_print(table_with_milliseconds, include_id=False)\n```\n::\nResult\n```\nmilliseconds\n-23123\n0\n12\n123\n23123\n86423123\n```\n::\n::\n"}
{"doc": "The `minute()` function is part of the Pathway framework and is used to extract the minute from a DateTime object. It returns the minute as an integer between 0 and 59. The documentation provides an example usage of the function with a sample input table and output result.\nminute()\nExtracts minute from a DateTime.\n\n\n* Returns\n\n    Minute as int. 0 <= minute < 60\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 2023-05-15T10:00:00\n   2 | 2023-05-15T10:00:23\n   3 | 2023-05-15T10:13:00\n   4 | 2023-05-15T10:13:23\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S\"))\ntable_with_minutes = table_with_datetime.select(\n    minute=table_with_datetime.t1.dt.minute()\n)\npw.debug.compute_and_print(table_with_minutes, include_id=False)\n```\n::\nResult\n```\nminute\n0\n0\n13\n13\n```\n::\n::\n"}
{"doc": "The `minutes()` function is an attribute of the `Duration` class in the Pathway framework. It returns the total number of minutes in a `Duration` object as an integer. The example provided demonstrates how to use `minutes()` function to calculate the difference in minutes between two dates in a table using the Pathway framework.\nminutes()\nThe total number of minutes in a Duration.\n\n\n* Returns\n\n    Minutes as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |         t1          |         t2\n   0 | 2023-05-15T10:00:00 | 2023-05-15T10:13:23\n   1 | 2023-05-15T10:00:00 | 2023-05-15T10:00:00\n   2 | 2023-05-15T10:00:23 | 2023-05-15T10:00:00\n   3 | 2023-05-15T10:13:00 | 2023-05-15T10:00:00\n   4 | 2023-05-15T10:13:23 | 2023-05-15T10:00:00\n   5 | 2023-05-16T10:13:23 | 2023-05-15T10:00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_minutes = table_with_diff.select(minutes=pw.this[\"diff\"].dt.minutes())\npw.debug.compute_and_print(table_with_minutes, include_id=False)\n```\n::\nResult\n```\nminutes\n-13\n0\n0\n13\n13\n1453\n```\n::\n::\n"}
{"doc": "The `month()` function is a part of the Pathway framework. It is used to extract the month from a DateTime object and returns an integer between 1 and 12. The function is demonstrated through a code example that imports Pathway, creates a table, converts the table to include DateTime objects and extracts the month from each DateTime object in the table using the `month()` function. The resulting table only includes the extracted months.\nmonth()\nExtracts month from a DateTime.\n\n\n* Returns\n\n    Month as int. 1 <= month <= 12\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 1974-03-12T00:00:00\n   2 | 2023-03-25T12:00:00\n   3 | 2023-05-15T14:13:00\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S\"))\ntable_with_months = table_with_datetime.select(month=table_with_datetime.t1.dt.month())\npw.debug.compute_and_print(table_with_months, include_id=False)\n```\n::\nResult\n```\nmonth\n3\n3\n5\n```\n::\n::\n"}
{"doc": "The `nanosecond()` function is a method of the `DateTime` object in the `pathway` framework. It takes a `DateTime` object as input and returns the number of nanoseconds as an integer. The returned value ranges from 0 to 999,999,999. The example code demonstrates how to use this function to extract nanoseconds from a `DateTime` object and returns the results in a table format.\nnanosecond()\nExtracts nanoseconds from a DateTime.\n\n\n* Returns\n\n    Nanosecond as int. 0 <= nanosecond < 1_000_000_000\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.000000012\n   3 | 2023-05-15T10:13:00.123456789\n   4 | 2023-05-15T10:13:23.123456789\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S.%f\"))\ntable_with_nanoseconds = table_with_datetime.select(\n    nanosecond=table_with_datetime.t1.dt.nanosecond()\n)\npw.debug.compute_and_print(table_with_nanoseconds, include_id=False)\n```\n::\nResult\n```\nnanosecond\n0\n12\n123456789\n123456789\n```\n::\n::\n"}
{"doc": "The `nanoseconds()` function is an attribute of the `Duration` class in the Pathway framework. It returns the total number of nanoseconds in the duration. The function takes no arguments and returns an integer value. The provided example code shows how to use the function to calculate the duration in nanoseconds between two datetime values in a table. The resulting nanoseconds values are printed in the output.\nnanoseconds()\nThe total number of nanoseconds in a Duration.\n\n\n* Returns\n\n    Nanoseconds as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1              |               t2\n   0 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:23.123456789\n   1 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.000000012 | 2023-05-15T10:13:00.000000000\n   3 | 2023-05-15T10:13:00.123456789 | 2023-05-15T10:13:00.000000000\n   4 | 2023-05-15T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n   5 | 2023-05-16T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S.%f\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_nanoseconds = table_with_diff.select(\n    nanoseconds=pw.this[\"diff\"].dt.nanoseconds()\n)\npw.debug.compute_and_print(table_with_nanoseconds, include_id=False)\n```\n::\nResult\n```\nnanoseconds\n-23123456789\n0\n12\n123456789\n23123456789\n86423123456789\n```\n::\n::\n"}
{"doc": "The \"round\" function in the Pathway framework rounds a DateTime object to the precision specified by the duration argument. The duration can be either a ColumnExpression or a Duration. The function returns either a DateTimeNaive or DateTimeUtc object depending on the type of object the method was called on. The documentation includes an example of how to use the function to round a date column to various time intervals.\nround(duration)\nRounds DateTime to precision specified by duration argument.\n\n\n* Parameters\n\n    duration (`Union`\\[`ColumnExpression`, `Duration`\\]) \u2013 rounding precision\n\n\n\n* Returns\n\n    DateTimeNaive or DateTimeUtc depending on the type of an object                 the method was called on\n\n\nExamples:\n\n\n\nCode\n```python\nimport pathway as pw\nimport datetime\nt1 = pw.debug.table_from_markdown(\n    '''\n     |         date\n   1 | 2023-05-15T12:23:12\n   2 | 2023-05-15T12:33:21\n   3 | 2023-05-15T13:20:35\n   4 | 2023-05-15T13:51:41\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\nt2 = t1.select(date=pw.this.date.dt.strptime(fmt=fmt))\nres = t2.with_columns(\n    rounded_to_hours=pw.this.date.dt.round(datetime.timedelta(hours=1)),\n    rounded_to_10_min=pw.this.date.dt.round(datetime.timedelta(minutes=10)),\n    rounded_to_15_s=pw.this.date.dt.round(datetime.timedelta(seconds=15)),\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\ndate                | rounded_to_hours    | rounded_to_10_min   | rounded_to_15_s\n2023-05-15 12:23:12 | 2023-05-15 12:00:00 | 2023-05-15 12:20:00 | 2023-05-15 12:23:15\n2023-05-15 12:33:21 | 2023-05-15 13:00:00 | 2023-05-15 12:30:00 | 2023-05-15 12:33:15\n2023-05-15 13:20:35 | 2023-05-15 13:00:00 | 2023-05-15 13:20:00 | 2023-05-15 13:20:30\n2023-05-15 13:51:41 | 2023-05-15 14:00:00 | 2023-05-15 13:50:00 | 2023-05-15 13:51:45\n```\n::\n::\n"}
{"doc": "The `second()` function is an attribute of the DateTime class in the Pathway framework. It extracts the seconds from a given DateTime object and returns it as an integer. The output is such that 0 <= second < 60. The example given demonstrates the use of this function to extract seconds from a table of DateTime objects.\nsecond()\nExtracts seconds from a DateTime.\n\n\n* Returns\n\n    Second as int. 0 <= second < 60\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.123456789\n   3 | 2023-05-15T10:13:23.000000000\n   4 | 2023-05-15T10:13:23.123456789\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S.%f\"))\ntable_with_seconds = table_with_datetime.select(\n    second=table_with_datetime.t1.dt.second()\n)\npw.debug.compute_and_print(table_with_seconds, include_id=False)\n```\n::\nResult\n```\nsecond\n0\n0\n23\n23\n```\n::\n::\n"}
{"doc": "The `seconds()` function is a method of a Duration object in the Pathway framework. It returns an integer that represents the total number of seconds in the Duration object. The example code uses this function to calculate the difference in seconds between two dates/times.\nseconds()\nThe total number of seconds in a Duration.\n\n\n* Returns\n\n    Seconds as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1              |               t2\n   0 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:23.123456789\n   1 | 2023-05-15T10:13:00.000000000 | 2023-05-15T10:13:00.000000000\n   2 | 2023-05-15T10:13:00.123456789 | 2023-05-15T10:13:00.000000000\n   3 | 2023-05-15T10:13:23.000000000 | 2023-05-15T10:13:00.000000000\n   4 | 2023-05-15T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n   5 | 2023-05-16T10:13:23.123456789 | 2023-05-15T10:13:00.000000000\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S.%f\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_seconds = table_with_diff.select(seconds=pw.this[\"diff\"].dt.seconds())\npw.debug.compute_and_print(table_with_seconds, include_id=False)\n```\n::\nResult\n```\nseconds\n-23\n0\n0\n23\n23\n86423\n```\n::\n::\n"}
{"doc": "`strftime(fmt)` is a function in the Pathway framework that converts a DateTime object to a string using a specified format string `fmt`. The function uses specifiers from the chrono library, which are mostly identical to standard Python specifiers in strftime. The function returns a string. The example provided demonstrates how to use `strftime` to format a table of date and time values.\nstrftime(fmt)\nConverts a DateTime to a string.\n\n\n* Parameters\n\n    fmt (`Union`\\`ColumnExpression`, `str`\\]) \u2013 Format string. We use the specifiers of             [chrono             library. In most cases they are identical to standard python specifiers in             strftime .\n\n\n\n* Returns\n\n    str\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 1970-02-03T10:13:00\n   2 | 2023-03-25T10:13:00\n   3 | 2023-03-26T12:13:00\n   4 | 2023-05-15T14:13:23\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\ntable_with_datetime = table.select(t1=pw.this.t1.dt.strptime(fmt=fmt))\ntable_formatted = table_with_datetime.select(\n    date=pw.this.t1.dt.strftime(\"%d.%m.%Y\"),\n    full_date=pw.this.t1.dt.strftime(\"%B %d, %Y\"),\n    time_24=pw.this.t1.dt.strftime(\"%H:%M:%S\"),\n    time_12=pw.this.t1.dt.strftime(\"%I:%M:%S %p\"),\n)\npw.debug.compute_and_print(table_formatted, include_id=False)\n```\n::\nResult\n```\ndate       | full_date         | time_24  | time_12\n03.02.1970 | February 03, 1970 | 10:13:00 | 10:13:00 AM\n15.05.2023 | May 15, 2023      | 14:13:23 | 02:13:23 PM\n25.03.2023 | March 25, 2023    | 10:13:00 | 10:13:00 AM\n26.03.2023 | March 26, 2023    | 12:13:00 | 12:13:00 PM\n```\n::\n::\n"}
{"doc": "This documentation is for the `subtract_date_time_in_timezone` function in the Pathway framework. It takes two `DateTimeNaive` objects and subtracts them, taking into account the specified timezone. The function returns a `Duration` object representing the difference between the two times. The documentation includes a code example using the function to calculate the time difference between two dates, with the output printed in a table.\nsubtract_date_time_in_timezone(date_time, timezone)\nSubtracts two DateTimeNaives taking into account time zone.\n\n\n* Parameters\n\n    * date_time (`Union`\\[`ColumnExpression`, `DateTimeNaive`\\]) \u2013 DateTimeNaive to be subtracted from self.\n\n    * timezone (`Union`\\[`ColumnExpression`, `str`\\]) \u2013 The time zone to perform subtraction in.\n\n\n\n* Returns\n\n    Duration\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n     |        date1        |        date2\n   1 | 2023-03-26T03:20:00 | 2023-03-26T01:20:00\n   2 | 2023-03-27T03:20:00 | 2023-03-27T01:20:00\n   3 | 2023-10-29T03:20:00 | 2023-10-29T01:20:00\n   4 | 2023-10-30T03:20:00 | 2023-10-30T01:20:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\nt2 = t1.select(\n    date1=pw.this.date1.dt.strptime(fmt=fmt), date2=pw.this.date2.dt.strptime(fmt=fmt)\n)\nt3 = t2.with_columns(\n    diff=pw.this.date1.dt.subtract_date_time_in_timezone(\n        pw.this.date2, timezone=\"Europe/Warsaw\"\n    ),\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\ndate1               | date2               | diff\n2023-03-26 03:20:00 | 2023-03-26 01:20:00 | 0 days 01:00:00\n2023-03-27 03:20:00 | 2023-03-27 01:20:00 | 0 days 02:00:00\n2023-10-29 03:20:00 | 2023-10-29 01:20:00 | 0 days 03:00:00\n2023-10-30 03:20:00 | 2023-10-30 01:20:00 | 0 days 02:00:00\n```\n::\n::\n"}
{"doc": "The `subtract_duration_in_timezone()` function in the Pathway framework can subtract a duration from a datetime object, taking into account a specified time zone. It accepts two parameters: `duration` (which can be a `ColumnExpression` or a `Duration` object) and `timezone` (which can be a `ColumnExpression` or a string). Depending on the object the method is called on, it returns either a `DateTimeNaive` or a `DateTimeUtc` object. The documentation provides an example code that shows how to use the function with a table containing datetime values in different time zones.\nsubtract_duration_in_timezone(duration, timezone)\nSubtracts Duration from DateTime taking into account time zone.\n\n\n* Parameters\n\n    * duration (`Union`\\[`ColumnExpression`, `Duration`\\]) \u2013 Duration to be subtracted from DateTime.\n\n    * timezone (`Union`\\[`ColumnExpression`, `str`\\]) \u2013 The time zone to perform subtraction in.\n\n\n\n* Returns\n\n    DateTimeNaive or DateTimeUtc depending on the type of an object                 the method was called on\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nimport datetime\nt1 = pw.debug.table_from_markdown(\n    '''\n     |        date\n   1 | 2023-03-26T03:23:00\n   2 | 2023-03-27T03:23:00\n   3 | 2023-10-29T03:23:00\n   4 | 2023-10-30T03:23:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\nt2 = t1.select(date=pw.this.date.dt.strptime(fmt=fmt))\nt3 = t2.with_columns(\n    new_date=pw.this.date.dt.subtract_duration_in_timezone(\n        datetime.timedelta(hours=2), timezone=\"Europe/Warsaw\"\n    ),\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\ndate                | new_date\n2023-03-26 03:23:00 | 2023-03-26 00:23:00\n2023-03-27 03:23:00 | 2023-03-27 01:23:00\n2023-10-29 03:23:00 | 2023-10-29 02:23:00\n2023-10-30 03:23:00 | 2023-10-30 01:23:00\n```\n::\n::\n"}
{"doc": "The `timestamp()` function is a method of the `datetime` object in the pathway framework. It returns a number of nanoseconds since 1970-01-01 for naive DateTime and from 1970-01-01 UTC for timezone-aware datetime. The function takes no arguments and returns a timestamp as an integer. There are examples provided in the documentation showing how to use this function to convert datetime objects to timestamps. The examples include creating a table with datetime objects, converting them to timestamps, and displaying the results.\ntimestamp()\nReturns a number of nanoseconds from 1970-01-01 for naive DateTime\nand from 1970-01-01 UTC for timezone-aware datetime.\n\n\n* Returns\n\n    Timestamp as int.\n\n\nExamples:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   0 | 1969-01-01T00:00:00.000000000\n   1 | 1970-01-01T00:00:00.000000000\n   2 | 2023-01-01T00:00:00.000000000\n   3 | 2023-03-25T00:00:00.000000000\n   4 | 2023-03-25T13:45:26.000000000\n   5 | 2023-03-25T13:45:26.987654321\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S.%f\"))\ntable_with_timestamp = table_with_datetime.select(\n    timestamp=table_with_datetime.t1.dt.timestamp()\n)\npw.debug.compute_and_print(table_with_timestamp, include_id=False)\n```\n::\nResult\n```\ntimestamp\n-31536000000000000\n0\n1672531200000000000\n1679702400000000000\n1679751926000000000\n1679751926987654321\n```\n::\n::\n\nCode\n```python\n\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 1969-01-01T00:00:00.000000000+00:00\n   2 | 1970-01-01T00:00:00.000000000+00:00\n   3 | 1970-01-01T00:00:00.000000000+02:00\n   4 | 1970-01-01T00:00:00.000000000-03:00\n   5 | 2023-01-01T00:00:00.000000000+01:00\n   6 | 2023-03-25T00:00:00.000000000+01:00\n   7 | 2023-03-25T13:45:26.000000000+01:00\n   8 | 2023-03-25T13:45:26.987654321+01:00\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S.%f%z\"))\ntable_with_timestamp = table_with_datetime.select(\n    timestamp=table_with_datetime.t1.dt.timestamp()\n)\npw.debug.compute_and_print(table_with_timestamp, include_id=False)\n```\n::\nResult\n```\ntimestamp\n-31536000000000000\n-7200000000000\n0\n10800000000000\n1672527600000000000\n1679698800000000000\n1679748326000000000\n1679748326987654321\n```\n::\n::\n"}
{"doc": "This documentation is describing the `weeks()` function in the Pathway framework. It calculates the total number of weeks in a duration and returns it as an integer. The documentation includes an example code snippet that demonstrates how to use the `weeks()` function in conjunction with other Pathway functions to compute the difference in weeks between two dates in a table. The result of the computation is also provided in the documentation.\nweeks()\nThe total number of weeks in a Duration.\n\n\n* Returns\n\n    Weeks as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |         t1          |         t2\n   0 | 2023-03-15T00:00:00 | 2023-05-15T10:13:23\n   1 | 2023-04-15T00:00:00 | 2023-05-15T10:00:00\n   2 | 2023-05-01T10:00:00 | 2023-05-15T10:00:00\n   3 | 2023-05-15T10:00:00 | 2023-05-15T09:00:00\n   4 | 2023-05-15T10:00:00 | 2023-05-15T11:00:00\n   5 | 2023-05-16T12:13:00 | 2023-05-15T10:00:00\n   6 | 2024-05-15T14:13:23 | 2023-05-15T10:00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\ntable_with_datetimes = table.select(\n    t1=pw.this.t1.dt.strptime(fmt=fmt), t2=pw.this.t2.dt.strptime(fmt=fmt)\n)\ntable_with_diff = table_with_datetimes.select(diff=pw.this.t1 - pw.this.t2)\ntable_with_weeks = table_with_diff.select(weeks=pw.this[\"diff\"].dt.weeks())\npw.debug.compute_and_print(table_with_weeks, include_id=False)\n```\n::\nResult\n```\nweeks\n-8\n-4\n-2\n0\n0\n0\n52\n```\n::\n::\n"}
{"doc": "The `year()` function is a part of the Pathway framework. It is used to extract the year from a given DateTime object. It returns the year as an integer. The example provided demonstrates its usage to extract the year from a table with DateTime values.\nyear()\nExtracts year from a DateTime.\n\n\n* Returns\n\n    Year as int.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 1974-03-12T00:00:00\n   2 | 2023-03-25T12:00:00\n   3 | 2023-05-15T14:13:00\n'''\n)\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(\"%Y-%m-%dT%H:%M:%S\"))\ntable_with_years = table_with_datetime.select(year=table_with_datetime.t1.dt.year())\npw.debug.compute_and_print(table_with_years, include_id=False)\n```\n::\nResult\n```\nyear\n1974\n2023\n2023\n```\n::\n::\n\n"}
{"doc": "The `pw.NumericalNamespace` class is a module that contains methods related to numbers in the Pathway framework. These methods can be called using a `num` attribute of an expression. The `typical use` section shows an example of using the `abs()` method of the `num` attribute to calculate the absolute value of a number in a table.\nclass  pw.NumericalNamespace(expression)\n\nA module containing methods related to numbers.\nThey can be called using a num attribute of an expression.\n\nTypical use:\n\n\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     | v\n   1 | -1\n'''\n)\ntable_abs = table.select(v_abs=table.v.num.abs())\n```\n"}
{"doc": "The documentation describes the abs() function in the Pathway framework, which returns the absolute value of a numerical value and returns it as a float. It includes an example code snippet demonstrating how to use it in a table.\nabs()\nReturns the absolute value from a numerical value.\n\n\n* Returns\n\n    Absolute value as float\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     | v\n   1 | 1\n   2 | -1\n   3 | 2.5\n   4 | -2.5\n'''\n)\ntable_abs = table.select(v_abs=table.v.num.abs())\npw.debug.compute_and_print(table_abs, include_id=False)\n```\n::\nResult\n```\nv_abs\n1.0\n1.0\n2.5\n2.5\n```\n::\n::\n"}
{"doc": "The `fill_na()` function is a method of the `num` attribute in the `table` class in the Pathway framework. It takes a default value as a parameter and fills the missing values in a column of a table with that value. The function returns a new column with the missing values filled in. A code example is provided to demonstrate its usage.\nfill_na(default_value)\nFill the missing values (None or NaN) in a column of a table with a specified default value.\n\n\n* Parameters\n\n    default_value (*float*) \u2013 The value to fill in for the missing values.\n\n\n\n* Returns\n\n    A new column with the missing values filled with the specified default value.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     | v\n   1 | 1\n   2 | 2.0\n   3 | None\n   4 | 3.5\n'''\n)\ntable_fill_na = table.select(v_filled=table.v.num.fill_na(0))\npw.debug.compute_and_print(table_fill_na, include_id=False)\n```\n::\nResult\n```\nv_filled\n0.0\n1.0\n2.0\n3.5\n```\n::\n::\n"}
{"doc": "The `round` function in the Pathway framework is used to round the values in a column of a table to a specified number of decimals. The function can take either an integer or a reference to another column to specify the number of decimal places to round to. It returns a new column with the values rounded to the specified number of decimals. The documentation provides two examples that demonstrate how to use the `round` function with different input arguments.\nround(decimals=0)\nRound the values in a column of a table to the specified number of decimals.\n\n\n* Parameters\n\n    * decimals (`Union`\\[`ColumnExpression`, `int`\\]) \u2013 The number of decimal places to round to. It can be either an\n\n    * 0. (*integer or a reference to another column. Defaults to*) \u2013 \n\n\n\n* Returns\n\n    A new column with the values rounded to the specified number of decimals.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     | v\n   1 | -2.18\n   2 | -1.11\n   3 | 1\n   4 | 2.1\n   5 | 3.14\n   6 | 4.17\n'''\n)\ntable_round = table.select(v_round=table.v.num.round(1))\npw.debug.compute_and_print(table_round, include_id=False)\n```\n::\nResult\n```\nv_round\n-2.2\n-1.1\n1.0\n2.1\n3.1\n4.2\n```\n::\n::\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     | v      | precision\n   1 | 3      | 0\n   2 | 3.1    | 1\n   3 | 3.14   | 1\n   4 | 3.141  | 2\n   5 | 3.1415 | 2\n'''\n)\ntable_round = table.select(v_round=table.v.num.round(pw.this.precision))\npw.debug.compute_and_print(table_round, include_id=False)\n```\n::\nResult\n```\nv_round\n3.0\n3.1\n3.1\n3.14\n3.14\n```\n::\n::\n\n"}
{"doc": "The `strptime()` function in the Pathway framework converts a string to a DateTime object. If the string contains timezone information, a timezone-aware DateTime object is created and the timezone is converted to the server timezone. If no timezone information is present, a naive DateTime object is created. The `fmt` parameter specifies the format of the string using chrono library specifiers, and the `contains_timezone` parameter determines the return type. The function returns a DateTime object. An example usage is shown that selects the `t1` column from a table and converts it to a DateTime object using the `strptime()` function.\nstrptime(fmt, contains_timezone=None)\nConverts a string to a DateTime. If the string contains a timezone and\na %z specifier is used, timezone-aware DateTime is created.\nThen the timezone is converted to a server timezone (see examples).\nIf the string contains no timezone, a naive (not aware of timezone) DateTime\nis created.\n\n\n* Parameters\n\n    fmt (`Union`\\`ColumnExpression`, `str`\\]) \u2013 Format string. We use the specifiers of             [chrono             library. In most cases they are identical to standard python specifiers in             strptime .             contains_timezone: If fmt is not a single string (the same for all objects)             but a ColumnExpression, you need to set this parameter so that the function             can determine if the return type is DateTimeNaive (contains_timezone = False)             or DateTimeUtc (contains_timezone = True).\n\n\n\n\n* Returns\n\n    DateTime\n\n\nExample:\n\n\n\n\n```python\n\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 1970-02-03T10:13:00.000000000\n   2 | 2023-03-25T10:13:00.000000012\n   3 | 2023-03-26T12:13:00.123456789\n   4 | 2023-05-15T14:13:23.123456789\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S.%f\"\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(fmt=fmt))\npw.debug.compute_and_print(table_with_datetime, include_id=False)\n```\n::\nResult\n```\nt1\n1970-02-03 10:13:00\n2023-03-25 10:13:00.000000012\n2023-03-26 12:13:00.123456789\n2023-05-15 14:13:23.123456789\n```\n::\n::\n\n\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 03.02.1970T10:13:00.000000000\n   2 | 25.03.2023T10:13:00.000000012\n   3 | 26.03.2023T12:13:00.123456789\n   4 | 15.05.2023T14:13:23.123456789\n'''\n)\nfmt = \"%d.%m.%YT%H:%M:%S.%f\"\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(fmt=fmt))\npw.debug.compute_and_print(table_with_datetime, include_id=False)\n```\n::\nResult\n```\nt1\n1970-02-03 10:13:00\n2023-03-25 10:13:00.000000012\n2023-03-26 12:13:00.123456789\n2023-05-15 14:13:23.123456789\n```\n::\n::\n\n\ntable = pw.debug.table_from_markdown(\n    '''\n     |               t1\n   1 | 1970-02-03T10:13:00-02:00\n   2 | 2023-03-25T10:13:00+00:00\n   3 | 2023-03-26T12:13:00-01:00\n   4 | 2023-05-15T14:13:23+00:30\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S%z\"\ntable_with_datetime = table.select(t1=table.t1.dt.strptime(fmt=fmt))\npw.debug.compute_and_print(table_with_datetime, include_id=False)\n```\n::\nResult\n```\nt1\n1970-02-03 12:13:00+00:00\n2023-03-25 10:13:00+00:00\n2023-03-26 13:13:00+00:00\n2023-05-15 13:43:23+00:00\n```\n::\n::\n"}
{"doc": "The `to_naive_in_timezone` function is a method of the DateTimeUtc attribute in the Pathway framework. It converts a DateTimeUtc object to a specified time zone. The function accepts a `timezone` parameter representing the time zone to convert to, and returns a DateTimeNaive object. An example of its usage is shown, which demonstrates how it can convert a table of UTC dates to local time in Warsaw.\nto_naive_in_timezone(timezone)\nConverts DateTimeUtc to time zone specified as timezone argument.\n\n\n* Parameters\n\n    timezone (`Union`\\[`ColumnExpression`, `str`\\]) \u2013 The time zone to convert to.\n\n\n\n* Returns\n\n    DateTimeNaive\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |        date_utc\n   1 | 2023-03-26T00:59:00+00:00\n   2 | 2023-03-26T01:00:00+00:00\n   3 | 2023-03-27T00:59:00+00:00\n   4 | 2023-03-27T01:00:00+00:00\n   5 | 2023-10-28T23:59:00+00:00\n   6 | 2023-10-29T00:00:00+00:00\n   7 | 2023-10-29T00:30:00+00:00\n   8 | 2023-10-29T01:00:00+00:00\n   9 | 2023-10-29T01:30:00+00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S%z\"\ntable_utc = table.select(date_utc=pw.this.date_utc.dt.strptime(fmt=fmt))\ntable_local = table_utc.with_columns(\n    date=pw.this.date_utc.dt.to_naive_in_timezone(timezone=\"Europe/Warsaw\"),\n)\npw.debug.compute_and_print(table_local, include_id=False)\n```\n::\nResult\n```\ndate_utc                  | date\n2023-03-26 00:59:00+00:00 | 2023-03-26 01:59:00\n2023-03-26 01:00:00+00:00 | 2023-03-26 03:00:00\n2023-03-27 00:59:00+00:00 | 2023-03-27 02:59:00\n2023-03-27 01:00:00+00:00 | 2023-03-27 03:00:00\n2023-10-28 23:59:00+00:00 | 2023-10-29 01:59:00\n2023-10-29 00:00:00+00:00 | 2023-10-29 02:00:00\n2023-10-29 00:30:00+00:00 | 2023-10-29 02:30:00\n2023-10-29 01:00:00+00:00 | 2023-10-29 02:00:00\n2023-10-29 01:30:00+00:00 | 2023-10-29 02:30:00\n```\n::\n::\n\n\ntable = pw.debug.table_from_markdown(\n    '''\n     |        date_utc\n   1 | 2023-03-12T09:59:00+00:00\n   2 | 2023-03-12T10:00:00+00:00\n   3 | 2023-03-13T09:59:00+00:00\n   4 | 2023-03-13T10:00:00+00:00\n   5 | 2023-11-05T07:59:00+00:00\n   6 | 2023-11-05T08:00:00+00:00\n   7 | 2023-11-05T08:30:00+00:00\n   8 | 2023-11-05T09:00:00+00:00\n   9 | 2023-11-05T09:30:00+00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S%z\"\ntable_utc = table.select(date_utc=pw.this.date_utc.dt.strptime(fmt=fmt))\ntable_local = table_utc.with_columns(\n    date=pw.this.date_utc.dt.to_naive_in_timezone(timezone=\"America/Los_Angeles\"),\n)\npw.debug.compute_and_print(table_local, include_id=False)\n```\n::\nResult\n```\ndate_utc                  | date\n2023-03-12 09:59:00+00:00 | 2023-03-12 01:59:00\n2023-03-12 10:00:00+00:00 | 2023-03-12 03:00:00\n2023-03-13 09:59:00+00:00 | 2023-03-13 02:59:00\n2023-03-13 10:00:00+00:00 | 2023-03-13 03:00:00\n2023-11-05 07:59:00+00:00 | 2023-11-05 00:59:00\n2023-11-05 08:00:00+00:00 | 2023-11-05 01:00:00\n2023-11-05 08:30:00+00:00 | 2023-11-05 01:30:00\n2023-11-05 09:00:00+00:00 | 2023-11-05 01:00:00\n2023-11-05 09:30:00+00:00 | 2023-11-05 01:30:00\n```\n::\n::\n"}
{"doc": "The `to_utc()` function in the Pathway framework takes a datetime object in a given timezone (`from_timezone`) and converts it into a UTC datetime object. If the input datetime doesn't exist in the given timezone, it is mapped to the first existing datetime after it. If a given datetime corresponds to more than one moment in the provided timezone, it is mapped to a later moment. The function returns a DateTimeUtc object. The example shows how to use the function to convert a table of datetimes from a local timezone to UTC.\nto_utc(from_timezone)\nConverts DateTimeNaive to UTC from time zone provided as from_timezone\nargument. If the given DateTime doesn\u2019t exist in the provided time zone it is\nmapped to the first existing DateTime after it. If a given DateTime corresponds\nto more than one moments in the provided time zone, it is mapped to a later\nmoment.\n\n\n* Parameters\n\n    from_timezone (`Union`\\[`ColumnExpression`, `str`\\]) \u2013 The time zone to convert from.\n\n\n\n* Returns\n\n    DateTimeUtc\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\n     |         date\n   1 | 2023-03-26T01:59:00\n   2 | 2023-03-26T02:30:00\n   3 | 2023-03-26T03:00:00\n   4 | 2023-03-27T01:59:00\n   5 | 2023-03-27T02:30:00\n   6 | 2023-03-27T03:00:00\n   7 | 2023-10-29T01:59:00\n   8 | 2023-10-29T02:00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\ntable_local = table.select(date=pw.this.date.dt.strptime(fmt=fmt))\ntable_utc = table_local.with_columns(\n    date_utc=pw.this.date.dt.to_utc(from_timezone=\"Europe/Warsaw\"),\n)\npw.debug.compute_and_print(table_utc, include_id=False)\n```\n::\nResult\n```\ndate                | date_utc\n2023-03-26 01:59:00 | 2023-03-26 00:59:00+00:00\n2023-03-26 02:30:00 | 2023-03-26 01:00:00+00:00\n2023-03-26 03:00:00 | 2023-03-26 01:00:00+00:00\n2023-03-27 01:59:00 | 2023-03-26 23:59:00+00:00\n2023-03-27 02:30:00 | 2023-03-27 00:30:00+00:00\n2023-03-27 03:00:00 | 2023-03-27 01:00:00+00:00\n2023-10-29 01:59:00 | 2023-10-28 23:59:00+00:00\n2023-10-29 02:00:00 | 2023-10-29 01:00:00+00:00\n```\n::\n::\n\n\ntable = pw.debug.table_from_markdown(\n    '''\n     |         date\n   1 | 2023-03-12T01:59:00\n   2 | 2023-03-12T02:30:00\n   3 | 2023-03-12T03:00:00\n   4 | 2023-03-13T01:59:00\n   5 | 2023-03-13T02:30:00\n   6 | 2023-03-13T03:00:00\n   7 | 2023-11-05T00:59:00\n   8 | 2023-11-05T01:00:00\n'''\n)\nfmt = \"%Y-%m-%dT%H:%M:%S\"\ntable_local = table.select(date=pw.this.date.dt.strptime(fmt=fmt))\ntable_utc = table_local.with_columns(\n    date_utc=pw.this.date.dt.to_utc(from_timezone=\"America/Los_Angeles\"),\n)\npw.debug.compute_and_print(table_utc, include_id=False)\n```\n::\nResult\n```\ndate                | date_utc\n2023-03-12 01:59:00 | 2023-03-12 09:59:00+00:00\n2023-03-12 02:30:00 | 2023-03-12 10:00:00+00:00\n2023-03-12 03:00:00 | 2023-03-12 10:00:00+00:00\n2023-03-13 01:59:00 | 2023-03-13 08:59:00+00:00\n2023-03-13 02:30:00 | 2023-03-13 09:30:00+00:00\n2023-03-13 03:00:00 | 2023-03-13 10:00:00+00:00\n2023-11-05 00:59:00 | 2023-11-05 07:59:00+00:00\n2023-11-05 01:00:00 | 2023-11-05 09:00:00+00:00\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_equal_to()` function is a method in the Pathway framework that asserts that the universe of the current object is a subset of the universe of another object. It is used in situations where Pathway cannot deduce one universe being a subset of another. The function returns none and works in place. The provided example demonstrates how it can be used to merge two tables based on matching values in their columns.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_subset_of(other)` function is a method in the Pathway framework that asserts that the universe of the calling object is a subset of the universe of the input `other` object. It is used in situations where Pathway cannot deduce one universe being a subset of another. The function returns the calling object and the assertion is performed in place. The code example shows how the function can be used to combine two tables with different universes.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "The `promise_universes_are_disjoint(other)` function is part of the Pathway framework and is used to assert that the universe of the current object is disjoint from the universe of another object. It is used in situations where Pathway cannot deduce that the universes are disjoint. The function returns the current object and works in place. The code example shows how this function is used to combine two tables (`t1` and `t2`) and ensure that their universes are disjoint before concatenating them. The resulting table (`t3`) is then printed.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n"}
{"doc": "The `reduce` function is an attribute of a grouped join result in the Pathway framework. It is used to reduce the result of a table to a single value by performing a specified operation. In this example, the `reduce` function is applied to a grouped join result to count the number of pairs for each owner in a given table. The resulting output is a table with the owner and pairs columns.\nreduce(\\*args, \\*\\*kwargs)\nReduces grouped join result to table.\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   cost  owner  pet\n1   100  Alice    1\n2    90    Bob    1\n3    80  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    cost  owner  pet size\n11   100  Alice    3    M\n12    90    Bob    1    L\n13    80    Tom    1   XL\n''')\nresult = (t1.join(t2, t1.owner==t2.owner).groupby(pw.this.owner)\n    .reduce(pw.this.owner, pairs = pw.reducers.count()))\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nowner | pairs\nAlice | 2\nBob   | 1\n```\n::\n::\n\n"}
{"doc": "The documentation explains a function called `promise_universe_is_equal_to` in the Pathway framework. This function checks if the universe of one object is a subset of the universe of another object. It returns None and works in place. The example provided shows how to use this function to combine two tables.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The documentation describes the function `promise_universe_is_subset_of(other)` in the Pathway framework. This function asserts that the universe of `self` is a subset of the universe of each of the other objects and is used in situations where Pathway cannot deduce one universe being a subset of another. The function returns `self` and works in place. The example given demonstrates how to use this function to subset one table based on another.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "The `promise_universes_are_disjoint` function in the Pathway framework is used to assert that the universe of a table is disjoint from the universe of another table. It is used when the framework cannot deduce that the universes are disjoint. The function returns the original table and works in place. The code provided demonstrates how the function can be used to merge two tables with disjoint universes.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n\n"}
{"doc": "The documentation describes a class called `GroupedTable` in the Pathway framework. It takes in a `table` and `grouping_columns` as parameters, and has an optional `set_id` parameter. It represents the result of a groupby operation on a table. The example provided shows how to use this class to group data based on the `pet` and `owner` columns of a table. The `isinstance` function is used to check if the result of the groupby operation is an instance of the `GroupedTable` class.\nclass  pw.GroupedTable(table, grouping_columns, set_id=False)\n\nResult of a groupby operation on a Table.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt2 = t1.groupby(t1.pet, t1.owner)\nisinstance(t2, pw.GroupedTable)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_equal_to` function is used in the Pathway framework to assert that the universe of one object (self) is a subset of the universe of another object (other). It is meant to be used in situations where the framework is unable to deduce that one universe is a subset of another. The function works in place and returns None. The documentation includes an example of using the function to create a new table by concatenating two existing tables.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_subset_of(other)` function is used in the Pathway framework to assert that the universe of `self` is a subset of the universe of the `other`. It is used when Pathway cannot deduce one universe being a subset of another. The function returns `self` and works in place. The example shows how this function is used in practice with two tables.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "This documentation describes the `promise_universes_are_disjoint` attribute of the Pathway framework, which is a function that checks if two universes are disjoint. It is used when Pathway cannot deduce if the universes are disjoint. The function returns the object it was called on and works in place. The code example demonstrates how this function can be used to concatenate two tables with non-disjoint universes.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n"}
{"doc": "The `reduce()` function in the Pathway framework takes a grouped table and reduces it to a table. It has two parameters: `args` for column references and `kwargs` for column expressions with their new assigned names. It returns a table. The function can be used with a groupby operation on a table to obtain a reduced version of that table. The example shows how to group a table by owner and pet, and then reduce it to show the sum of ages for each owner and pet combination.\nreduce(\\*args, \\*\\*kwargs)\nReduces grouped table to a table.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 Column references.\n\n    * kwargs (`ColumnExpression`) \u2013 Column expressions with their new assigned names.\n\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt2 = t1.groupby(t1.pet, t1.owner).reduce(t1.owner, t1.pet, ageagg=pw.reducers.sum(t1.age))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nowner | pet | ageagg\nAlice | cat | 8\nAlice | dog | 10\nBob   | dog | 16\n```\n::\n::\n\n"}
{"doc": "The `ConnectorSubject` is an abstract class in the Pathway framework that allows for the creation of custom Python connectors. The class requires an implementation of the `run()` function, responsible for filling the buffer with data, which is started in a separate thread by the pathway engine. The class provides methods for sending messages, such as `next_json()`, `next_str()`, and `next_bytes()`. Additionally, there are methods for closing the connector, committing messages, and handling the end of the `run()` function.\nclass  pw.io.python.ConnectorSubject()\n\nAn abstract class allowing to create custom python connectors.\n\nCustom python connector can be created by extending this class and implementing\n`run()` function responsible for filling the buffer with data.\nThis function will be started by pathway engine in a separate thread.\n\nIn order to send a message one of the methods\n`next_json()`, `next_str()`, `next_bytes()` can be used.\n\n\n### close()\nSends a sentinel message.\n\nShould be called to indicate that no new messages will be sent.\n\n\n### commit()\nSends a commit message.\n\n\n### next_bytes(message)\nSends a message.\n\n\n* Parameters\n\n    message (`bytes`) \u2013 bytes encoded json string.\n\n\n\n### next_json(message)\nSends a message.\n\n\n* Parameters\n\n    message (`Dict`) \u2013 Dict representing json.\n\n\n\n### next_str(message)\nSends a message.\n\n\n* Parameters\n\n    message (`str`) \u2013 json string.\n\n\n\n### on_stop()\nCalled after the end of the `run()` function.\n\n\n### start()\nRuns a separate thread with function feeding data into buffer.\n\nShould not be called directly.\n\n\n"}
{"doc": "This is a function called `pw.io.python.read` in the Pathway framework that reads a table from a `ConnectorSubject` instance. It takes various parameters such as the format of the output data, columns to extract, primary key, data types, default values, and autocommit duration. It returns the table that was read.\nFunctions\n\n### pw.io.python.read(subject, \\*, format='json', value_columns=None, primary_key=None, types=None, default_values=None, autocommit_duration_ms=10000, debug_data=None)\nReads a table from a ConnectorSubject.\n\n\n* Parameters\n\n    * subject (`ConnectorSubject`) \u2013 An instance of a `ConnectorSubject`\n\n    * format (`str`) \u2013 Format of the data produced by a subject, \u201cjson\u201d or \u201craw\u201d. In case of\n        a \u201craw\u201d format, table with single \u201cdata\u201d column will be produced.\n\n    * value_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 Columns to extract for a table.\n\n    * primary_key (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated randomly.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * autocommit_duration_ms (`int`) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * debug_data \u2013 static data replacing original one when debug mode is active.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n"}
{"doc": "This documentation describes the subpackages, submodules, and classes/functions contained within the \"pathway\" framework's stdlib (standard library) module. The subpackages include graphs (with subpackages for Bellman-Ford, Louvain Communities, PageRank, and utils), indexing, ml (with subpackages for classifiers, datasets, and smart table operations) and more. The documentation also lists some of the submodules and functions within each subpackage.\nSubpackages\n\n* pathway.stdlib.graphs package\n\n    * Subpackages\n\n        * pathway.stdlib.graphs.bellman_ford package\n\n            * Submodules\n\n            * pathway.stdlib.graphs.bellman_ford.impl module\n\n        * pathway.stdlib.graphs.louvain_communities package\n\n            * Submodules\n\n            * pathway.stdlib.graphs.louvain_communities.impl module\n\n        * pathway.stdlib.graphs.pagerank package\n\n            * Submodules\n\n            * pathway.stdlib.graphs.pagerank.impl module\n\n        * pathway.stdlib.graphs.utils package\n\n            * Submodules\n\n            * pathway.stdlib.graphs.utils.clusters module\n\n    * Submodules\n\n    * pathway.stdlib.graphs.common module\n\n* pathway.stdlib.indexing package\n\n    * Submodules\n\n    * pathway.stdlib.indexing.sorting module\n\n* pathway.stdlib.ml package\n\n    * Subpackages\n\n        * pathway.stdlib.ml.classifiers package\n\n        * pathway.stdlib.ml.datasets package\n\n            * Subpackages\n\n        * pathway.stdlib.ml.smart_table_ops package\n\n    * Submodules\n\n    * pathway.stdlib.ml.utils module\n\n* pathway.stdlib.ordered package\n\n    * Submodules\n\n    * pathway.stdlib.ordered.diff module\n\n* pathway.stdlib.statistical package\n\n* pathway.stdlib.temporal package\n\n    * Submodules\n\n    * pathway.stdlib.temporal.utils module\n\n* pathway.stdlib.utils package\n\n    * Submodules\n\n    * pathway.stdlib.utils.async_transformer module\n\n    * pathway.stdlib.utils.bucketing module\n\n    * pathway.stdlib.utils.col module\n\n    * pathway.stdlib.utils.filtering module\n\n    * pathway.stdlib.utils.pandas_transformer module\n"}
{"doc": "This is a documentation for a class called `AsyncTransformer` in the pathway framework. It allows asynchronous transformations on a table and has a method `invoke()` that is called asynchronously for each row of an input table. The resulting table can be accessed via the `result` property. The documentation also includes an example code and explains the use of `close()`, `open()`, and `with_options()` methods.\nclass  pw.AsyncTransformer(input_table)\n\nAllows to perform async transformations on a table.\n\n`invoke()` will be called asynchronously for each row of an input_table.\n\nOutput table can be acccesed via `result`.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nimport asyncio\nclass OutputSchema(pw.Schema):\n   ret: int\n\nclass AsyncIncrementTransformer(pw.AsyncTransformer, output_schema=OutputSchema):\n    async def invoke(self, value) -> Dict[str, Any]:\n        await asyncio.sleep(0.1)\n        return {\"ret\": value + 1 }\n\ninput = pw.debug.parse_to_table('''\n  | value\n1 | 42\n2 | 44\n''')\nresult = AsyncIncrementTransformer(input_table=input).result\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nret\n43\n45\n```\n::\n::\n\n### close()\nCalled once at the end. Proper place for cleanup.\n\n\n### abstract async  invoke(\\*args, \\*\\*kwargs)\nCalled for every row of input_table. The arguments will correspond to the\ncolumns in the input table.\n\nShould return dict of values matching `output_schema`.\n\n\n### open()\nCalled before actual work. Suitable for one time setup.\n\n\n### with_options(capacity=None, retry_strategy=None)\nSets async options.\n\n\n* Parameters\n\n    * capacity (`Optional`\\[`int`\\]) \u2013 maximum number of concurrent operations.\n\n    * retry_strategy (`Optional`\\[`AsyncRetryStrategy`\\]) \u2013 defines how failures will be handled.\n\n\n\n* Returns\n\n    self\n\n\n\n### property  result(: Table )\nResulting table.\n\n\n"}
{"doc": "The documentation describes a class called `ClassArg` in the Pathway framework that can be used as a base class for inner classes when writing class transformers. It provides an example of how to use it in a simple transformer class. Additionally, it mentions a method called `pointer_from()` that produces pointer types based on its argument.\nclass  pw.ClassArg(ref: RowReference, ptr: Pointer)\n\nBase class to inherit from when writing inner classes for class transformers.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n@pw.transformer\nclass simple_transformer:\n    class table(pw.ClassArg):\n        arg = pw.input_attribute()\n        @pw.output_attribute\n        def ret(self) -> int:\n            return self.arg + 1\nt1 = pw.debug.parse_to_table('''\nage\n10\n9\n8\n7\n''')\nt2 = simple_transformer(table=t1.select(arg=t1.age)).table\npw.debug.compute_and_print(t1 + t2, include_id=False)\n```\n::\nResult\n```\nage | ret\n7   | 8\n8   | 9\n9   | 10\n10  | 11\n```\n::\n::\n\n### pointer_from(\\*args, optional=False)\nPseudo-random hash of its argument. Produces pointer types. Applied value-wise.\n\n\n"}
{"doc": "The documentation describes the `pw.Pointer()` class in the Pathway framework, which is used as a pointer to a row type. An example is provided where the `pw.debug.parse_to_table()` function is used to create a table, and the `pw.Pointer()` class is used to select a column from the table. The result of the example is shown as `True`. The documentation is brief and shows how to use `pw.Pointer()`.\nclass  pw.Pointer()\n\nPointer to row type.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt2 = t1.select(col=t1.id)\nt2.schema['col'] is pw.Pointer\n```\n::\nResult\n```\nTrue\n```\n::\n::\n\n"}
{"doc": "The `pw.Schema()` class is a base class used for creating schemas in the Pathway framework. All schemas should be subclasses of this class. The example provided shows how to use the `as_dict()` method to get a dictionary of the schema's attributes, how to check if a schema is a subclass of `pw.Schema()`, and how to create a new schema by inheriting from `pw.Schema()` and adding new attributes to the schema using the union operator (`|`).\nclass  pw.Schema()\n\nBase class to inherit from when creating schemas.\nAll schemas should be subclasses of this one.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   age  owner  pet\n1   10  Alice  dog\n2    9    Bob  dog\n3    8  Alice  cat\n4    7    Bob  dog''')\nt1.schema.as_dict()\n```\n::\nResult\n```\n{'age': <class 'int'>, 'owner': <class 'str'>, 'pet': <class 'str'>}\n```\n::\n::\n\nCode\n```python\nissubclass(t1.schema, pw.Schema)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n\nCode\n```python\nclass NewSchema(pw.Schema):\n  foo: int\nSchemaSum = NewSchema | t1.schema\nSchemaSum.as_dict()\n```\n::\nResult\n```\n{'age': <class 'int'>, 'owner': <class 'str'>, 'pet': <class 'str'>, 'foo': <class 'int'>}\n```\n::\n::\n\n"}
{"doc": "The class `pw.StatsMonitoringLevel()` defines the three levels of verbosity for monitoring the computation graph in the Pathway framework. The `NONE` level means no monitoring, `IN_OUT` level monitors input and output latency, and the `ALL` level monitors latency for each operator in the execution graph. Latency is measured as the difference between the time when the operator processed the data and the time when Pathway acquired the data.\nclass  pw.StatsMonitoringLevel()\n\nSpecifies the verbosity of computation graph monitoring mechanism\n\nNONE: No monitoring\n\nIN_OUT: Monitor input and output latency. The latency is measured as the difference     between the time when the operator processed the data and the time when pathway     acquired the data.\n\nALL: Monitor latency for each operator in the execution graph latency. The latency     is measured as the difference between the time when the operator processed     the data and the time when pathway acquired the data.\n\n\n"}
{"doc": "The documentation describes the TableSlice class in pathway framework, which is a collection of references to table columns and can be created using the slice method or left/right/this constructs. It also supports various column manipulation methods. The example code shows how to use the without and with_suffix methods to remove a column and add a suffix to the remaining columns, respectively, in a given table.\nclass  pw.TableSlice(mapping)\n\nCollection of references to Table columns.\nCreated by Table.slice method, or automatically by using left/right/this constructs.\nSupports basic column manipulation methods.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt1.slice.without(\"age\").with_suffix(\"_col\")\n```\n::\nResult\n```\nTableSlice({'owner_col': <table1>.owner, 'pet_col': <table1>.pet})\n```\n::\n::\n\n"}
{"doc": "This is the documentation for the `pw.left` class in the Pathway framework. It generates column references without holding the actual table in hand and needs to be evaluated in the proper context. It refers to the left input table for Table.join() and JoinResult.select(). The example shows how to use it in a join operation and select statement. The result is a table with selected columns from the left and right tables.\nclass  pw.left(\\*args, \\*\\*kwargs)\n\nObject for generating column references without holding the actual table in hand.\nNeeds to be evaluated in the proper context.\nFor Table.join() and JoinResult.select(), refers to the left input table.\nFor all other situations, you need pw.this object.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, pw.left.pet == pw.right.pet, pw.left.owner == pw.right.owner).select(\n         age=pw.left.age, owner_name=pw.right.owner, size=pw.this.size\n     )\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n\n"}
{"doc": "This documentation describes the `pw.right` class in Pathway Framework. It is an object used for generating column references without holding the actual table in hand and needs to be evaluated in the proper context. It refers to the right input table for `Table.join()` and `JoinResult.select()` and is used in conjunction with `pw.this` for all other situations. An example code block is provided to illustrate its usage.\nclass  pw.right(\\*args, \\*\\*kwargs)\n\nObject for generating column references without holding the actual table in hand.\nNeeds to be evaluated in the proper context.\nFor Table.join() and JoinResult.select(), refers to the right input table.\nFor all other situations, you need pw.this object.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, pw.left.pet == pw.right.pet, pw.left.owner == pw.right.owner).select(\n         age=pw.left.age, owner_name=pw.right.owner, size=pw.this.size\n     )\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n\n"}
{"doc": "This is the documentation for the `pw.this()` class in the Pathway framework. It is used for generating column references without holding the actual table in hand and needs to be evaluated in the proper context. It gives an example of how to use `pw.this()` to select specific columns in a table.\nclass  pw.this(\\*args, \\*\\*kwargs)\n\nObject for generating column references without holding the actual table in hand.\nNeeds to be evaluated in the proper context.\nFor most of the Table methods, it refers to self.\nFor JoinResult, it refers to the left input table.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | 1\n9   | Bob   | 1\n8   | Alice | 2\n''')\nt2 = t1.select(pw.this.owner, pw.this.age)\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nowner | age\nAlice | 8\nAlice | 10\nBob   | 9\n```\n::\n::\n\n"}
{"doc": "The documentation describes the `ColumnReference` class in the Pathway framework, which is used to reference columns in a table. It provides an example of creating a table and checking if the `age` column is an instance of `ColumnReference`, as well as checking for the `owner` column using the indexing notation. The example code shows how to use the `ColumnReference` class in practical use cases.\nclass  pw.ColumnReference(\\*, column, table, name)\n\nReference to the column.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   age  owner  pet\n1   10  Alice  dog\n2    9    Bob  dog\n3    8  Alice  cat\n4    7    Bob  dog''')\nisinstance(t1.age, pw.ColumnReference)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n\nCode\n```python\nisinstance(t1[\"owner\"], pw.ColumnReference)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n"}
{"doc": "The documentation describes the `get()` method of the Tuple class in the pathway framework. It extracts an element at a specified index position from a Tuple object and returns a default value if the specified index is not present. The method accepts two parameters: `index` and `default`. It provides an example code demonstrating the usage of the method to extract elements from a table.\nget(index, default=None)\nExtracts element at index from an object. The object has to be a Tuple.\nIf no element is present at index, it returns value specified by a default parameter.\n\n\n* Parameters\n\n    * index (`Union`\\[`ColumnExpression`, `int`\\]) \u2013 Position to extract element at.\n\n    * default (`Union`\\[`ColumnExpression`, `None`, `int`, `float`, `str`, `bool`, `BasePointer`, `datetime`, `timedelta`, `Tuple`\\[`Any`, `...`\\]\\]) \u2013 Value returned when no element is at position index.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n  | a | b | c\n1 | 3 | 2 | 2\n2 | 4 | 1 | 0\n3 | 7 | 3 | 1\n'''\n)\nt2 = t1.with_columns(tup=pw.make_tuple(pw.this.a, pw.this.b))\nt3 = t2.select(\n    x=pw.this.tup.get(1),\n    y=pw.this.tup.get(3),\n    z=pw.this.tup.get(pw.this.c),\n    t=pw.this.tup.get(pw.this.c, default=100),\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nx | y | z | t\n1 |   | 4 | 4\n2 |   |   | 100\n3 |   | 3 | 3\n```\n::\n::\n"}
{"doc": "The documentation describes the `apply()` function in the Pathway framework, which applies a given function to column expressions. The output column type is determined by the function's type annotations. It includes an example code snippet that uses the `apply()` function to concatenate two columns in a table. The resulting output column contains concatenated strings.\npw.apply(fun, \\*args, \\*\\*kwargs)\nApplies function to column expressions, column-wise.\nOutput column type deduced from type-annotations of a function.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ndef concat(left: str, right: str) -> str:\n  return left+right\nt1 = pw.debug.parse_to_table('''\nage  owner  pet\n 10  Alice  dog\n  9    Bob  dog\n  8  Alice  cat\n  7    Bob  dog''')\nt2 = t1.select(col = pw.apply(concat, t1.owner, t1.pet))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\ncol\nAlicecat\nAlicedog\nBobdog\nBobdog\n```\n::\n::\n"}
{"doc": "The code snippet shows an example of using the `apply_async` function in the Pathway framework. This function applies a provided function asynchronously to column expressions column-wise with the output column type deduced from type-annotations of a function. The example uses an async function called 'concat' to concatenate values from two columns in a table. The resulting output is a new table with the concatenated values in a new column called 'col'.\npw.apply_async(fun, \\*args, \\*\\*kwargs)\nApplies function asynchronously to column expressions, column-wise.\nOutput column type deduced from type-annotations of a function.\nEiterh a regular or async function can be passed.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nimport asyncio\nasync def concat(left: str, right: str) -> str:\n  await asyncio.sleep(0.1)\n  return left+right\nt1 = pw.debug.parse_to_table('''\nage  owner  pet\n 10  Alice  dog\n  9    Bob  dog\n  8  Alice  cat\n  7    Bob  dog''')\nt2 = t1.select(col = pw.apply_async(concat, t1.owner, t1.pet))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\ncol\nAlicecat\nAlicedog\nBobdog\nBobdog\n```\n::\n::\n"}
{"doc": "The `pw.apply_with_type` function is used in the Pathway framework to apply a function to column expressions in a table. The output column type is explicitly provided as an argument. In the example provided, the function concatenates two columns (owner and pet) and the output type is a string. The resulting table has a new column called \"col\" that contains the concatenated strings.\npw.apply_with_type(fun, ret_type, \\*args, \\*\\*kwargs)\nApplies function to column expressions, column-wise.\nOutput column type is provided explicitly.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   age  owner  pet\n1   10  Alice  dog\n2    9    Bob  dog\n3    8  Alice  cat\n4    7    Bob  dog''')\nt2 = t1.select(col = pw.apply_with_type(lambda left, right: left+right, str, t1.owner, t1.pet))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\ncol\nAlicecat\nAlicedog\nBobdog\nBobdog\n```\n::\n::\n"}
{"doc": "The `pw.attribute(func, **kwargs)` is a decorator that can be used to create attributes in the Pathway framework. In the example provided, it is used to create the \"attr\" attribute within the \"simple_transformer\" class, which returns twice the value of its input attribute. Additionally, the `pw.output_attribute` decorator is used to create the \"ret\" attribute, which returns the value of \"attr\" plus one. The example also includes sample code for using the transformer and its attributes to manipulate tables. The result of the computation is a table with two columns: \"age\" and \"ret\", where \"ret\" is calculated using the \"attr\" attribute and the \"arg\" input attribute.\npw.attribute(func, \\*\\*kwargs)\nDecorator for creation of attributes.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n@pw.transformer\nclass simple_transformer:\n    class table(pw.ClassArg):\n        arg = pw.input_attribute()\n\n        @pw.attribute\n        def attr(self) -> float:\n            return self.arg*2\n\n        @pw.output_attribute\n        def ret(self) -> float:\n            return self.attr + 1\n\nt1 = pw.debug.parse_to_table('''\nage\n10\n9\n8\n7''')\nt2 = simple_transformer(table=t1.select(arg=t1.age)).table\npw.debug.compute_and_print(t1 + t2, include_id=False)\n```\n::\nResult\n```\nage | ret\n7   | 15\n8   | 17\n9   | 19\n10  | 21\n```\n::\n::\n"}
{"doc": "The documentation describes the `pw.cast()` function in the Pathway framework which changes the data type of a column to the specified target type and converts the data in the column. An example is provided which demonstrates how the function is applied to a table and how it changes the data type of a column from integer to float. The `pw.debug.parse_to_table()` and `pw.debug.compute_and_print()` functions are also used to create and display the table respectively.\npw.cast(target_type, col)\nChanges the type of the column to target_type and converts the data of this column\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  val\n1   10\n2    9\n3    8\n4    7''')\nt1.schema.as_dict()\n```\n::\nResult\n```\n{'val': <class 'int'>}\n```\n::\n::\n\nCode\n```python\npw.debug.compute_and_print(t1, include_id=False)\n```\n::\nResult\n```\nval\n7\n8\n9\n10\n```\n::\n::\n\nCode\n```python\nt2 = t1.select(val = pw.cast(float, t1.val))\nt2.schema.as_dict()\n```\n::\nResult\n```\n{'val': <class 'float'>}\n```\n::\n::\n\nCode\n```python\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nval\n7.0\n8.0\n9.0\n10.0\n```\n::\n::\n"}
{"doc": "The `pw.coalesce()` function in the Pathway framework takes any number of arguments and returns the first argument that is not None. This is useful for handling cases where a value may be missing or undefined. The example code shows how to use `pw.coalesce()` to select a value from one of two columns in a table.\npw.coalesce(\\*args)\nFor arguments list arg_1, arg_2, \u2026, arg_n returns first not-None value.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\ncolA   colB\n     |   10\n   2 |\n     |\n   4 |    7''')\nt2 = t1.select(t1.colA, t1.colB, col=pw.coalesce(t1.colA, t1.colB))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\ncolA | colB | col\n     |      |\n     | 10   | 10\n2    |      | 2\n4    | 7    | 4\n```\n::\n::\n"}
{"doc": "The documentation describes the `pw.declare_type(target_type, col)` function in the Pathway framework. This function is used to change the type of a column to a specific target type, without changing the actual values stored in the column. The example provided shows how the function can be used to change the type of a column in a table schema from `int` to `int | float`.\npw.declare_type(target_type, col)\nUsed to change the type of a column to a particular type.\nDisclaimer: it only changes type in a schema, it does not affect values stored.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   val\n1   10\n2    9\n3    8\n4    7''')\nt1.schema.as_dict()\n```\n::\nResult\n```\n{'val': <class 'int'>}\n```\n::\n::\n\nCode\n```python\nt2 = t1.select(val = pw.declare_type(int | float, t1.val))\nt2.schema.as_dict()\n```\n::\nResult\n```\n{'val': int | float}\n```\n::\n::\n"}
{"doc": "The documentation describes the usage of the \"if_else\" function in the Pathway framework. It states that the function takes three arguments, if_clause, then_clause, and else_clause, and returns the then_clause if the if_clause is true, and else_clause otherwise. It provides an equivalent code example in Python and a usage example in the context of the Pathway framework that shows how to use \"if_else\" to create a new column in a table.\npw.if_else(if_clause, then_clause, else_clause)\nEquivalent to:\n\n\n```default\nif (if_clause):\n    return (then_clause)\nelse:\n    return (else_clause)\n```\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\ncolA   colB\n   1 |    0\n   2 |    2\n   6 |    3''')\nt2 = t1.select(res = pw.if_else(t1.colB != 0, t1.colA // t1.colB, 0))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nres\n0\n1\n2\n```\n::\n::\n"}
{"doc": "This documentation describes the `pw.input_attribute()` function in the Pathway framework, which returns a new input attribute to be used inside class transformers. It includes an example code snippet of how the function can be used within a transformer class to select a specific attribute from a table and add 1 to its values. The result of the computation is also shown.\npw.input_attribute(type=<class 'float'>)\nReturns new input_attribute. To be used inside class transformers.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n@pw.transformer\nclass simple_transformer:\n    class table(pw.ClassArg):\n        arg = pw.input_attribute()\n\n        @pw.output_attribute\n        def ret(self) -> float:\n            return self.arg + 1\n\nt1 = pw.debug.parse_to_table('''\nage\n10\n9\n8\n7''')\nt2 = simple_transformer(table=t1.select(arg=t1.age)).table\npw.debug.compute_and_print(t1 + t2, include_id=False)\n```\n::\nResult\n```\nage | ret\n7   | 8\n8   | 9\n9   | 10\n10  | 11\n```\n::\n::\n"}
{"doc": "The documentation describes how to use the `pw.input_method()` decorator to define input methods in class transformers. It includes an example code snippet that shows how to define and use input methods in two different transformers (`first_transformer` and `second_transformer`) to manipulate data in a table. The documentation provides details on the arguments and return value of the example method (`fun`). Finally, the documentation includes the expected output of the example code snippet.\npw.input_method(type=<class 'float'>)\nDecorator for defining input methods in class transformers.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n@pw.transformer\nclass first_transformer:\n    class table(pw.ClassArg):\n        a: float = pw.input_attribute()\n\n        @pw.method\n        def fun(self, arg) -> int:\n            return self.a * arg\n\n@pw.transformer\nclass second_transformer:\n    class table(pw.ClassArg):\n        m = pw.input_method(int)\n\n        @pw.output_attribute\n        def val(self):\n            return self.m(2)\n\nt1 = pw.debug.parse_to_table('''\nage\n10\n9\n8\n7''')\nt2 = first_transformer(table=t1.select(a=t1.age)).table\nt2.schema.as_dict()\n```\n::\nResult\n```\n{'fun': typing.Callable[..., int]}\n```\n::\n::\n\nCode\n```python\nt3 = second_transformer(table=t2.select(m=t2.fun)).table\npw.debug.compute_and_print(t1 + t3, include_id=False)\n```\n::\nResult\n```\nage | val\n7   | 14\n8   | 16\n9   | 18\n10  | 20\n```\n::\n::\n"}
{"doc": "The `pw.iterate()` function in Pathway framework is used to iterate a given function until a fixed point is reached. The function should take only named arguments and tables and return a dictionary of tables. The initial arguments can be passed using `kwargs`. The example given shows how to use the `pw.iterate()` function with a function that performs the Collatz conjecture on a table. The output of the function is a dictionary of tables.\npw.iterate(func, iteration_limit=None, \\*\\*kwargs)\nIterate function until fixed point.\nFunction has to take only named arguments, Tables, and return a dict of Tables.\nInitial arguments to function are passed through kwargs.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ndef collatz_transformer(iterated):\n    def collatz_step(x: int) -> int:\n        if x == 1:\n            return 1\n        elif x % 2 == 0:\n            return x / 2\n        else:\n            return 3 * x + 1\n    new_iterated = iterated.select(val=pw.apply(collatz_step, iterated.val))\n    return dict(iterated=new_iterated)\ntab = pw.debug.parse_to_table('''\nval\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8''')\nret = pw.iterate(collatz_transformer, iterated=tab).iterated\npw.debug.compute_and_print(ret, include_id=False)\n```\n::\nResult\n```\nval\n1\n1\n1\n1\n1\n1\n1\n1\n```\n::\n::\n"}
{"doc": "The `pw.make_tuple(*args)` function creates a tuple from the provided expressions in the arguments. The function takes a list of expressions that can be of various types such as ColumnExpression, int, float, str, bool, BasePointer, datetime, timedelta, and Tuple. The function returns a tuple. Each cell in the output column will be a tuple containing the corresponding values from the input columns. The order of values in each tuple will match the order of the input columns. If any of the input columns have missing values, the resulting tuples will contain None for those positions. An example code is provided in which a table is created and `pw.make_tuple()` is used to create a new table with tuples containing the values from the columns of the input table.\npw.make_tuple(\\*args)\nCreates a tuple from the provided expressions.\n\n\n* Parameters\n\n    args (`Union`\\[`ColumnExpression`, `None`, `int`, `float`, `str`, `bool`, `BasePointer`, `datetime`, `timedelta`, `Tuple`\\[`Any`, `...`\\]\\]) \u2013 a list of expressions to be put in a tuple\n\n\n\n* Returns\n\n    tuple\n\n\nNOTE: * Each cell in the output column will be a tuple containing the corresponding values from the input         columns.\n\n* The order of values in each tuple will match the order of the input columns.\n\n* If any of the input columns have missing values, the resulting tuples will contain None for those         positions.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown(\n    '''\nA | B  | C\n1 | 10 | a\n2 | 20 |\n3 | 30 | c\n'''\n)\ntable_with_tuple = table.select(res=pw.make_tuple(pw.this.A, pw.this.B, pw.this.C))\npw.debug.compute_and_print(table_with_tuple, include_id=False)\n```\n::\nResult\n```\nres\n(1, 10, 'a')\n(2, 20, None)\n(3, 30, 'c')\n```\n::\n::\n"}
{"doc": "The `pw.method()` is a decorator used in the pathway framework to create methods in class transformers. It is used along with the `@pw.transformer` decorator. The example shows how to create a simple transformer class with input and output attributes and a method, and how to use it to transform a table. The `pw.debug.compute_and_print()` function is used to compute and print the results.\npw.method(func, \\*\\*kwargs)\nDecorator for creation methods in class transformers.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n@pw.transformer\nclass simple_transformer:\n    class table(pw.ClassArg):\n        a: float = pw.input_attribute()\n\n        @pw.output_attribute\n        def b(self) -> float:\n            return self.fun(self.a)\n\n        @method\n        def fun(self, arg) -> float:\n            return self.a * arg\n\nt1 = pw.debug.parse_to_table('''\nage\n10\n9\n8\n7''')\nt2 = simple_transformer(table=t1.select(a=t1.age)).table\nt2.schema.as_dict()\n```\n::\nResult\n```\n{'b': <class 'float'>, 'fun': typing.Callable[..., float]}\n```\n::\n::\n\nCode\n```python\npw.debug.compute_and_print(t1 + t2.select(t2.b), include_id=False)\n```\n::\nResult\n```\nage | b\n7   | 49\n8   | 64\n9   | 81\n10  | 100\n```\n::\n::\n\nCode\n```python\npw.debug.compute_and_print(t1 + t2.select(out = t2.fun(t2.b)), include_id=False)\n```\n::\nResult\n```\nage | out\n7   | 343\n8   | 512\n9   | 729\n10  | 1000\n```\n::\n::\n"}
{"doc": "The pw.numba_apply() function applies a given numba-compilable function to column expressions in a table, column-wise. The function must be unary or binary, and the arguments and return type must be either int64 or float64. The example code provided multiplies each value in the 'val' column of a table by itself, subtracts 2 times the value, and adds 1, then puts the result in a new column 'col'.\npw.numba_apply(fun, numba_signature, \\*args, \\*\\*kwargs)\nApplies function to column expressions, column-wise.\nFunction has to be numba compilable.\n\nCurrently only a few signatures are supported:\n- function has to be unary or binary\n- arguments and return type has to be either int64 or float64\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   val\n1    1\n2    3\n3    5\n4    7''')\nt2 = t1.select(col = pw.numba_apply(lambda x: x*x-2*x+1, \"int64(int64,)\", t1.val))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\ncol\n0\n4\n16\n36\n```\n::\n::\n"}
{"doc": "The `pw.output_attribute` is a decorator in the Pathway framework that creates output attributes. In the example provided, a transformer class called \"simple_transformer\" is defined which contains an input attribute \"arg\" and an output attribute \"ret\". The output attribute is created using the `pw.output_attribute` decorator. When the example is executed, the output attribute \"ret\" returns the value of the input attribute \"arg\" plus 1. The result is printed as a table with two columns, \"age\" and \"ret\".\npw.output_attribute(func, \\*\\*kwargs)\nDecorator for creation of output_attributes.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n@pw.transformer\nclass simple_transformer:\n    class table(pw.ClassArg):\n        arg = pw.input_attribute()\n\n        @pw.output_attribute\n        def ret(self) -> float:\n            return self.arg + 1\n\nt1 = pw.debug.parse_to_table('''\nage\n10\n9\n8\n7''')\nt2 = simple_transformer(table=t1.select(arg=t1.age)).table\npw.debug.compute_and_print(t1 + t2, include_id=False)\n```\n::\nResult\n```\nage | ret\n7   | 8\n8   | 9\n9   | 10\n10  | 11\n```\n::\n::\n"}
{"doc": "This piece of documentation describes a Python function decorator called `pw.pandas_transformer` in the Pathway framework. It converts a Python function that works with pandas DataFrames into a pathway transformer. The input universes are converted into input DataFrame indexes, and the resulting index is treated as the output universe. The `output_schema` parameter is the schema of the resulting table, and `output_universe` is the index or name of an argument whose universe will be used in the resulting table. The function returns a transformer that can be applied on Pathway tables.\npw.pandas_transformer(output_schema, output_universe=None)\nDecorator that turns python function operating on pandas.DataFrame into pathway transformer.\n\nInput universes are converted into input DataFrame indexes.\nThe resulting index is treated as the output universe, so it must maintain uniqueness\nand be of integer type.\n\n\n* Parameters\n\n    * output_schema (`Type`\\[`Schema`\\]) \u2013 Schema of a resulting table.\n\n    * output_universe (`Union`\\[`str`, `int`, `None`\\]) \u2013 Index or name of an argument whose universe will be used\n\n    * None. (*in resulting table. Defaults to*) \u2013 \n\n\n\n* Returns\n\n    Transformer that can be applied on Pathway tables.\n\n\n"}
{"doc": "The `pw.require(val, *deps)` function in the Pathway framework checks whether all the dependencies specified in `deps` are not None. If all of them are not None, then it returns `val`, otherwise, it returns None. An example is given where this function is used to select certain columns from a table and compute their sum only if both columns have values.\npw.require(val, \\*deps)\nReturns val iff every dep in deps is not-None.\nReturns None otherwise.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\ncolA   colB\n     |   10\n   2 |\n     |\n   4 |    7''')\nt2 = t1.select(t1.colA, t1.colB, col=pw.require(t1.colA + t1.colB, t1.colA, t1.colB))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\ncolA | colB | col\n     |      |\n     | 10   |\n2    |      |\n4    | 7    | 11\n```\n::\n::\n"}
{"doc": "This documentation describes the `pw.schema_from_types` function in the Pathway framework. This function constructs a schema from key-value pairs where the keys are field names and the values are their respective types. The example code shows how to use this function to create a schema with two fields, `foo` of type `int` and `bar` of type `str`, and then convert it to a dictionary using the `as_dict` method. The second example code checks if the schema is a subclass of the `pw.Schema` class and returns `True`.\npw.schema_from_types(_name=None, \\*\\*kwargs)\nConstructs schema from kwargs: field=type.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ns = pw.schema_from_types(foo=int, bar=str)\ns.as_dict()\n```\n::\nResult\n```\n{'foo': <class 'int'>, 'bar': <class 'str'>}\n```\n::\n::\n\nCode\n```python\nissubclass(s, pw.Schema)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n"}
{"doc": "This is a piece of documentation about the `pw.transformer(cls)` decorator in the Pathway framework. The decorator is used to wrap the outer class when defining class transformers. The example code included demonstrates how to use this decorator to create a simple transformer that selects a column from a table and adds 1 to each value in that column. The result is output as a new table. The input and output attributes of the transformer are defined using `pw.input_attribute()` and `pw.output_attribute()` decorators respectively. The `compute_and_print()` method is used to execute the transformation and display the output table.\npw.transformer(cls)\nDecorator that wraps the outer class when defining class transformers.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n@pw.transformer\nclass simple_transformer:\n    class table(pw.ClassArg):\n        arg = pw.input_attribute()\n\n        @pw.output_attribute\n        def ret(self) -> float:\n            return self.arg + 1\n\nt1 = pw.debug.parse_to_table('''\nage\n10\n9\n8\n7''')\nt2 = simple_transformer(table=t1.select(arg=t1.age)).table\npw.debug.compute_and_print(t1 + t2, include_id=False)\n```\n::\nResult\n```\nage | ret\n7   | 8\n8   | 9\n9   | 10\n10  | 11\n```\n::\n::\n"}
{"doc": "The `pw.sql()` function in the Pathway framework allows you to run a SQL query on Pathway tables. It takes a SQL query string as input and optionally an association name that binds table names used in the query. The output is a Pathway table that can be manipulated further. The supported SQL keywords and operations include SELECT, WHERE, arithmetic operations, GROUP BY, HAVING, UNION, INTERSECTION, JOIN, and WITH. However, ordering operations, INSERT INTO, anonymous columns, COALESCE, IFNULL, FULL JOIN, NATURAL JOIN, and CAST are not supported.\npw.sql(query, \\*\\*kwargs)\nRun a SQL query on Pathway tables.\n\n\n* Parameters\n\n    * query (`str`) \u2013 the SQL query to execute.\n\n    * kwargs (`Table`) \u2013 the association name: table used for the execution of the SQL query. Each name:table pair links a Pathway table to a table name used in the SQL query.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt = pw.debug.table_from_markdown(\n    \"\"\"\n      A  | B\n      1  | 2\n      4  | 3\n      4  | 7\n    \"\"\"\n)\nret = pw.sql(\"SELECT * FROM tab WHERE A<B\", tab=t)\npw.debug.compute_and_print(ret, include_id=False)\n```\n::\nResult\n```\nA | B\n1 | 2\n4 | 7\n```\n::\n::\nSupported SQL keywords and operations:\nSELECT, WHERE, boolean expressions, arithmetic operations, GROUP BY, HAVING, AS (alias), UNION, INTERSECTION, JOIN, and WITH.\n\nTable and column names are case-sensitive.\n\nSpecificities of Pathway:\n- id is a reserved key word for columns, every Pathway table has a special column id. This column is not captured by \\* expressions in SQL.\n- Order of columns might not be preserved with respect to SELECT query.\n- Pathway reducers (pw.count, pw.sum, etc.) aggregate over None values, while SQL aggregation functions (COUNT, SUM, etc.) skip NULL values.\n- UNION requires matching column names.\n- INTERSECT requires matching column names.\n\nLimited support:\n- Subqueries are supported but fragile \u2013 they depend on a set of query rewriting routines from the sqlglot library.\n- Additionally, using the id column in subqueries is fragile.\n- LIKE, ANY, ALL, EXISTS are not supported, or only supported in a very weak state.\n\nUnsupported operations:\n- ordering operations: ORDER BY, LIMIT, SELECT TOP\n- INSERT INTO (Pathway tables are immutable)\n- Pathway does not support anonymous columns: they might work but we do not guarantee their behavior.\n- INTERSECT does not support INTERSECT ALL.\n- COALESCE, IFNULL are not supported.\n- FULL JOIN and NATURAL JOIN are not supported.\n- CAST is not supported\n\n"}
{"doc": "This documentation describes functions related to K-Nearest Neighbor (KNN) classifiers in the Pathway framework. The functions include building a Locality Sensitive Hashing (LSH) index over data, classifying the queries, and training the LSH index using different distance metrics like Euclidean and generic LSH projectors. The number of repetitions of the LSH scheme is described by the parameter L.\nFunctions\n\n### pw.stdlib.ml.classifiers.knn_lsh_classifier_train(data, L, type='euclidean', \\*\\*kwargs)\nBuild the LSH index over data.\nL the number of repetitions of the LSH scheme.\nReturns a LSH projector of type (queries: Table, k:Any) -> Table\n\n\n### pw.stdlib.ml.classifiers.knn_lsh_classify(knn_model, data_labels, queries, k)\nClassify the queries.\nUse the knn_model to extract the k closest datapoints.\nThe queries are then labeled using a majority vote between the labels\nof the retrieved datapoints, using the labels provided in data_labels.\n\n\n### pw.stdlib.ml.classifiers.knn_lsh_euclidean_classifier_train(data, d, M, L, A)\nBuild the LSH index over data using the Euclidean distances.\nd is the dimension of the data, L the number of repetition of the LSH scheme,\nM and A are specific to LSH with Euclidean distance, M is the number of random projections\ndone to create each bucket and A is the width of each bucket on each projection.\n\n\n### pw.stdlib.ml.classifiers.knn_lsh_generic_classifier_train(data, lsh_projection, distance_function, L)\nBuild the LSH index over data using the a generic lsh_projector and its associated distance.\nL the number of repetitions of the LSH scheme.\nReturns a LSH projector of type (queries: Table, k:Any) -> Table\n\n\n### pw.stdlib.ml.classifiers.knn_lsh_train(data, L, type='euclidean', \\*\\*kwargs)\nBuild the LSH index over data.\nL the number of repetitions of the LSH scheme.\nReturns a LSH projector of type (queries: Table, k:Any) -> Table\n"}
{"doc": "This is documentation for the `AsyncTransformer` class in the Pathway framework. It allows for asynchronous transformations of a table, with `invoke()` being called for each row of an input table. The resulting output table can be accessed via `result`. The example provided shows an `AsyncIncrementTransformer` class that increments the value of each row of an input table by 1. The documentation also includes information on the `close()`, `open()`, and `result` methods, as well as the `with_options()` function for setting async options.\nclass  pw.stdlib.utils.async_transformer.AsyncTransformer(input_table)\n\nAllows to perform async transformations on a table.\n\n`invoke()` will be called asynchronously for each row of an input_table.\n\nOutput table can be acccesed via `result`.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nimport asyncio\nclass OutputSchema(pw.Schema):\n   ret: int\n\nclass AsyncIncrementTransformer(pw.AsyncTransformer, output_schema=OutputSchema):\n    async def invoke(self, value) -> Dict[str, Any]:\n        await asyncio.sleep(0.1)\n        return {\"ret\": value + 1 }\n\ninput = pw.debug.parse_to_table('''\n  | value\n1 | 42\n2 | 44\n''')\nresult = AsyncIncrementTransformer(input_table=input).result\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nret\n43\n45\n```\n::\n::\n\n### close()\nCalled once at the end. Proper place for cleanup.\n\n\n### abstract async  invoke(\\*args, \\*\\*kwargs)\nCalled for every row of input_table. The arguments will correspond to the\ncolumns in the input table.\n\nShould return dict of values matching `output_schema`.\n\n\n### open()\nCalled before actual work. Suitable for one time setup.\n\n\n### property  result(: Table )\nResulting table.\n\n\n### with_options(capacity=None, retry_strategy=None)\nSets async options.\n\n\n* Parameters\n\n    * capacity (`Optional`\\[`int`\\]) \u2013 maximum number of concurrent operations.\n\n    * retry_strategy (`Optional`\\[`AsyncRetryStrategy`\\]) \u2013 defines how failures will be handled.\n\n\n\n* Returns\n\n    self\n\n\n"}
{"doc": "This documentation describes a Python module called `pandas_transformer` in the `pathway.stdlib.utils` package. It defines a decorator `pandas_transformer` that can be used to turn a Python function that operates on a pandas DataFrame into a pathway transformer. The decorator takes an output schema and an optional output universe, which specifies the index or name of an argument whose universe will be used in the resulting table. The decorator returns a transformer that can be applied on Pathway tables.\npathway.stdlib.utils.pandas_transformer module\n\n\n### pw.stdlib.utils.pandas_transformer.pandas_transformer(output_schema, output_universe=None)\nDecorator that turns python function operating on pandas.DataFrame into pathway transformer.\n\nInput universes are converted into input DataFrame indexes.\nThe resulting index is treated as the output universe, so it must maintain uniqueness\nand be of integer type.\n\n\n* Parameters\n\n    * output_schema (`Type`\\[`Schema`\\]) \u2013 Schema of a resulting table.\n\n    * output_universe (`Union`\\[`str`, `int`, `None`\\]) \u2013 Index or name of an argument whose universe will be used\n\n    * None. (*in resulting table. Defaults to*) \u2013 \n\n\n\n* Returns\n\n    Transformer that can be applied on Pathway tables.\n"}
{"doc": "The function pw.stdlib.utils.col.apply_all_rows applies a given function to all the data in selected columns at once. It takes a list of columns, a function that operates on those columns and returns a corresponding list of outputs, and the name of the output column. The output is a table with a single column containing the results of the apply function, indexed with the original indices. This transformer is intended for infrequent use on small tables.\npw.stdlib.utils.col.apply_all_rows(\\*cols, fun, result_col_name)\nApplies a function to all the data in selected columns at once, returning a single column.\nThis transformer is meant to be run infrequently on a relativelly small tables.\n\nInput:\n- cols: list of columns to which function will be applied\n- fun: function taking lists of columns and returning a corresponding list of outputs.\n- result_col_name: name of the output column\n\nOutput:\n- Table indexed with original indices with a single column named by \u201cresult_col_name\u201d argument\ncontaining results of the apply\n\n"}
{"doc": "The `flatten_column` function in the `pw.stdlib.utils.col` module is used to flatten a column in a table. It takes in two parameters: `column`, which is the column expression of the column to be flattened, and `origin_id`, which is the name of the output column where the id's of input rows will be stored (if not None). The output of the function is a table with columns `colname_to_flatten` and `origin_id` (if not None).\npw.stdlib.utils.col.flatten_column(column, origin_id=<table1>.origin_id)\nFlattens a column of a table.\n\nInput:\n- column: Column expression of column to be flattened\n- origin_id: name of output column where to store id\u2019s of input rows\n\nOutput:\n- Table with columns: colname_to_flatten and origin_id (if not None)\n\n"}
{"doc": "The pw.stdlib.utils.col.multiapply_all_rows function can be used to apply a function to multiple columns of data at once, returning multiple output columns. The function takes in the columns to be operated on, the function to apply, and the names of the output columns. The output is a table indexed with the original indices and containing the results of the apply. This transformer is designed to be used infrequently on small tables.\npw.stdlib.utils.col.multiapply_all_rows(\\*cols, fun, result_col_names)\nApplies a function to all the data in selected columns at once, returning multiple columns.\nThis transformer is meant to be run infrequently on a relativelly small tables.\n\nInput:\n- cols: list of columns to which function will be applied\n- fun: function taking lists of columns and returning a corresponding list of outputs.\n- result_col_names: names of the output columns\n\nOutput:\n- Table indexed with original indices with columns named by \u201cresult_col_names\u201d argument\ncontaining results of the apply\n\n"}
{"doc": "The pw.io.s3_csv.read() function reads a table from one or several objects in an Amazon S3 bucket. It takes in parameters such as path, aws_s3_settings, value_columns, id_columns, csv_settings, mode, types, default_values, autocommit_duration_ms, persistent_id, and debug_data. The function returns a Table object. An example usage of the function is also provided.\npw.io.s3_csv.read(path, aws_s3_settings, value_columns, id_columns=None, csv_settings=None, mode='streaming', types=None, default_values=None, autocommit_duration_ms=None, persistent_id=None, debug_data=None, \\*\\*kwargs)\nReads a table from one or several objects in Amazon S3 bucket.\n\nIn case the prefix is specified, and there are several objects lying under this prefix,\ntheir order is determined according to their modification times: the smaller the\nmodification time is, the earlier the file will be passed to the engine.\n\n\n* Parameters\n\n    * path (`str`) \u2013 Path to an object or to a folder of objects in Amazon S3 bucket.\n\n    * aws_s3_settings (`AwsS3Settings`) \u2013 Connection parameters for the S3 account and the bucket.\n\n    * value_columns (`List`\\[`str`\\]) \u2013 Names of the columns to be extracted from the files.\n\n    * id_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated randomly.\n\n    * csv_settings (`Optional`\\[`CsvParserSettings`\\]) \u2013 The settings for the CSV parser.\n\n    * mode (`str`) \u2013 If set to \u201cstreaming\u201d, the engine will wait for the new input files in the bucket, which fall under the path prefix. Set it to \u201cstatic\u201d, it will onlyconsider the available data and ingest all of it in one commit. Default value is\u201dstreaming\u201d.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nExample:\n\nLet\u2019s consider an object store, which is hosted in Amazon S3. The store contains\ndatasets in the respective bucket and is located in the region eu-west-3. The goal\nis to read the dataset, located under the path animals/ in this bucket.\n\nThen, the code may look as follows:\n\n\n```python\nimport os\nimport pathway as pw\nt = pw.io.s3_csv.read(\n    \"animals/\",\n    aws_s3_settings=pw.io.s3_csv.AwsS3Settings.AwsS3Settings(\n        bucket_name=\"datasets\",\n        region=\"eu-west-3\",\n        access_key=os.environ[\"S3_ACCESS_KEY\"],\n        secret_access_key=os.environ[\"S3_SECRET_ACCESS_KEY\"],\n    ),\n    value_columns=[\"owner\", \"pet\"],\n)\n```\nAlternatively, there might be a need to read the data from S3 storage, which is\nhosted in a different cloud and, therefore, requires to specify a custom endpoint.\n\nIt can be done with the usage of an extra parameter endpoint of AwsS3Settings\nobject. An example for the OVH-hosted bucket would then look as follows:\n\n\n```python\nimport os\nimport pathway as pw\nt = pw.io.s3_csv.read(\n    \"animals/\",\n    aws_s3_settings=pw.io.s3_csv.AwsS3Settings.AwsS3Settings(\n        bucket_name=\"datasets\",\n        region=\"rbx\",\n        endpoint=\"s3.rbx.io.cloud.ovh.net\",\n        access_key=os.environ[\"OVH_S3_ACCESS_KEY\"],\n        secret_access_key=os.environ[\"OVH_S3_SECRET_ACCESS_KEY\"],\n    ),\n    value_columns=[\"owner\", \"pet\"],\n)\n```\nIn case you are dealing with custom S3 buckets, there are two ways\nto work with paths in requests. The default and the one used by AWS S3 is a\nvirtually hosted-style. However, some installations of S3 in, for example, min.io\ndo require to use of path-style requests. If this is the case, you can use the\nparameter with_path_style of AwsS3Settings.\n\nThen, the code may look as follows:\n\n\n```python\nimport os\nimport pathway as pw\nt = pw.io.s3_csv.read(\n    \"animals/\",\n    aws_s3_settings=pw.io.s3_csv.AwsS3Settings.AwsS3Settings(\n        bucket_name=\"datasets\",\n        endpoint=\"avv749.stackhero-network.com\",\n        access_key=os.environ[\"MINIO_S3_ACCESS_KEY\"],\n        secret_access_key=os.environ[\"MINIO_S3_SECRET_ACCESS_KEY\"],\n        with_path_style=True,\n    ),\n    value_columns=[\"owner\", \"pet\"],\n)\n```\n"}
{"doc": "This is a documentation for the function \"interpolate\" in the Pathway framework, which takes in a column of timestamps and one or more columns of values, and interpolates missing values between two non-missing values in the specified columns. It returns a new table with the interpolated values. The only supported interpolation mode is linear. The function raises a ValueError if the columns are not ColumnReference or if the interpolation mode is not supported. It includes an example usage of the function with input and output tables.\nFunctions\n\n### pw.stdlib.statistical.interpolate(self, timestamp, \\*values, mode=InterpolateMode.LINEAR)\nInterpolates missing values in a column using the previous and next values based on a timestamps column.\n\n\n* Parameters\n\n    * timestamp (*ColumnReference*) \u2013 Reference to the column containing timestamps.\n\n    * \\*values (*ColumnReference*) \u2013 References to the columns containing values to be interpolated.\n\n    * mode (*InterpolateMode, optional*) \u2013 The interpolation mode. Currently,            only InterpolateMode.LINEAR is supported. Default is InterpolateMode.LINEAR.\n\n\n\n* Returns\n\n    *Table* \u2013 A new table with the interpolated values.\n\n\n\n* Raises\n\n    ValueError \u2013 If the columns are not ColumnReference or if the interpolation mode is not supported.\n\n\nNOTE: * The interpolation is performed based on linear interpolation between the previous and next values.\n\n* If a value is missing at the beginning or end of the column, no interpolation is performed.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\ntimestamp | values_a | values_b\n1         | 1        | 10\n2         |          |\n3         | 3        |\n4         |          |\n5         |          |\n6         | 6        | 60\n''')\ntable = table.interpolate(pw.this.timestamp, pw.this.values_a, pw.this.values_b)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\ntimestamp | values_a | values_b\n1         | 1        | 10\n2         | 2.0      | 20.0\n3         | 3        | 30.0\n4         | 4.0      | 40.0\n5         | 5.0      | 50.0\n6         | 6        | 60\n```\n::\n::\n"}
{"doc": "The first function computes the modularity of a given weighted graph using exact total weight in the computation. It rounds the modularity to a specified number of decimal places and returns the rounded result. The second function uses Louvain community detection algorithm to find a clustering that is a local maximum with respect to the objective function, given a weighted graph.\nFunctions\n\n### pw.stdlib.graphs.louvain_communities.impl.exact_modularity(G, C, round_digits=16)\nThis function computes modularity of a given weighted graph.\nThis implementation is meant to be used for testing / development.\nThe reason is that it uses exact total weight in the computation,\nwhich introduces a lot of edges in recomputation graph. Will perform badly\non dynamic datasets, as single weight change will trigger recomputation on all\nrows.\nRounds the modularity to round_digits decimal places (default is 16),\nfor result res it returns round(res, ndigits = round_digits)\n\n\n### pw.stdlib.graphs.louvain_communities.impl.louvain_level(G, total_weight)\nThis function, given a weighted graph, finds a clustering that\nis a local maximum with respect to the objective function as defined\nby Louvain community detection algorithm\n"}
{"doc": "The documentation describes the `pw.Table` class in the Pathway framework. It takes in parameters such as `columns`, `universe`, `pk_columns`, `schema`, and `id_column`. An example is shown where the class is used to create a table of data with columns for age, owner, and pet. The `isinstance` function is used to verify that the resulting object is indeed an instance of `pw.Table`.\nclass  pw.Table(columns, universe, pk_columns={}, schema=None, id_column=None)\n\nCollection of named columns over identical universes.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nisinstance(t1, pw.Table)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n"}
{"doc": "The documentation describes the `concat` method in the Pathway framework, which is used to concatenate two tables together. The method ensures that the columns of the two tables match and that the resulting table has the correct row IDs. The documentation provides an example usage of the method along with its parameters and return type.\nconcat(\\*others)\nConcats self with every other \u220a others.\n\nSemantics:\n- result.columns == self.columns == other.columns\n- result.id == self.id \u222a other.id\n\nif self.id and other.id collide, throws an exception.\n\nRequires:\n- other.columns == self.columns\n- self.id disjoint with other.id\n\n\n* Parameters\n\n    other \u2013 the other table.\n\n\n\n* Returns\n\n    *Table* \u2013 The concatenated table. Id\u2019s of rows from original tables are preserved.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''')\npw.universes.promise_are_pairwise_disjoint(t1, t2)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n"}
{"doc": "This documentation describes a function called `concat_reindex` in the Pathway framework. The function is used to concatenate the contents of several tables with the same schema, similar to PySpark union. Each row is reindexed, and the concatenated table will have new, synthetic ids. The function takes a list of tables as a parameter and returns the concatenated table. An example is also provided to demonstrate the usage of the function.\nconcat_reindex(\\*tables)\nConcatenate contents of several tables.\n\nThis is similar to PySpark union. All tables must have the same schema. Each row is reindexed.\n\n\n* Parameters\n\n    tables (`Table`) \u2013 List of tables to concatenate. All tables must have the same schema.\n\n\n\n* Returns\n\n    *Table* \u2013 The concatenated table. It will have new, synthetic ids.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | pet\n1 | Manul\n8 | Octopus\n''')\nt3 = t1.concat_reindex(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet\nCat\nDog\nManul\nOctopus\n```\n::\n::\n"}
{"doc": "The `copy()` function in the pathway framework returns a copy of a table. The function is demonstrated using an example where a table is created and then copied using the `copy()` function. The resulting copy is printed using the `compute_and_print()` function and compared to the original table using the `is` operator.\ncopy()\nReturns a copy of a table.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt2 = t1.copy()\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n7   | Bob   | dog\n8   | Alice | cat\n9   | Bob   | dog\n10  | Alice | dog\n```\n::\n::\n\nCode\n```python\nt1 is t2\n```\n::\nResult\n```\nFalse\n```\n::\n::\n"}
{"doc": "This documentation describes the `diff` function in the Pathway framework, which computes the difference between the values in the `values` columns and the previous values based on the order defined by the `timestamp` column. It takes two parameters, `timestamp` and `*values`, and returns a new table with columns replaced by new columns containing the difference, whose name is the concatenation of `diff_` and the former name. The function raises a `ValueError` if the columns are not `ColumnReference`. The documentation provides an example code and its result to illustrate the usage of the function.\ndiff(timestamp, \\*values)\nCompute the difference between the values in the `values` columns and the previous values\naccording to the order defined by the column `timestamp`.\n\n\n* Parameters\n\n    * timestamp (*-*) \u2013 The column reference to the `timestamp` column on\n        which the order is computed.\n\n    * \\*values (*-*) \u2013 Variable-length argument representing the column\n        references to the `values` columns.\n\n\n\n* Returns\n\n    `Table` \u2013 A new table where each column is replaced with a new column containing\n    the difference and whose name is the concatenation of diff_ and the former name.\n\n\n\n* Raises\n\n    ValueError \u2013 If the columns are not ColumnReference.\n\n\nNOTE: * The value of the \u201cfirst\u201d value (the row with the lower value\n\n        in the `timestamp` column) is `None`.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\ntimestamp | values\n1         | 1\n2         | 2\n3         | 4\n4         | 7\n5         | 11\n6         | 16\n''')\ntable += table.diff(pw.this.timestamp, pw.this.values)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\ntimestamp | values | diff_values\n1         | 1      |\n2         | 2      | 1\n3         | 4      | 2\n4         | 7      | 3\n5         | 11     | 4\n6         | 16     | 5\n```\n::\n::\n"}
{"doc": "The `difference()` function in the pathway framework takes a table as input and removes the rows that have keys matching with the input table. The function returns a new table object with the same set of columns as the original table but with a smaller universe. An example is shown where two tables `t1` and `t2` are created, and `t1.difference(t2)` returns the rows from `t1` which do not have keys in `t2`. The result is printed to the console.\ndifference(other)\nRestrict self universe to keys not appearing in the other table.\n\n\n* Parameters\n\n    other (`Table`) \u2013 table with ids to remove from self.\n\n\n\n* Returns\n\n    *Table* \u2013 table with restricted universe, with the same set of columns\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age  | owner  | pet\n1 | 10   | Alice  | 1\n2 | 9    | Bob    | 1\n3 | 8    | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | cost\n2 | 100\n3 | 200\n4 | 300\n''')\nt3 = t1.difference(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n10  | Alice | 1\n```\n::\n::\n"}
{"doc": "The `dtypes()` function in the Pathway framework returns a dictionary containing the data types of the columns in a table. The example provided shows a table with columns for age, owner, and pet, and the function returns a dictionary with keys for each column name and values for each data type (int, str). The second example shows how to access the data type for a specific column using the `schema` attribute.\ndtypes()\nReturn the types of the columns as a dictionary.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt1.dtypes()\n```\n::\nResult\n```\n{'age': <class 'int'>, 'owner': <class 'str'>, 'pet': <class 'str'>}\n```\n::\n::\n\nCode\n```python\nt1.schema['age']\n```\n::\nResult\n```\n<class 'int'>\n```\n::\n::\n"}
{"doc": "The `empty` function in the Pathway framework creates an empty table with a schema specified by the `kwargs` parameter, which is a dictionary with column names as keys and column types as values. The function returns the empty table object. An example usage of the function is provided where an empty table with two columns, `age` and `pet`, both of type `float`, is created and printed.\nstatic  empty(\\*\\*kwargs)\nCreates an empty table with a schema specified by kwargs.\n\n\n* Parameters\n\n    kwargs (`NewType`(`DType`, `type`)) \u2013 Dict whose keys are column names and values are column types.\n\n\n\n* Returns\n\n    *Table* \u2013 Created empty table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.Table.empty(age=float, pet=float)\npw.debug.compute_and_print(t1, include_id=False)\n```\n::\nResult\n```\nage | pet\n```\n::\n::\n"}
{"doc": "This documentation describes the `filter()` function in the Pathway framework which takes a filtering condition as input and returns a new table with rows that satisfy the filter condition. The function is demonstrated with an example where a table is filtered based on the `outdegree` column. The output of the function is a new table with the same schema as the input table and a subset of the input table's ids.\nfilter(filter_expression)\nFilter a table according to filter condition.\n\n\n* Parameters\n\n    filter \u2013 ColumnExpression that specifies the filtering condition.\n\n\n\n* Returns\n\n    *Table* \u2013 Result has the same schema as self and its ids are subset of self.id.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nvertices = pw.debug.parse_to_table('''\nlabel outdegree\n    1         3\n    7         0\n''')\nfiltered = vertices.filter(vertices.outdegree == 0)\npw.debug.compute_and_print(filtered, include_id=False)\n```\n::\nResult\n```\nlabel | outdegree\n7     | 0\n```\n::\n::\n"}
{"doc": "The `flatten` function in the Pathway framework performs a flatmap operation on a column or expression given as the first argument. The datatype of the column or expression has to be iterable. Other columns specified in the method arguments are duplicated as many times as the length of the iterable. It is possible to get ids of source rows by using the `table.id` column. The documentation provides examples of how to use the function.\nflatten(\\*args, \\*\\*kwargs)\nPerforms a flatmap operation on a column or expression given as a first\nargument. Datatype of this column or expression has to be iterable.\nOther columns specified in the method arguments are duplicated\nas many times as the length of the iterable.\n\nIt is possible to get ids of source rows by using table.id column, e.g.\ntable.flatten(table.column_to_be_flattened, original_id = table.id).\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet  |  age\n1 | Dog  |   2\n7 | Cat  |   5\n''')\nt2 = t1.flatten(t1.pet)\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\npet\nC\nD\na\ng\no\nt\n```\n::\n::\n\nCode\n```python\nt3 = t1.flatten(t1.pet, t1.age)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nC   | 5\nD   | 2\na   | 5\ng   | 2\no   | 2\nt   | 5\n```\n::\n::\n"}
{"doc": "This documentation describes the `from_columns` function in the Pathway framework. It takes a list of columns and optional keyword arguments that define new column names, and builds a table from them. The columns must have the same ids and pairwise distinct names. The function returns the created table. An example usage is also provided.\nstatic  from_columns(\\*args, \\*\\*kwargs)\nBuild a table from columns.\n\nAll columns must have the same ids. Columns\u2019 names must be pairwise distinct.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 List of columns.\n\n    * kwargs (`ColumnReference`) \u2013 Columns with their new names.\n\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.Table.empty(age=float, pet=float)\nt2 = pw.Table.empty(foo=float, bar=float)\nt3 = pw.Table.from_columns(t1.pet, qux=t2.foo)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | qux\n```\n::\n::\n"}
{"doc": "The groupby() function in the pathway framework groups a table by columns specified in args and returns a GroupedTable object. If an id is provided, it is used to set the ids of the rows in the result. This function is usually followed by the reduce() function to aggregate and return a table. The documentation provides an example of using groupby() with reduce() to compute the total age of pets owned by each owner.\ngroupby(\\*args, id=None)\nGroups table by columns from args.\n\nNOTE: Usually followed by .reduce() that aggregates the result and returns a table.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 columns to group by.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 if provided, is the column used to set id\u2019s of the rows of the result\n\n\n\n* Returns\n\n    *GroupedTable* \u2013 Groupby object.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt2 = t1.groupby(t1.pet, t1.owner).reduce(t1.owner, t1.pet, ageagg=pw.reducers.sum(t1.age))\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nowner | pet | ageagg\nAlice | cat | 8\nAlice | dog | 10\nBob   | dog | 16\n```\n::\n::\n"}
{"doc": "This documentation describes the `id` property in the Pathway framework, which returns a reference to the pseudocolumn containing the IDs of a table. It gives an example of how to use this property to select rows with matching IDs from a table, and includes sample code and output.\nproperty  id(: ColumnReference )\nGet reference to pseudocolumn containing id\u2019s of a table.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt2 = t1.select(ids = t1.id)\npw.debug.compute_and_print(t2.select(test=t2.id == t2.ids), include_id=False)\n```\n::\nResult\n```\ntest\nTrue\nTrue\nTrue\nTrue\n```\n::\n::\n"}
{"doc": "This is the documentation for the `interpolate` function in the Pathway framework. It is used to interpolate missing values in a column using the previous and next values based on a timestamps column. The function takes in a timestamp column reference and any number of value column references. It returns a new table with the interpolated values. The only currently supported interpolation mode is linear interpolation. If there are missing values at the beginning or end of the column, no interpolation is performed. The documentation also includes an example code snippet with input and output tables.\ninterpolate(timestamp, \\*values, mode=InterpolateMode.LINEAR)\nInterpolates missing values in a column using the previous and next values based on a timestamps column.\n\n\n* Parameters\n\n    * timestamp (*ColumnReference*) \u2013 Reference to the column containing timestamps.\n\n    * \\*values (*ColumnReference*) \u2013 References to the columns containing values to be interpolated.\n\n    * mode (*InterpolateMode, optional*) \u2013 The interpolation mode. Currently,            only InterpolateMode.LINEAR is supported. Default is InterpolateMode.LINEAR.\n\n\n\n* Returns\n\n    *Table* \u2013 A new table with the interpolated values.\n\n\n\n* Raises\n\n    ValueError \u2013 If the columns are not ColumnReference or if the interpolation mode is not supported.\n\n\nNOTE: * The interpolation is performed based on linear interpolation between the previous and next values.\n\n* If a value is missing at the beginning or end of the column, no interpolation is performed.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\ntimestamp | values_a | values_b\n1         | 1        | 10\n2         |          |\n3         | 3        |\n4         |          |\n5         |          |\n6         | 6        | 60\n''')\ntable = table.interpolate(pw.this.timestamp, pw.this.values_a, pw.this.values_b)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\ntimestamp | values_a | values_b\n1         | 1        | 10\n2         | 2.0      | 20.0\n3         | 3        | 30.0\n4         | 4.0      | 40.0\n5         | 5.0      | 50.0\n6         | 6        | 60\n```\n::\n::\n"}
{"doc": "The `intersect` function in the Pathway framework restricts a table's universe to only the keys that appear in all of the input tables. The function takes in one or more tables as parameters and returns a new table with a restricted universe, but with the same set of columns as the input tables. The documentation provides an example of how to use the `intersect` function with three tables, and shows the resulting table with the restricted universe.\nintersect(\\*tables)\nRestrict self universe to keys appearing in all of the tables.\n\n\n* Parameters\n\n    tables (`Table`) \u2013 tables keys of which are used to restrict universe.\n\n\n\n* Returns\n\n    *Table* \u2013 table with restricted universe, with the same set of columns\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age  | owner  | pet\n1 | 10   | Alice  | 1\n2 | 9    | Bob    | 1\n3 | 8    | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | cost\n2 | 100\n3 | 200\n4 | 300\n''')\nt3 = t1.intersect(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n```\n::\n::\n"}
{"doc": "The `ix()` property is used to return an indexer object that can be indexed by a column to return a new table reindexed by that column. The returned object is an indexer that, when indexed by some column, returns a table with rows specified by that column. The function can be used in conjunction with other functions in the pathway framework to manipulate data in tables. The documentation provides an example that shows how `ix()` can be used to select rows from one table based on the values in another table.\nproperty  ix()\nReturn an object that indexed by \\[column\\] returns new table reindexed.\n\n\n* Returns\n\n    *Indexer* \u2013 an object that when indexed by some column returns a table with rows specified by that column.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt_animals = pw.debug.parse_to_table('''\n  | epithet    | genus\n1 | upupa      | epops\n2 | acherontia | atropos\n3 | bubo       | scandiacus\n4 | dynastes   | hercules\n''')\nt_birds = pw.debug.parse_to_table('''\n  | desc\n2 | hoopoe\n4 | owl\n''')\nret = t_birds.select(t_birds.desc, latin=t_animals.ix(t_birds.id).genus)\npw.debug.compute_and_print(ret, include_id=False)\n```\n::\nResult\n```\ndesc   | latin\nhoopoe | atropos\nowl    | hercules\n```\n::\n::\n"}
{"doc": "The documentation describes the `ix_ref()` function in the Pathway framework. It explains that the function returns a row indexed by its primary keys and can use several columns as an index. The documentation also provides examples of how to use the function to access rows in a table and how to access single-row tables.\nix_ref(\\*args, optional=False)\nReturns a row, indexed by its primary keys. Several columns can be used as index.\n\n\n* Parameters\n\n    args (`Union`\\[`ColumnExpression`, `None`, `int`, `float`, `str`, `bool`, `BasePointer`, `datetime`, `timedelta`, `Tuple`\\[`Any`, `...`\\]\\]) \u2013 Column references.\n\n\n\n* Returns\n\n    *Row* \u2013 indexed row.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nname   | pet\nAlice  | dog\nBob    | cat\nCarole | cat\nDavid  | dog\n''')\nt2 = t1.with_id_from(pw.this.name)\nt2 = t2.select(*pw.this, new_value=pw.this.ix_ref(\"Alice\").pet)\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nname   | pet | new_value\nAlice  | dog | dog\nBob    | cat | dog\nCarole | cat | dog\nDavid  | dog | dog\n```\n::\n::\nTables obtained by a groupby/reduce scheme always have primary keys:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nname   | pet\nAlice  | dog\nBob    | cat\nCarole | cat\nDavid  | cat\n''')\nt2 = t1.groupby(pw.this.pet).reduce(pw.this.pet, count=pw.reducers.count(pw.this.name))\nt3 = t1.select(*pw.this, new_value=t2.ix_ref(pw.this.pet).count)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nname   | pet | new_value\nAlice  | dog | 1\nBob    | cat | 3\nCarole | cat | 3\nDavid  | cat | 3\n```\n::\n::\nSingle-row tables can be accessed via ix_ref():\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nname   | pet\nAlice  | dog\nBob    | cat\nCarole | cat\nDavid  | cat\n''')\nt2 = t1.reduce(count=pw.reducers.count(pw.this.name))\nt3 = t1.select(*pw.this, new_value=t2.ix_ref().count)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nname   | pet | new_value\nAlice  | dog | 4\nBob    | cat | 4\nCarole | cat | 4\nDavid  | cat | 4\n```\n::\n::\n"}
{"doc": "This documentation describes the `join()` function in the Pathway framework, which allows the user to join two tables using a given join expression. The function takes in parameters such as `other`, `on`, `id`, and `how` to specify the details of the join operation. It returns a `JoinResult` object that allows the user to extract relevant columns from the result of the join. An example usage of the function is also provided.\njoin(other, \\*on, id=None, how=JoinMode.INNER)\nJoin self with other using the given join expression.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n    * how (`JoinMode`) \u2013 by default, inner join is performed. Possible values are JoinMode.{INNER,LEFT,RIGHT,OUTER}\n        correspond to inner, left, right and outer join respectively.\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(\n    t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER\n).select(age=t1.age, owner_name=t2.owner, size=t2.size)\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "This documentation describes the function `join_inner` in the Pathway framework, which performs an inner join between two tables or join results. It takes in parameters such as the right side of the join and a list of column expressions. The function returns a JoinResult object on which .select() may be called to extract relevant columns from the result of the join. An example usage with input and output is also provided.\njoin_inner(other, \\*on, id=None)\nInner-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER).select(age=t1.age, owner_name=t2.owner, size=t2.size)  # noqa: E501\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "This documentation describes the `join_left()` function in the Pathway framework, which performs a left-join operation on two tables or join results. It takes an optional id column and returns a `JoinResult` object that can be used to extract relevant columns. The documentation provides details on the parameters, remarks, behavior, and example usage of the function.\njoin_left(other, \\*on, id=None)\nLeft-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks:\nargs cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- rows from the right side that were not matched with the left side are skipped\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_left(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "This documentation describes the `join_outer()` method in the Pathway Framework. This method performs an outer join operation between two tables or join results. It takes two parameters, `other` and `*on`, where `other` represents the joinable table or result, and `*on` represents the columns to join. An optional id column can also be specified. The method returns a `JoinResult` object, on which `.select()` can be called to extract relevant columns from the result of the join. The behavior of the method is such that missing values on the right are replaced with `None` for rows from the left side that were not matched with the right side, missing values on the left are replaced with `None` for rows from the right side that were not matched with the left side, and for rows that were matched, the behavior is the same as that of an inner join. An example usage is also provided.\njoin_outer(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,             as the result table has id column with auto-generated ids;             it can be selected by assigning it to a column with defined             name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_outer(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t1.id,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "The join_right function is used to join two tables or join results, based on specified columns. The function takes in two parameters: other and \\*on, where other refers to the table or join result to join with, and \\*on refers to the columns to join based on the syntax self.col1 == other.col2. Additionally, the function has an optional id parameter, which refers to the id column of the result. The function returns a JoinResult object, on which .select() can be called to extract relevant columns from the result of the join. The function's behavior is such that rows from the left side that were not matched with the right side are skipped, and for rows from the right side that were not matched with the left side, missing values on the left are replaced with None. For rows that were matched, the behavior is the same as that of an inner join. The function also provides an example of its usage.\njoin_right(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- rows from the left side that were not matched with the right side are skipped\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_right(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(pw.coalesce(t1.B,0) + t2.D,t1.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n```\n::\n::\n\n* Returns\n\n    OuterJoinResult object\n\n\n"}
{"doc": "The `pointer_from` function in the Pathway framework is a pseudo-random hash generator that produces pointer types, which are applied column-wise. The function takes any number of arguments, and an optional boolean argument that defaults to False. The documentation provides an example of how to use `pointer_from` in conjunction with other functions to group and reduce data. In the example, data is grouped by owner and a reference column is created using `pointer_from`. The resulting table is then compared to a test table and the output shows that the test was successful.\npointer_from(\\*args, optional=False)\nPseudo-random hash of its argument. Produces pointer types. Applied column-wise.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   age  owner  pet\n1   10  Alice  dog\n2    9    Bob  dog\n3    8  Alice  cat\n4    7    Bob  dog''')\ng = t1.groupby(t1.owner).reduce(refcol = t1.pointer_from(t1.owner)) # g.id == g.refcol\npw.debug.compute_and_print(g.select(test = (g.id == g.refcol)), include_id=False)\n```\n::\nResult\n```\ntest\nTrue\nTrue\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_equal_to` function is used in the Pathway framework to assert that the universe of a given object is a subset of the universes of other objects. It is used in situations where this cannot be deduced automatically. The function returns None and works in place. The example provided demonstrates how this function can be used to combine two tables with different universes by asserting their equality.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_subset_of` function is used in the Pathway framework to assert that the universe of the current instance is a subset of the universe of another instance. It is used when Pathway cannot deduce one universe being a subset of another. It returns the current instance and works in place. The example given shows how it can be used to merge two tables in a specific way.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "The documentation describes the `promise_universes_are_disjoint` function of the Pathway framework. This function asserts that the universe of the object calling the function is disjoint from the universe of a given object `other`. This assertion is used in cases where Pathway cannot deduce the disjointness of the universes. The function returns the calling object, and the assertion is done in place. The provided code shows an example of using this function to ensure the disjointness of two tables and concatenating them. The resulting table is printed as output.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n"}
{"doc": "The `reduce()` function in Pathway Framework allows users to reduce a table to a single row using a reducer. The function takes in a `ColumnReference` for the reducer to reduce the table with, and a `ColumnExpression` for the new name of the column. The function returns a `Table` object that represents the reduced table. The documentation also provides an example of how to use the `reduce()` function in practice.\nreduce(\\*args, \\*\\*kwargs)\nReduce a table to a single row.\n\nEquivalent to self.groupby().reduce(\\*args, \\*\\*kwargs).\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 reducer to reduce the table with\n\n    * kwargs (`ColumnExpression`) \u2013 reducer to reduce the table with. Its key is the new name of a column.\n\n\n\n* Returns\n\n    *Table* \u2013 Reduced table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt2 = t1.reduce(ageagg=pw.reducers.argmin(t1.age))\npw.debug.compute_and_print(t2, include_id=False) \n```\n::\nResult\n```\nageagg\n^...\n```\n::\n::\n\nCode\n```python\nt3 = t2.select(t1.ix(t2.ageagg).age, t1.ix(t2.ageagg).pet)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | pet\n7   | dog\n```\n::\n::\n"}
{"doc": "This documentation describes the `rename` function in the Pathway framework, which allows renaming columns in a table object. The function takes in a dictionary or keyword arguments mapping old column names to new names. It uses `rename_by_dict` if a mapping dictionary is provided, otherwise, `rename_columns` is used with keyword arguments. The function returns the table object with the renamed columns.\nrename(names_mapping=None, \\*\\*kwargs)\nRename columns according either a dictionary or kwargs.\n\nIf a mapping is provided using a dictionary, `rename_by_dict` will be used.\nOtherwise, `rename_columns` will be used with kwargs.\nColumns not in keys(kwargs) are not changed. New name of a column must not be `id`.\n\n\n* Parameters\n\n    * names_mapping (`Optional`\\`Dict`\\[`Union`\\[`str`, [`ColumnReference`\\], `str`\\]\\]) \u2013 mapping from old column names to new names.\n\n    * kwargs (`ColumnExpression`) \u2013 mapping from old column names to new names.\n\n\n\n* Returns\n\n    *Table* \u2013 self with columns renamed.\n\n\n"}
{"doc": "The `rename_by_dict` function in the Pathway framework renames columns in a table according to a provided dictionary. Only columns listed in the dictionary are changed, and the new name of a column cannot be \"id\". The function returns the renamed table. An example usage of the function is provided in the documentation.\nrename_by_dict(names_mapping)\nRename columns according to a dictionary.\n\nColumns not in keys(kwargs) are not changed. New name of a column must not be id.\n\n\n* Parameters\n\n    names_mapping (`Dict`\\`Union`\\[`str`, [`ColumnReference`\\], `str`\\]) \u2013 mapping from old column names to new names.\n\n\n\n* Returns\n\n    *Table* \u2013 self with columns renamed.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | 1\n9   | Bob   | 1\n8   | Alice | 2\n''')\nt2 = t1.rename_by_dict({\"age\": \"years_old\", t1.pet: \"animal\"})\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nowner | years_old | animal\nAlice | 8         | 2\nAlice | 10        | 1\nBob   | 9         | 1\n```\n::\n::\n"}
{"doc": "This documentation describes the `rename_columns()` function in the Pathway framework. This function is used to rename columns in a table according to a mapping of old column names to new names. The function returns a new version of the table with the renamed columns. The function takes in keyword arguments in the form of old column names mapped to new column names. The example shows how this function can be used to rename columns in a simple table.\nrename_columns(\\*\\*kwargs)\nRename columns according to kwargs.\n\nColumns not in keys(kwargs) are not changed. New name of a column must not be id.\n\n\n* Parameters\n\n    kwargs (`Union`\\`str`, [`ColumnReference`\\]) \u2013 mapping from old column names to new names.\n\n\n\n* Returns\n\n    *Table* \u2013 self with columns renamed.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | 1\n9   | Bob   | 1\n8   | Alice | 2\n''')\nt2 = t1.rename_columns(years_old=t1.age, animal=t1.pet)\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nowner | years_old | animal\nAlice | 8         | 2\nAlice | 10        | 1\nBob   | 9         | 1\n```\n::\n::\n"}
{"doc": "The documentation describes the \"schema\" property of a table in the Pathway framework. It explains that the schema property can be used to get the schema of a table, which is a dictionary of column names and their corresponding data types. The example code demonstrates how to use the schema property to get the schema of a table and access the data types of specific columns.\nproperty  schema(: Type\\[Schema\\] )\nGet schema of the table.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt1.schema.as_dict()\n```\n::\nResult\n```\n{'age': <class 'int'>, 'owner': <class 'str'>, 'pet': <class 'str'>}\n```\n::\n::\n\nCode\n```python\nt1.schema['age']\n```\n::\nResult\n```\n<class 'int'>\n```\n::\n::\n"}
{"doc": "The `select` function in the Pathway framework builds a new table with columns specified by keyword arguments. These columns can be raw values, boxed values, or columns from the original table passed to the function. The function returns the newly created table. The example provided shows how to use the `select` function to create a new table with columns for animal and description.\nselect(\\*args, \\*\\*kwargs)\nBuild a new table with columns specified by kwargs.\n\nOutput columns\u2019 names are keys(kwargs). values(kwargs) can be raw values, boxed\nvalues, columns. Assigning to id reindexes the table.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 Column references.\n\n    * kwargs (`Any`) \u2013 Column expressions with their new assigned names.\n\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\npet\nDog\nCat\n''')\nt2 = t1.select(animal=t1.pet, desc=\"fluffy\")\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nanimal | desc\nCat    | fluffy\nDog    | fluffy\n```\n::\n::\n"}
{"doc": "The `slice` property in the Pathway framework creates a collection of references to a table's columns and supports basic column manipulation methods. The example provided shows how to create a slice without the \"age\" column from a table called \"t1\". The resulting `TableSlice` object contains references to the \"owner\" and \"pet\" columns of `t1`.\nproperty  slice(: TableSlice )\nCreates a collection of references to self columns.\nSupports basic column manipulation methods.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\nt1.slice.without(\"age\")\n```\n::\nResult\n```\nTableSlice({'owner': <table1>.owner, 'pet': <table1>.pet})\n```\n::\n::\n"}
{"doc": "The `sort` function in the Pathway framework is used to sort a table based on specified keys. The function takes in a `Table` object and optional `key` and `instance` arguments. If `key` is not provided, the table is sorted based on the primary key column. If `instance` is not provided, the function will use the `instance` field if it exists, otherwise only the primary key is used. The function returns the sorted `Table` with two columns, `prev` and `next`, containing pointers to the previous and next rows. The documentation includes an example usage of the function.\nsort(key=None, instance=None)\nSorts a table by the specified keys.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 pw.Table\n        The table to be sorted.\n\n    * key (`Optional`\\[`ColumnReference`\\]) \u2013 ColumnReference or None\n        The name of the primary key to sort by. If None, the table is sorted\n        based on the key column as primary key.\n\n    * instance (`Optional`\\[`ColumnReference`\\]) \u2013 ColumnReference or None\n        The name of the secondary key to sort by. If None, the field \u201cinstance\u201d is chosen\n        if it exists, otherwise only the primary key is used.\n\n\n\n* Returns\n\n    *pw.Table* \u2013 The sorted table. Contains two columns: `prev` and `next`, containing the pointers\n    to the previous and next rows.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\nname     | age | score\nAlice    | 25  | 80\nBob      | 20  | 90\nCharlie  | 30  | 80\n''')\ntable = table.with_id_from(pw.this.name)\ntable += sort(table, key=pw.this.age)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\nname    | age | score | next        | prev\nAlice   | 25  | 80    | ^DS9AT95... | ^EDPSSB1...\nBob     | 20  | 90    | ^GBSDEEW... |\nCharlie | 30  | 80    |             | ^GBSDEEW...\n```\n::\n::\n"}
{"doc": "This documentation describes the `update_cells()` function in the Pathway framework. The function takes another table as input and updates the cells of the current table, resolving conflicts in favor of the values in the other table. The function requires that the columns and IDs of the other table are subsets of the current table. An example usage of the function is provided, showing how it updates the cells of a table based on another table.\nupdate_cells(other)\nUpdates cells of self, breaking ties in favor of the values in other.\n\nSemantics:\n\n    * result.columns == self.columns\n\n    * result.id == self.id\n\n    * conflicts are resolved preferring other\u2019s values\n\nRequires:\n\n    * other.columns \u2286 self.columns\n\n    * other.id \u2286 self.id\n\n\n* Parameters\n\n    other (`Table`) \u2013 the other table.\n\n\n\n* Returns\n\n    *Table* \u2013 self updated with cells form other.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n    age | owner | pet\n1 | 10  | Alice | 30\n''')\npw.universes.promise_is_subset_of(t2, t1)\nt3 = t1.update_cells(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "This documentation describes the `update_rows()` function in the `Table` class of Pathway framework. It takes another table as input and updates the rows of the current table with those from the other table. If there are conflicts, the rows from the other table are given priority. The function requires that both tables have the same columns, and returns the updated table. An example is provided to demonstrate how to use the function.\nupdate_rows(other)\nUpdates rows of self, breaking ties in favor for the rows in other.\n\nSemantics:\n- result.columns == self.columns == other.columns\n- result.id == self.id \u222a other.id\n\nRequires:\n- other.columns == self.columns\n\n\n* Parameters\n\n    other (`Table`) \u2013 the other table.\n\n\n\n* Returns\n\n    *Table* \u2013 self updated with rows form other.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n1  | 10  | Alice | 30\n12 | 12  | Tom   | 40\n''')\nt3 = t1.update_rows(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n"}
{"doc": "The `windowby()` function in the Pathway framework creates a GroupedTable by windowing the table based on the column expression provided in `time_expr`. It can also be optionally sharded with `shard`. The `window` parameter specifies the type of window to be used. The function takes in a table and returns a GroupedTable. The examples section provides sample code to demonstrate the usage of the function.\nwindowby(time_expr, \\*, window, shard=None)\nCreate a GroupedTable by windowing the table (based on expr and window),\noptionally sharded with shard\n\n\n* Parameters\n\n    * time_expr (`ColumnExpression`) \u2013 Column expression used for windowing\n\n    * window (`Window`) \u2013 type window to use\n\n    * shard (`Optional`\\[`ColumnExpression`\\]) \u2013 optional column expression to act as a shard key\n\n\nExamples:\n\n\n\nCode\n```python\nimport pathway as pw\nt = pw.debug.table_from_markdown(\n'''\n    | shard |  t |  v\n1   | 0     |  1 |  10\n2   | 0     |  2 |  1\n3   | 0     |  4 |  3\n4   | 0     |  8 |  2\n5   | 0     |  9 |  4\n6   | 0     |  10|  8\n7   | 1     |  1 |  9\n8   | 1     |  2 |  16\n''')\nresult = t.windowby(\n    t.t, window=pw.temporal.session(predicate=lambda a, b: abs(a-b) <= 1), shard=t.shard\n).reduce(\npw.this.shard,\nmin_t=pw.reducers.min(pw.this.t),\nmax_v=pw.reducers.max(pw.this.v),\ncount=pw.reducers.count(pw.this.t),\n)\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nshard | min_t | max_v | count\n0     | 1     | 10    | 2\n0     | 4     | 3     | 1\n0     | 8     | 8     | 3\n1     | 1     | 16    | 2\n```\n::\n::\n"}
{"doc": "The `with_columns` function in the Pathway framework updates the columns of a table according to the specified arguments and keyword arguments. The function returns a new table with the updated columns. The arguments and keyword arguments are evaluated according to the `table.select` specification. The provided code example shows how to use the `with_columns` function to update columns of a table with data from another table.\nwith_columns(\\*args, \\*\\*kwargs)\nUpdates columns of self, according to args and kwargs.\nSee table.select specification for evaluation of args and kwargs.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | owner | pet | size\n1 | Tom   | 1   | 10\n2 | Bob   | 1   | 9\n3 | Tom   | 2   | 8\n''').with_universe_of(t1)\nt3 = t1.with_columns(*t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet | size\n8   | Tom   | 2   | 8\n9   | Bob   | 1   | 9\n10  | Tom   | 1   | 10\n```\n::\n::\n"}
{"doc": "The `with_id(new_index)` function in the pathway framework sets new ids for a table based on values in a specified column. The function returns a table with updated ids. The `new_index` parameter is the column to be used as the new index. The function requires that the values assigned be row-wise unique. An example is provided in the documentation.\nwith_id(new_index)\nSet new ids based on another column containing id-typed values.\n\nTo generate ids based on arbitrary valued columns, use with_id_from.\n\nValues assigned must be row-wise unique.\n\n\n* Parameters\n\n    new_id \u2013 column to be used as the new index.\n\n\n\n* Returns\n\n    Table with updated ids.\n\n\nExample:\n\n\n\nCode\n```python\nimport pytest; pytest.xfail(\"with_id is hard to test\")\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | new_id\n1 | 2\n2 | 3\n3 | 4\n''')\nt3 = t1.promise_universe_is_subset_of(t2).with_id(t2.new_id)\npw.debug.compute_and_print(t3)\n```\n::\nResult\n```\n    age  owner  pet\n^2   10  Alice    1\n^3    9    Bob    1\n^4    8  Alice    2\n```\n::\n::\n"}
{"doc": "The `with_id_from()` function in the Pathway framework computes new ids based on values in columns. The function takes one parameter, `columns`, which is a list of columns to be used as primary keys. The function returns a new table with updated ids. The documentation provides an example of using this function to create new ids based on age values in a table and then selecting rows based on the old and new id values.\nwith_id_from(\\*args)\nCompute new ids based on values in columns.\nIds computed from columns must be row-wise unique.\n\n\n* Parameters\n\n    columns \u2013 columns to be used as primary keys.\n\n\n\n* Returns\n\n    *Table* \u2013 self updated with recomputed ids.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   | age | owner  | pet\n 1 | 10  | Alice  | 1\n 2 | 9   | Bob    | 1\n 3 | 8   | Alice  | 2\n''')\nt2 = t1 + t1.select(old_id=t1.id)\nt3 = t2.with_id_from(t2.age)\npw.debug.compute_and_print(t3) \n```\n::\nResult\n```\n     | age | owner | pet | old_id\n^... | 8   | Alice | 2   | ^...\n^... | 9   | Bob   | 1   | ^...\n^... | 10  | Alice | 1   | ^...\n```\n::\n::\n\nCode\n```python\nt4 = t3.select(t3.age, t3.owner, t3.pet, same_as_old=(t3.id == t3.old_id),\n    same_as_new=(t3.id == t3.pointer_from(t3.age)))\npw.debug.compute_and_print(t4) \n```\n::\nResult\n```\n     | age | owner | pet | same_as_old | same_as_new\n^... | 8   | Alice | 2   | False       | True\n^... | 9   | Bob   | 1   | False       | True\n^... | 10  | Alice | 1   | False       | True\n```\n::\n::\n"}
{"doc": "The `with_prefix` function in the Pathway framework renames the columns of a table by adding a prefix to each column name. The function takes a string parameter `prefix` and returns a new table with prefixed column names. An example is provided to demonstrate how the function works.\nwith_prefix(prefix)\nRename columns by adding prefix to each name of column.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | 1\n9   | Bob   | 1\n8   | Alice | 2\n''')\nt2 = t1.with_prefix(\"u_\")\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nu_age | u_owner | u_pet\n8     | Alice   | 2\n9     | Bob     | 1\n10    | Alice   | 1\n```\n::\n::\n"}
{"doc": "The `with_suffix()` method is an attribute of a `table` object in the Pathway framework. It is used to rename columns by adding a suffix to each column name. The method takes a string argument representing the suffix to be added to the column names. An example is provided where the `with_suffix()` method is used to add the suffix \"_current\" to each column name of a table object `t1`. The resulting table is printed to the console using the `compute_and_print()` function from the `debug` module of the Pathway framework.\nwith_suffix(suffix)\nRename columns by adding suffix to each name of column.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | 1\n9   | Bob   | 1\n8   | Alice | 2\n''')\nt2 = t1.with_suffix(\"_current\")\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nage_current | owner_current | pet_current\n8           | Alice         | 2\n9           | Bob           | 1\n10          | Alice         | 1\n```\n::\n::\n"}
{"doc": "The `with_universe_of(other)` function is used in the Pathway framework to return a copy of an object with the same universe as the input object `other`. The precondition is that the universes of both objects must be equal. The function is used in situations where Pathway cannot deduce the equality of universes, but they are equal during runtime. An example usage of this function is given, which involves parsing two tables and adding them together using the `+` operator, and then printing the resulting table.\nwith_universe_of(other)\nReturns a copy of self with exactly the same universe as others.\n\nSemantics: Required precondition self.universe == other.universe\nUsed in situations where Pathway cannot deduce equality of universes, but\nthose are equal as verified during runtime.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''').with_universe_of(t1)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `without()` function in the pathway framework allows you to select all columns of a table except the ones specified in the input parameter `columns`. The parameter `columns` can be either a string or a list of `ColumnReference`. The function returns a new `Table` object which has all the columns except the specified ones. An example usage of the function is also provided.\nwithout(\\*columns)\nSelects all columns without named column references.\n\n\n* Parameters\n\n    columns (`Union`\\`str`, [`ColumnReference`\\]) \u2013 columns to be dropped provided by table.column_name notation.\n\n\n\n* Returns\n\n    *Table* \u2013 self without specified columns.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = t1.without(t1.age, pw.this.pet)\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nowner\nAlice\nAlice\nBob\n```\n::\n::\n\n"}
{"doc": "This is a class called `TableLike` in the Pathway framework, which serves as an interface for table-like classes such as `Table`, `GroupedTable`, and `JoinResult`. It contains information about the universe and supports universe-related asserts. The example shows how to use this class to group and filter data in a table.\nclass  pw.TableLike(universe)\n\nInterface class for table-likes: Table, GroupedTable and JoinResult.\nAll of those contain universe info, and thus support universe-related asserts.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage | owner | pet\n10  | Alice | dog\n9   | Bob   | dog\n8   | Alice | cat\n7   | Bob   | dog\n''')\ng1 = t1.groupby(t1.owner)\nt2 = t1.filter(t1.age >= 9)\npw.debug.compute_and_print(t2, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n9   | Bob   | dog\n10  | Alice | dog\n```\n::\n::\n```python\ng2 = t2.groupby(t2.owner)\npw.universes.promise_is_subset_of(g2, g1) # t2 is a subset of t1, so this is safe\n```\n"}
{"doc": "The `promise_universe_is_equal_to(other)` function is used in the Pathway framework to assert that the universe of the current object is a subset of the universe of the `other` object. It is mainly used when Pathway cannot deduce one universe being a subset of another. The function does not return anything and works in place. The documentation includes an example that shows how the function can be used with two tables to create a new table.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_subset_of` function is an assertion that checks if the universe of one object is a subset of the universe of another object in the Pathway framework. If Pathway cannot deduce one universe being a subset of another, this assertion can be used. The function returns the object it was called on and works in place. The example code shows the usage of this function with two tables.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "The function `promise_universes_are_disjoint` is an assertion used in the Pathway framework to declare that the universe of the current object is disjoint from the universe of another object. It is used to ensure that Pathway can deduce disjoint universes correctly. The function returns the current object and works in place. The code provides an example of using the function to ensure that the universes of two tables are disjoint before concatenating them. The resulting concatenated table is printed as output.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n\n"}
{"doc": "The `asof_join` function in pathway framework performs an ASOF (as-of) join of two tables using time-like column expressions to do the join against. It takes as parameters the other table to join with, the time-like column expression of the first table to join against, the time-like column expression of the second table to join against, a list of column expressions for the join condition, the join mode, and a dictionary of column reference to default value. The function returns a new table that contains entries resulting from the join. The join operation is demonstrated in an example code block.\nasof_join(other, self_time, other_time, \\*on, how, defaults={}, direction=Direction.BACKWARD)\nPerform an ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * how (`JoinMode`) \u2013 mode of the join (LEFT, RIGHT, FULL)\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    how=pw.JoinMode.LEFT,\n    defaults={t2.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 1  | 1        | -1        | 0\n0         | 4  | 2        | 6         | 8\n0         | 5  | 3        | 6         | 9\n0         | 6  | 4        | 6         | 10\n0         | 7  | 5        | 6         | 11\n0         | 11 | 6        | 9         | 15\n0         | 12 | 7        | 9         | 16\n1         | 5  | 8        | 7         | 15\n1         | 7  | 9        | 7         | 16\n```\n::\n::\n"}
{"doc": "The `asof_join_left` function is used to perform a left ASOF join of two tables. It takes in the following parameters:\n\n- `other`: Table to join with self, both must contain a column val.\n- `self_time`: time-like column expression to do the join against.\n- `other_time`: time-like column expression to do the join against.\n- `on`: a list of column expressions. Each must have == as the top level operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n- `defaults`: dictionary column-> default value. Entries in the resulting table that not have a predecessor in the join will be set to this default value. If no default is provided, None will be used.\n- `direction`: direction of the join, accepted values: Direction.BACKWARD, Direction.FORWARD, Direction.NEAREST.\n\nAn example code is provided to show how the function can be used to join two tables and select certain columns from the results.\nasof_join_left(other, self_time, other_time, \\*on, defaults={}, direction=Direction.BACKWARD)\nPerform a left ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n    * direction (`Direction`) \u2013 direction of the join, accepted values: Direction.BACKWARD,\n        Direction.FORWARD, Direction.NEAREST\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join_left(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    defaults={t2.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 1  | 1        | -1        | 0\n0         | 4  | 2        | 6         | 8\n0         | 5  | 3        | 6         | 9\n0         | 6  | 4        | 6         | 10\n0         | 7  | 5        | 6         | 11\n0         | 11 | 6        | 9         | 15\n0         | 12 | 7        | 9         | 16\n1         | 5  | 8        | 7         | 15\n1         | 7  | 9        | 7         | 16\n```\n::\n::\n"}
{"doc": "This documentation describes the `asof_join_outer()` function in the Pathway framework, which performs an outer ASOF join of two tables. The function takes `other`, `self_time`, `other_time`, `on`, `defaults`, and `direction` as parameters. `other` is the table to be joined with `self`, both of which must contain a column named `val`. `self_time` and `other_time` are time-like column expressions to do the join against. `on` is a list of column expressions that are used to match rows between the two tables. `defaults` is a dictionary that specifies default values for entries in the resulting table that do not have a predecessor in the join. Finally, `direction` specifies the direction of the join. The documentation includes an example of how to use this function.\nasof_join_outer(other, self_time, other_time, \\*on, defaults={}, direction=Direction.BACKWARD)\nPerform an outer ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n    * direction (`Direction`) \u2013 direction of the join, accepted values: Direction.BACKWARD,\n        Direction.FORWARD, Direction.NEAREST\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join_outer(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    defaults={t1.val: -1, t2.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 1  | 1        | -1        | 0\n0         | 2  | 1        | 0         | 1\n0         | 3  | 1        | 6         | 7\n0         | 4  | 2        | 6         | 8\n0         | 5  | 3        | 6         | 9\n0         | 6  | 4        | 6         | 10\n0         | 7  | 5        | 2         | 7\n0         | 7  | 5        | 6         | 11\n0         | 8  | 5        | 3         | 8\n0         | 9  | 5        | 9         | 14\n0         | 11 | 6        | 9         | 15\n0         | 12 | 7        | 9         | 16\n0         | 13 | 7        | 7         | 14\n0         | 14 | 7        | 4         | 11\n1         | 2  | -1       | 7         | 6\n1         | 5  | 8        | 7         | 15\n1         | 7  | 9        | 7         | 16\n1         | 8  | 9        | 3         | 12\n```\n::\n::\n"}
{"doc": "The `asof_join_right` method performs a right ASOF join of two tables based on a time-like column expression. The method takes in the following parameters: `other`, `self_time`, `other_time`, `on`, `defaults`, and `direction`. `other` is the table to join with `self`, both of which must contain a column val. `self_time` and `other_time` are column expressions to do the join against. `on` is a list of column expressions, and each must have `==` as the top-level operation and be of the form `LHS: ColumnReference == RHS: ColumnReference`. `defaults` is a dictionary of column->default value, and entries in the resulting table that do not have a predecessor in the join will be set to this default value. If no default is provided, `None` will be used. `direction` is the direction of the join, and accepted values are `Direction.BACKWARD`, `Direction.FORWARD`, and `Direction.NEAREST`. An example is provided to illustrate the usage of `asof_join_right`.\nasof_join_right(other, self_time, other_time, \\*on, defaults={}, direction=Direction.BACKWARD)\nPerform a right ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n    * direction (`Direction`) \u2013 direction of the join, accepted values: Direction.BACKWARD,\n        Direction.FORWARD, Direction.NEAREST\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join_right(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    defaults={t1.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 2  | 1        | 0         | 1\n0         | 3  | 1        | 6         | 7\n0         | 7  | 5        | 2         | 7\n0         | 8  | 5        | 3         | 8\n0         | 9  | 5        | 9         | 14\n0         | 13 | 7        | 7         | 14\n0         | 14 | 7        | 4         | 11\n1         | 2  | -1       | 7         | 6\n1         | 8  | 9        | 3         | 12\n```\n::\n::\n"}
{"doc": "The `interval_join()` function in Pathway framework performs an interval join of one table with another based on a time difference and join expressions. It takes in parameters such as the other table, time expressions in both tables, lower and upper bounds on time difference, join expressions and a JoinMode parameter that decides the type of join to be performed. The function returns an IntervalJoinResult object which can be further filtered using the `.select()` method. An example usage is shown in the documentation.\ninterval_join(other, self_time, other_time, interval, \\*on, how=JoinMode.INNER)\nPerforms an interval join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * how (`JoinMode`) \u2013 decides whether to run interval_join_inner, interval_join_left, interval_join_right\n        or interval_join_outer. Default is INNER.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b, how=pw.JoinMode.INNER\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n```\n::\n::\n"}
{"doc": "The `interval_join_inner` function in the Pathway framework performs an interval join of two tables based on a time difference and join expressions. The function takes in the right side of the join, time expressions from both tables, a lower and upper bound on the time difference, and a list of column expressions for the join. The function returns an `IntervalJoinResult` object, which can be further filtered with the `.select()` method. An example usage is provided in the documentation.\ninterval_join_inner(other, self_time, other_time, interval, \\*on)\nPerforms an interval join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_inner(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_inner(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n```\n::\n::\n"}
{"doc": "The documentation describes the `interval_join_left` function in the Pathway framework, which performs an interval left join of two tables using a time difference and join expressions. The function takes in parameters such as `other`, `self_time`, `other_time`, `lower_bound`, `upper_bound`, and `on`, and returns an `IntervalJoinResult` object. The documentation also provides an example of how to use the function and shows the output of the example.\ninterval_join_left(other, self_time, other_time, interval, \\*on)\nPerforms an interval left join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined. Rows from the left\nside that haven\u2019t been matched with the right side are returned with missing\nvalues on the right side replaced with None.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of the join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_left(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n11     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_left(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n1 | 11     |\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n3 | 4      |\n```\n::\n::\n"}
{"doc": "The `interval_join_outer` function performs an interval outer join of two tables (`self` and `other`) using time expressions and join expressions. The rows that have not been matched with the other table are returned with missing values. The function takes as parameters `other`, `self_time`, `other_time`, `lower_bound`, `upper_bound`, and `on` and returns an `IntervalJoinResult`, which can be used to extract relevant columns from the result of the join. An example usage is also provided.\ninterval_join_outer(other, self_time, other_time, interval, \\*on)\nPerforms an interval outer join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined. Rows that haven\u2019t\nbeen matched with the other side are returned with missing values on the other\nside replaced with None.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of the join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_outer(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 0\n       | 7\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n11     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_outer(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n  |        | 0\n  |        | 2\n  |        | 7\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n1 | 11     |\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n3 | 4      |\n```\n::\n::\n"}
{"doc": "The `interval_join_right` function is a method of the `Table` class in the Pathway framework that performs an interval right join of the table with another table using a time difference and join expressions. The method takes in the `other` table, `self_time`, `other_time`, `lower_bound`, `upper_bound`, and `on` parameters. It returns a `IntervalJoinResult` object that can be used to extract relevant columns from the result of the join. An example usage of the function is also provided.\ninterval_join_right(other, self_time, other_time, interval, \\*on)\nPerforms an interval right join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined. Rows from the right\nside that haven\u2019t been matched with the left side are returned with missing\nvalues on the left side replaced with None.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of the join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_right(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 0\n       | 7\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_right(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n  |        | 0\n  |        | 2\n  |        | 7\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n```\n::\n::\n"}
{"doc": "The `window_join` function in the Pathway framework performs a window join of two tables using a specified window and join expressions. It takes in the right side of the join (`other`), time expressions for both tables (`self_time` and `other_time`), a `Window` object, and a list of join conditions (`on`). The function can be set to run an inner, left, right or outer join, with the default being inner. The function returns a `WindowJoinResult` object that can be further manipulated using the `select()` method. An example usage of the function is also provided.\nwindow_join(other, self_time, other_time, window, \\*on, how=JoinMode.INNER)\nPerforms a window join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * how (`JoinMode`) \u2013 decides whether to run window_join_inner, window_join_left, window_join_right\n        or window_join_outer. Default is INNER.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n```\n::\n::\n\nt4 = t1.window_join(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      | 2\n2      | 2\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t1.a, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n2   | 2      | 2\n2   | 2      | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n```\n::\n::\n"}
{"doc": "The `window_join_inner()` function in the Pathway framework performs a window join of two tables using a window and join expressions. Records that belong to the same window and meet the conditions specified in the on clause will be joined. It takes in five parameters: the right side of the join, time expressions for both tables, a window to use, and a list of column expressions. The function returns a WindowJoinResult object that can be further manipulated. An example usage and output is provided.\nwindow_join_inner(other, self_time, other_time, window, \\*on)\nPerforms a window join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_inner(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n```\n::\n::\n\nt4 = t1.window_join_inner(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      | 2\n2      | 2\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_inner(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t1.a, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n2   | 2      | 2\n2   | 2      | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_inner(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_inner(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n```\n::\n::\n"}
{"doc": "The `window_join_left` function in the Pathway framework performs a window left join of a table with another table using a window and join expressions. The function returns a result of the window join and a method `select()` can be called on it to extract relevant columns from the result of the join. The function takes in parameters such as `other`, `self_time`, `other_time`, `window`, and `on`. The function has been demonstrated with an example in the documentation.\nwindow_join_left(other, self_time, other_time, window, \\*on)\nPerforms a window left join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\nRows from the left side that didn\u2019t match with any record on the right side in\na given window, are returned with missing values on the right side replaced\nwith None. The multiplicity of such rows equals the number of windows they\nbelong to and don\u2019t have a match in them.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_left(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      |\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n13     |\n```\n::\n::\n\nt4 = t1.window_join_left(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      |\n1      | 2\n2      | 2\n2      | 2\n3      |\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n13     |\n13     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_left(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t1.a, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      |\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n1   | 13     |\n2   | 1      |\n2   | 2      | 2\n2   | 2      | 3\n3   | 4      |\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_left(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n10     |\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_left(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n2   | 7      |\n3   | 4      |\n```\n::\n::\n"}
{"doc": "The `window_join_outer` function in the Pathway framework performs a window outer join of two tables using a specified window and join expressions. It returns a result that includes all rows from both tables that meet the join conditions, with missing values filled in with None. The multiplicity of such rows equals the number of windows they belong to and don\u2019t have a match in them. The function takes in five parameters: the right side table, time expressions for both tables, a window, and join expressions. The result can be further filtered by calling the `.select()` method on it. An example usage of the function is also provided.\nwindow_join_outer(other, self_time, other_time, window, \\*on)\nPerforms a window outer join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\nRows from both sides that didn\u2019t match with any record on the other side in\na given window, are returned with missing values on the other side replaced\nwith None. The multiplicity of such rows equals the number of windows they\nbelong to and don\u2019t have a match in them.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n1      |\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n13     |\n```\n::\n::\n\nt4 = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n       | 5\n       | 6\n1      |\n1      | 2\n2      | 2\n2      | 2\n3      |\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n13     |\n13     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=pw.coalesce(t1.a, t2.b), left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   |        | 5\n1   | 1      |\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n1   | 13     |\n2   | 1      |\n2   | 2      | 2\n2   | 2      | 3\n3   | 4      |\n4   |        | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_outer(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | -3\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n10     |\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_outer(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=pw.coalesce(t1.a, t2.b), left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   |        | 10\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n2   | 7      |\n3   | 4      |\n4   |        | 3\n```\n::\n::\n"}
{"doc": "The `window_join_right` function in Pathway framework performs a window right join of two tables using a window and join expressions. It returns a result that can be further processed by calling the `.select()` method on it. The function takes in several parameters including the two tables, time expressions, window, and join expressions. It also supports session windows and can handle cases where rows from the right side don't match with any record on the left side in a given window. The documentation includes an example usage of the function.\nwindow_join_right(other, self_time, other_time, window, \\*on)\nPerforms a window right join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\nRows from the right side that didn\u2019t match with any record on the left side in\na given window, are returned with missing values on the left side replaced\nwith None. The multiplicity of such rows equals the number of windows they\nbelong to and don\u2019t have a match in them.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_right(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n```\n::\n::\n\nt4 = t1.window_join_right(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n       | 5\n       | 6\n1      | 2\n2      | 2\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_right(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t2.b, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   |        | 5\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n2   | 2      | 2\n2   | 2      | 3\n4   |        | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_right(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | -3\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_right(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t2.b, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   |        | 10\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n4   |        | 3\n```\n::\n::\n"}
{"doc": "The `pw.io.fs.read()` function reads a table from one or several files with specified formats (csv, json, or plaintext) and returns a table read. It takes multiple parameters such as path, format, value_columns, mode, primary_key, csv_settings, types, default_values, json_field_paths, persistent_id, and debug_data. The function can read data from a single file or a folder containing multiple files. It supports streaming and static mode. It also supports mapping field names into paths in a JSON object. The function returns a table read.\npw.io.fs.read(path, format, \\*, value_columns=None, mode='streaming', primary_key=None, csv_settings=None, types=None, default_values=None, json_field_paths=None, persistent_id=None, autocommit_duration_ms=None, debug_data=None)\nReads a table from one or several files with the specified format.\n\nIn case the folder is passed to the engine, the order in which files from the directory are processed is determined according to the modification time of files within this folder: they will be processed by ascending order of the modification time.\n\nIn case the format is \u201cplaintext\u201d, the table will consist of a single column\n`data` with each cell containing a single line from the file.\n\n\n* Parameters\n\n    * path (`str`) \u2013 Path to the file or to the folder with files.\n\n    * value_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 Names of the columns to be extracted from the files.\n\n    * format (`str`) \u2013 Format of data to be read. Currently \u201ccsv\u201d, \u201cjson\u201d and \u201cplaintext\u201d formats are supported.\n\n    * mode (`str`) \u2013 If set to \u201cstreaming\u201d, the engine will wait for the new input files in the directory. Set it to \u201cstatic\u201d, it will only consider the available data and ingest all of it in one commit. Default value is \u201cstreaming\u201d.\n\n    * primary_key (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according toa subset of its columns, the set of columns should be specified in this field. Otherwise, the primary key will be generated randomly.\n\n    * csv_settings (`Optional`\\[`CsvParserSettings`\\]) \u2013 Settings for the CSV parser. This parameter is used only in case the specified format is \u201ccsv\u201d.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`. Supported in \u201ccsv\u201d and \u201cjson\u201d formats.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * json_field_paths (`Optional`\\`Dict`\\[`str`, `str`\\]\\]) \u2013 If the format is \u201cjson\u201d, this field allows to map field namesinto path in the read json object. For the field which require such mapping, it should be given in the format `<field_name>: <path to be mapped>`, where the path to be mapped needs to be a [JSON Pointer (RFC 6901).\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nExample:\n\nConsider you want to read a dataset, stored in the filesystem in a standard CSV\nformat. The dataset contains data about pets and their owners.\n\nFor the sake of demonstration, you can prepare a small dataset by creating a CSV file\nvia a unix command line tool:\n\n\n```bash\nprintf \"id,owner,pet\\n1,Alice,dog\\n2,Bob,dog\\n3,Alice,cat\\n4,Bob,dog\" > dataset.csv\n```\nIn order to read it into Pathway\u2019s table, you can first do the import and then\nuse the `pw.io.fs.read` method:\n\n\n```python\nimport pathway as pw\nt = pw.io.fs.read(\"dataset.csv\", format=\"csv\", value_columns=[\"owner\", \"pet\"])\n```\nThen, you can output the table in order to check the correctness of the read:\n\n\n\nCode\n```python\npw.debug.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nowner pet\nAlice dog\n  Bob dog\nAlice cat\n  Bob dog\n```\n::\n::\nSimilarly, we can do the same for JSON format.\n\nFirst, we prepare a dataset:\n\n\n```bash\nprintf \"{\\\"id\\\":1,\\\"owner\\\":\\\"Alice\\\",\\\"pet\\\":\\\"dog\\\"}\n{\\\"id\\\":2,\\\"owner\\\":\\\"Bob\\\",\\\"pet\\\":\\\"dog\\\"}\n{\\\"id\\\":3,\\\"owner\\\":\\\"Bob\\\",\\\"pet\\\":\\\"cat\\\"}\n{\\\"id\\\":4,\\\"owner\\\":\\\"Bob\\\",\\\"pet\\\":\\\"cat\\\"}\" > dataset.jsonlines\n```\nAnd then, we use the method with the \u201cjson\u201d format:\n\n\n```python\nt = pw.io.fs.read(\"dataset.jsonlines\", format=\"json\", value_columns=[\"owner\", \"pet\"])\n```\nNow let\u2019s try something different. Consider you have site access logs stored in a\nseparate folder in several files. For the sake of simplicity, a log entry contains\nan access ID, an IP address and the login of the user.\n\nA dataset, corresponding to the format described above can be generated, thanks to the\nfollowing set of unix commands:\n\n\n```bash\nmkdir logs\nprintf \"id,ip,login\\n1,127.0.0.1,alice\\n2,8.8.8.8,alice\" > logs/part_1.csv\nprintf \"id,ip,login\\n3,8.8.8.8,bob\\n4,127.0.0.1,alice\" > logs/part_2.csv\n```\nNow, let\u2019s see how you can use the connector in order to read the content of this\ndirectory into a table:\n\n\n```python\nt = pw.io.fs.read(\"logs/\", format=\"csv\", value_columns=[\"ip\", \"login\"])\n```\nThe only difference is that you specified the name of the directory instead of the\nfile name, as opposed to what you had done in the previous example. It\u2019s that simple!\n\nAlternatively, we can do the same for the \u201cjson\u201d variant:\n\nThe dataset creation would look as follows:\n\n\n```bash\nmkdir logs\nprintf \"{\\\"id\\\":1,\\\"ip\\\":\\\"127.0.0.1\\\",\\\"login\\\":\\\"alice\\\"}\n{\\\"id\\\":2,\\\"ip\\\":\\\"8.8.8.8\\\",\\\"login\\\":\\\"alice\\\"}\" > logs/part_1.jsonlines\nprintf \"{\\\"id\\\":3,\\\"ip\\\":\\\"8.8.8.8\\\",\\\"login\\\":\\\"bob\\\"}\n{\\\"id\\\":4,\\\"ip\\\":\\\"127.0.0.1\\\",\\\"login\\\":\\\"alice\\\"}\" > logs/part_2.jsonlines\n```\nWhile reading the data from logs folder can be expressed as:\n\n\n```python\nt = pw.io.fs.read(\"logs/\", format=\"json\", value_columns=[\"ip\", \"login\"], mode=\"static\")\n```\nBut what if you are working with a real-time system, which generates logs all the time.\nThe logs are being written and after a while they get into the log directory (this is\nalso called \u201clogs rotation\u201d). Now, consider that there is a need to fetch the new files\nfrom this logs directory all the time. Would Pathway handle that? Sure!\n\nThe only difference would be in the usage of `mode` field. So the code\nsnippet will look as follows:\n\n\n```python\nt = pw.io.fs.read(\"logs/\", format=\"csv\", value_columns=[\"ip\", \"login\"], mode=\"streaming\")\n```\nOr, for the \u201cjson\u201d format case:\n\n\n```python\nt = pw.io.fs.read(\"logs/\", format=\"json\", value_columns=[\"ip\", \"login\"], mode=\"streaming\")\n```\nWith this method, you obtain a table updated dynamically. The changes in the logs would incur\nchanges in the Business-Intelligence \u2018BI\u2019-ready data, namely, in the tables you would like to output. To see\nhow these changes are reported by Pathway, have a look at the\n\u201cStreams of Updates and Snapshots\u201d\narticle.\n\nFinally, a simple example for the plaintext format would look as follows:\n\n\n```python\nt = pw.io.fs.read(\"raw_dataset/lines.txt\", format=\"plaintext\")\n```\n"}
{"doc": "The `pw.io.fs.write` function in Pathway framework writes the stream of updates of a given table to a file in either CSV or JSON format specified by the user. The function takes in three parameters: `table`, `filename`, and `format`. The returned value is `None`. The function is demonstrated with examples of writing a CSV and JSON file. The CSV file contains columns representing data, time, and diff, while the JSON file contains plain JSON data.\npw.io.fs.write(table, filename, format)\nWrites `table`\u2019s stream of updates to a file in the given format.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 Table to be written.\n\n    * filename (`str`) \u2013 Path to the target output file.\n\n    * format (`str`) \u2013 Format to use for data output. Currently, there are two supported formats: \u201cjson\u201d and \u201ccsv\u201d\n\n\n\n* Returns\n\n    None\n\n\nExample:\n\nIn this simple example you can see how table output works.\nFirst, import Pathway and create a table:\n\n\n```python\nimport pathway as pw\nt = pw.debug.parse_to_table(\"age owner pet \\n 1 10 Alice dog \\n 2 9 Bob cat \\n 3 8 Alice cat\")\n```\nConsider you would want to output the stream of changes of this table in csv format.\nIn order to do that you simply do:\n\n\n```python\npw.io.fs.write(t, \"table.csv\", format=\"csv\")\n```\nNow, let\u2019s see what you have on the output:\n\n\n```bash\ncat table.csv\n```\n\n```csv\nage,owner,pet,time,diff\n10,\"Alice\",\"dog\",0,1\n9,\"Bob\",\"cat\",0,1\n8,\"Alice\",\"cat\",0,1\n```\nThe first three columns clearly represent the data columns you have. The column time\nrepresents the number of operations minibatch, in which each of the rows was read. In\nthis example, since the data is static: you have 0. The diff is another\nelement of this stream of updates. In this context, it is 1 because all three rows were read from\nthe input. All in all, the extra information in `time` and `diff` columns - in this case -\nshows us that in the initial minibatch (`time = 0`), you have read three rows and all of\nthem were added to the collection (`diff = 1`).\n\nAlternatively, this data can be written in JSON format:\n\n\n```python\npw.io.fs.write(t, \"table.jsonlines\", format=\"json\")\n```\nThen, we can also check the output file by executing the command:\n\n\n```bash\ncat table.jsonlines\n```\n\n```json\n{\"age\":10,\"owner\":\"Alice\",\"pet\":\"dog\",\"diff\":1,\"time\":0}\n{\"age\":9,\"owner\":\"Bob\",\"pet\":\"cat\",\"diff\":1,\"time\":0}\n{\"age\":8,\"owner\":\"Alice\",\"pet\":\"cat\",\"diff\":1,\"time\":0}\n```\nAs one can easily see, the values remain the same, while the format has changed to a plain JSON.\n"}
{"doc": "This documentation describes the `filter()` function in the Pathway framework. It takes in a filter expression which acts as a predicate for filtering rows in a table. The example code demonstrates how to use `filter()` with other functions like `join()` and `select()` to obtain a result table with selected columns and filtered rows based on a condition.\nfilter(filter_expression)\nFilters rows, keeping the ones satisfying the predicate.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   age  owner  pet\n1   10  Alice    1\n2    9    Bob    1\n3    8  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    age  owner  pet size\n11   10  Alice    3    M\n12    9    Bob    1    L\n13    8    Tom    1   XL\n''')\nresult = t1.join(t2).filter(t1.owner == t2.owner).select(t1.age, t2.size)   # noqa: E501\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nage | size\n8   | M\n9   | L\n10  | M\n```\n::\n::\n"}
{"doc": "This documentation describes the `groupby()` function in Pathway framework, which groups the join result by columns specified in `args`. It takes an optional argument `id` to set the ID's of the rows of the result. The output is a `GroupedJoinResult` object. The example provided shows how to use `groupby()` along with `reduce()` to count pairs of owners and their corresponding pets.\ngroupby(\\*args, id=None)\nGroups join result by columns from args.\n\nNOTE: Usually followed by .reduce() that aggregates the result and returns a table.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 columns to group by.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 if provided, is the column used to set id\u2019s of the rows of the result\n\n\n\n* Returns\n\n    *GroupedJoinResult* \u2013 Groupby object.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   cost  owner  pet\n1   100  Alice    1\n2    90    Bob    1\n3    80  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    cost  owner  pet size\n11   100  Alice    3    M\n12    90    Bob    1    L\n13    80    Tom    1   XL\n''')\nresult = (t1.join(t2, t1.owner==t2.owner).groupby(pw.this.owner)\n    .reduce(pw.this.owner, pairs = pw.reducers.count()))\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nowner | pairs\nAlice | 2\nBob   | 1\n```\n::\n::\n"}
{"doc": "This is the documentation for a function called \"join\" in Pathway framework. The function joins two tables using a given join expression and returns an object on which \"select\" can be called to extract relevant columns. The function takes in parameters such as \"other\" which is the right side of the join and \"on\" which is a list of column expressions. The function also allows for optional arguments like \"id\" and \"how\". The function's usage is demonstrated through an example code and output.\njoin(other, \\*on, id=None, how=JoinMode.INNER)\nJoin self with other using the given join expression.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n    * how (`JoinMode`) \u2013 by default, inner join is performed. Possible values are JoinMode.{INNER,LEFT,RIGHT,OUTER}\n        correspond to inner, left, right and outer join respectively.\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(\n    t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER\n).select(age=t1.age, owner_name=t2.owner, size=t2.size)\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "This is documentation for the `join_inner` function in the Pathway framework. It takes two tables or join results, and joins them based on specified columns. The function returns a `JoinResult` object that can be used to select relevant columns from the result of the join. The example given demonstrates how to use `join_inner` with two tables, and extract specific columns from the joined result.\njoin_inner(other, \\*on, id=None)\nInner-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER).select(age=t1.age, owner_name=t2.owner, size=t2.size)  # noqa: E501\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "This documentation describes the `join_left()` method in the Pathway framework, which performs a left join on two tables or join results. The method takes in two parameters: `other` (a table or join result) and `*on` (columns to join). It also has an optional `id` parameter. The method returns a `JoinResult` object. The behavior of the method is described in detail, including how missing values are handled. An example of using the method is also provided.\njoin_left(other, \\*on, id=None)\nLeft-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks:\nargs cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- rows from the right side that were not matched with the left side are skipped\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_left(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "This documentation describes the `join_outer` function in the Pathway framework, which is used for outer-joining two tables or join results. The function takes in two parameters: `other` and `*on`, where `other` is the table or join result being joined and `*on` specifies the columns to join. The function returns a `JoinResult` object on which `.select()` may be called to extract relevant columns from the result of the join. The documentation also provides an example of using the function and the expected output.\njoin_outer(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,             as the result table has id column with auto-generated ids;             it can be selected by assigning it to a column with defined             name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_outer(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t1.id,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "This is documentation for the `join_right` function in the Pathway framework. It takes two tables or join results and performs an outer join on them based on specified columns. The function returns a `JoinResult` object on which the `select` method can be called to extract relevant columns. The `id` parameter is optional and refers to an id column in the result table. The documentation also includes an example code snippet and the resulting output.\njoin_right(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- rows from the left side that were not matched with the right side are skipped\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_right(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(pw.coalesce(t1.B,0) + t2.D,t1.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n```\n::\n::\n\n* Returns\n\n    OuterJoinResult object\n\n\n"}
{"doc": "The documentation describes the `promise_universe_is_equal_to` function in the Pathway framework. This function asserts that the universe of the object on which it is called is a subset of the universe of another object. It is used in situations where Pathway cannot deduce one universe being a subset of another and returns no value. The assertion works in place. An example usage of this function is shown where two tables `t1` and `t2` are created, and `promise_universe_is_equal_to` is called on `t1` to ensure that its universe is a subset of `t2`'s universe. The resulting table `t3` is the concatenation of `t1` and `t2`, which is printed out as a table with two columns `pet` and `age`.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_subset_of` function is used in Pathway framework to assert that the universe of one object is a subset of the universe of another object. It is used when Pathway cannot deduce this subset relationship on its own. The function returns the object itself and works in place. An example usage of the function is provided where two tables are compared and the common subset is returned.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "The `promise_universes_are_disjoint()` function is used in the Pathway framework to assert that the universe of the current table is disjoint from the universe of another table. If Pathway cannot deduce that the universes are disjoint, this assertion is used. The function works in place and returns the current table. The given code imports Pathway and uses the `promise_universes_are_disjoint()` function to make sure that the universes of tables t1 and t2 are disjoint. Then, the code concatenates the two tables into t3 and prints the resulting table without including the ID column.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n"}
{"doc": "The `reduce` function in the Pathway framework reduces a join result to a single row. It takes in `*args` and `**kwargs` as reducers to reduce the table with, and returns a reduced table. The `args` should be a `ColumnReference`, while the `kwargs` should be a `ColumnExpression` with the key being the new name of a column. An example usage is shown in the documentation where it reduces the joined table by counting the number of total pairs.\nreduce(\\*args, \\*\\*kwargs)\nReduce a join result to a single row.\n\nEquivalent to self.groupby().reduce(\\*args, \\*\\*kwargs).\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 reducer to reduce the table with\n\n    * kwargs (`ColumnExpression`) \u2013 reducer to reduce the table with. Its key is the new name of a column.\n\n\n\n* Returns\n\n    *Table* \u2013 Reduced table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   cost  owner  pet\n1   100  Alice    1\n2    90    Bob    1\n3    80  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    cost  owner  pet size\n11   100  Alice    3    M\n12    90    Bob    1    L\n13    80    Tom    1   XL\n''')\nresult = t1.join(t2, t1.owner==t2.owner).reduce(total_pairs = pw.reducers.count())\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\ntotal_pairs\n3\n```\n::\n::\n"}
{"doc": "The documentation describes the `select()` function in the Pathway framework. This function is used to compute the result of a join between two tables based on specified column references and expressions. The function takes in `args` as column references, and `kwargs` as column expressions with their new assigned names. The function returns a created table. An example is given that demonstrates how to use the function to select specific columns after a join operation.\nselect(\\*args, \\*\\*kwargs)\nComputes result of a join.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 Column references.\n\n    * kwargs (`Any`) \u2013 Column expressions with their new assigned names.\n\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, t1.pet == t2.pet, t1.owner == t2.owner).select(age=t1.age, owner_name=t2.owner, size=t2.size)   # noqa: E501\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n\n"}
{"doc": "The documentation describes a class called \"JoinResult\" in the Pathway framework which represents the result of a join operation between two tables. It provides an example of how to use the class to perform a join operation between two tables in Python and check if the result is an instance of the \"JoinResult\" class. It also shows how to perform a select operation on the join result and print the resulting table.\nclass  pw.JoinResult(_universe, _context, _left_table, _right_table, _original_left, _original_right, _substitution, _chained_join_desugaring, _joined_on_names, _join_mode)\n\nResult of a join between tables.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   age  owner  pet\n1   10  Alice    1\n2    9    Bob    1\n3    8  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    age  owner  pet size\n11   10  Alice    3    M\n12    9    Bob    1    L\n13    8    Tom    1   XL\n''')\njoinresult= t1.join(t2, t1.pet == t2.pet, t1.owner == t2.owner)   # noqa: E501\nisinstance(joinresult, pw.JoinResult)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n\nCode\n```python\npw.debug.compute_and_print(joinresult.select(t1.age, t2.size), include_id=False)\n```\n::\nResult\n```\nage | size\n9   | L\n```\n::\n::\n"}
{"doc": "This piece of documentation describes the `filter` function in the Pathway framework. The function is used to filter rows in a table based on a given predicate. The example code shows how the function can be used to filter rows from two joined tables where the owner columns match. The resulting table only contains the age and size columns of the matching rows.\nfilter(filter_expression)\nFilters rows, keeping the ones satisfying the predicate.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   age  owner  pet\n1   10  Alice    1\n2    9    Bob    1\n3    8  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    age  owner  pet size\n11   10  Alice    3    M\n12    9    Bob    1    L\n13    8    Tom    1   XL\n''')\nresult = t1.join(t2).filter(t1.owner == t2.owner).select(t1.age, t2.size)   # noqa: E501\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nage | size\n8   | M\n9   | L\n10  | M\n```\n::\n::\n"}
{"doc": "The `groupby()` function in the Pathway framework is used to group join results by columns passed as arguments. It takes an optional `id` parameter to set the id's of the resulting rows. The function returns a `GroupedJoinResult` object and is usually followed by the `reduce()` function to aggregate the result and return a table. The documentation includes an example of how to use `groupby()` in the Pathway framework along with expected output.\ngroupby(\\*args, id=None)\nGroups join result by columns from args.\n\nNOTE: Usually followed by .reduce() that aggregates the result and returns a table.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 columns to group by.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 if provided, is the column used to set id\u2019s of the rows of the result\n\n\n\n* Returns\n\n    *GroupedJoinResult* \u2013 Groupby object.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   cost  owner  pet\n1   100  Alice    1\n2    90    Bob    1\n3    80  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    cost  owner  pet size\n11   100  Alice    3    M\n12    90    Bob    1    L\n13    80    Tom    1   XL\n''')\nresult = (t1.join(t2, t1.owner==t2.owner).groupby(pw.this.owner)\n    .reduce(pw.this.owner, pairs = pw.reducers.count()))\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nowner | pairs\nAlice | 2\nBob   | 1\n```\n::\n::\n"}
{"doc": "This is documentation for a function called `join` in the Pathway framework, which allows two tables to be joined using a specified join expression. \n\nThe `join` function takes in several parameters, including the right side of the join (`other`), a list of column expressions (`on`) which must be in the form of LHS: ColumnReference == RHS: ColumnReference, an optional argument for id of result (`id`), and the type of join to be performed (`how`).\n\nThe function returns a `JoinResult` object which can be used to extract the relevant columns from the joined table.\n\nThe documentation also includes an example code snippet which demonstrates how to use the `join` function to join two tables and select specific columns from the result.\njoin(other, \\*on, id=None, how=JoinMode.INNER)\nJoin self with other using the given join expression.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n    * how (`JoinMode`) \u2013 by default, inner join is performed. Possible values are JoinMode.{INNER,LEFT,RIGHT,OUTER}\n        correspond to inner, left, right and outer join respectively.\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(\n    t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER\n).select(age=t1.age, owner_name=t2.owner, size=t2.size)\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "This documentation describes the function `join_inner()` in the Pathway framework. It is used to perform an inner join on two tables or join results. The function takes in two mandatory arguments: `other`, which is the right side of the join, and `on`, which is a list of column expressions defining the join condition. An optional argument `id` can also be passed. The function returns a JoinResult object which can be used to extract relevant columns from the join result using `select()`. The example provided demonstrates how to use the function to perform an inner join on two tables and select specific columns from the result.\njoin_inner(other, \\*on, id=None)\nInner-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER).select(age=t1.age, owner_name=t2.owner, size=t2.size)  # noqa: E501\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "This is the documentation for the `join_left()` method in the pathway framework. This method performs a left-join between two tables or join results. It takes in another table to join with, a list of columns to join on, and an optional ID column. The behavior of the method is explained in the documentation. An example code is also provided to demonstrate how to use the `join_left()` method.\njoin_left(other, \\*on, id=None)\nLeft-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks:\nargs cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- rows from the right side that were not matched with the left side are skipped\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_left(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "This is the documentation for the `join_outer` method in the Pathway framework. It describes how to join two tables or join results with outer join and explains the parameters and behavior of the method. There is also an example code provided to show how the method works with two tables and how to select relevant columns from the result.\njoin_outer(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,             as the result table has id column with auto-generated ids;             it can be selected by assigning it to a column with defined             name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_outer(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t1.id,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "The documentation describes the `join_right` function in the Pathway framework that performs outer join operation between two tables. It takes another table, 'other', and columns to join as input parameters. The function returns an object that can be used to extract relevant columns from the join result. The behavior of the function is described in detail, including which rows are skipped or replaced with None. An example code snippet demonstrates how to use the function with two tables and extract relevant columns from the result.\njoin_right(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- rows from the left side that were not matched with the right side are skipped\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_right(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(pw.coalesce(t1.B,0) + t2.D,t1.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n```\n::\n::\n\n* Returns\n\n    OuterJoinResult object\n\n\n"}
{"doc": "The `promise_universe_is_equal_to` function is a method of the `Table` class in the Pathway framework. It takes one parameter, `other`, and asserts that the universe of the current table is a subset of the universe of `other`. The function is used when Pathway cannot deduce one universe being a subset of another. The function works in place and doesn't return anything. The example code shows how to use this function to create a new table by concatenating two tables and ensuring that their universes are equal.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_subset_of(other)` function is part of the Pathway framework and asserts that the universe of the current object is a subset of the universe of another object. If Pathway cannot deduce one universe being a subset of another, this function can be used. It returns the current object while performing the assertion in place. The example code demonstrates how to use this function in conjunction with Pathway tables.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "The `promise_universes_are_disjoint()` function is used in the Pathway framework to assert that the universes of two tables are disjoint. This is used when Pathway cannot deduce that the universes are disjoint. The function returns the original table and works in place. The code example imports Pathway, creates two tables, and asserts their universes are disjoint using the function. Then, it concatenates the two tables and computes and prints the resulting table.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n"}
{"doc": "This documentation describes the `reduce()` function in the Pathway framework, which allows users to reduce a join result to a single row by grouping the table and applying reducers. The function takes `args` and `kwargs` as parameters where `args` refers to the reducer to reduce the table with and `kwargs` refers to the new name of a column. The function returns a reduced table. An example code is also given to demonstrate the usage of the function.\nreduce(\\*args, \\*\\*kwargs)\nReduce a join result to a single row.\n\nEquivalent to self.groupby().reduce(\\*args, \\*\\*kwargs).\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 reducer to reduce the table with\n\n    * kwargs (`ColumnExpression`) \u2013 reducer to reduce the table with. Its key is the new name of a column.\n\n\n\n* Returns\n\n    *Table* \u2013 Reduced table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n   cost  owner  pet\n1   100  Alice    1\n2    90    Bob    1\n3    80  Alice    2\n''')\nt2 = pw.debug.parse_to_table('''\n    cost  owner  pet size\n11   100  Alice    3    M\n12    90    Bob    1    L\n13    80    Tom    1   XL\n''')\nresult = t1.join(t2, t1.owner==t2.owner).reduce(total_pairs = pw.reducers.count())\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\ntotal_pairs\n3\n```\n::\n::\n"}
{"doc": "The `select()` function in the Pathway framework takes in column references and expressions with new assigned names, and returns a new table with only the selected columns. In the example given, two tables are joined, and then only the age, owner_name, and size columns are selected from the resulting table. The function is demonstrated with sample code and the expected result is provided.\nselect(\\*args, \\*\\*kwargs)\nComputes result of a join.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 Column references.\n\n    * kwargs (`Any`) \u2013 Column expressions with their new assigned names.\n\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, t1.pet == t2.pet, t1.owner == t2.owner).select(age=t1.age, owner_name=t2.owner, size=t2.size)   # noqa: E501\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n\n"}
{"doc": "This documentation describes the `join` function in the Pathway framework, which joins two tables based on a specified condition. The function takes in the second table to join, a list of column expressions to specify the join condition, an optional argument for the result ID, and a join mode. It returns a `JoinResult` object that can be used to select relevant columns from the joined table. The documentation also includes an example usage of the function.\njoin(other, \\*on, id=None, how=JoinMode.INNER)\nJoin self with other using the given join expression.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n    * how (`JoinMode`) \u2013 by default, inner join is performed. Possible values are JoinMode.{INNER,LEFT,RIGHT,OUTER}\n        correspond to inner, left, right and outer join respectively.\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(\n    t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER\n).select(age=t1.age, owner_name=t2.owner, size=t2.size)\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "The documentation describes the `join_inner` method of the `Joinable` class in the Pathway framework. This method is used to perform an inner join between two tables or join results. The `other` parameter is the right side of the join, and the `on` parameter is a list of column expressions that specify the join conditions. The `id` parameter is optional and specifies the ID of the result. The method returns a `JoinResult` object on which `select()` method can be called to extract relevant columns from the result of the join. The documentation also provides an example code snippet that demonstrates how to use this method.\njoin_inner(other, \\*on, id=None)\nInner-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 the right side of the join.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional argument for id of result, can be only self.id or other.id\n\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\nage  | owner  | pet\n 10  | Alice  | 1\n  9  | Bob    | 1\n  8  | Alice  | 2\n''')\nt2 = pw.debug.parse_to_table('''\nage  | owner  | pet | size\n 10  | Alice  | 3   | M\n 9   | Bob    | 1   | L\n 8   | Tom    | 1   | XL\n''')\nt3 = t1.join(t2, t1.pet == t2.pet, t1.owner == t2.owner, how=pw.JoinMode.INNER).select(age=t1.age, owner_name=t2.owner, size=t2.size)  # noqa: E501\npw.debug.compute_and_print(t3, include_id = False)\n```\n::\nResult\n```\nage | owner_name | size\n9   | Bob        | L\n```\n::\n::\n"}
{"doc": "This is the documentation for the `join_left` function in the Pathway framework. This function performs a left join between two tables or join results. The `other` parameter represents the table or join result to join with, and the `*on` parameter specifies the columns to join. The `id` parameter is optional and specifies the id column of the result. The join result can be further selected using `.select()` to extract relevant columns. The behavior of the function is explained in detail, including how missing values are handled. Finally, the documentation includes an example code snippet and its result.\njoin_left(other, \\*on, id=None)\nLeft-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks:\nargs cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- rows from the right side that were not matched with the left side are skipped\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_left(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "This piece of documentation describes a function called `join_outer()` in the Pathway framework. The function performs an outer join between two tables or join results. The function takes two arguments, `other` and `*on`, where `other` is the table or join result to join and `*on` represents the columns to join. The function also has an optional `id` argument which specifies the ID column of the result. The function returns a `JoinResult` object on which `.select()` can be called to extract relevant columns from the result of the join. The documentation also includes an example code which demonstrates how the `join_outer()` function can be used to join two tables and perform relevant operations on the result.\njoin_outer(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,             as the result table has id column with auto-generated ids;             it can be selected by assigning it to a column with defined             name (passed in kwargs)\n\nBehavior:\n- for rows from the left side that were not matched with the right side,\nmissing values on the right are replaced with None\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_outer(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(t1.B + t2.D,t1.id,t2.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n13 |      |\n13 |      |\n```\n::\n::\n"}
{"doc": "This is the documentation for the `join_right` function in the Pathway framework. It is used to join two tables or join results based on specified columns. The function returns a `JoinResult` object on which `.select()` can be called to extract relevant columns from the joined results. The function has parameters such as `other`, which is the table or join result to be joined, `*on` which specifies the columns to be joined, and `id` which is an optional ID column of the result. The function also has behavior and example sections for better understanding.\njoin_right(other, \\*on, id=None)\nOuter-joins two tables or join results.\n\n\n* Parameters\n\n    * other (`Joinable`) \u2013 Table or join result.\n\n    * \\*on \u2013 Columns to join, syntax self.col1 == other.col2\n\n    * id (`Optional`\\[`ColumnReference`\\]) \u2013 optional id column of the result\n\n\nRemarks: args cannot contain id column from either of tables,         as the result table has id column with auto-generated ids;         it can be selected by assigning it to a column with defined         name (passed in kwargs)\n\nBehavior:\n- rows from the left side that were not matched with the right side are skipped\n- for rows from the right side that were not matched with the left side,\nmissing values on the left are replaced with None\n- for rows that were matched the behavior is the same as that of an inner join.\n\n\n* Returns\n\n    *JoinResult* \u2013 an object on which .select() may be called to extract relevant\n    columns from the result of the join.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | A  | B\n      1 | 11 | 111\n      2 | 12 | 112\n      3 | 13 | 113\n      4 | 13 | 114\n    '''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n        | C  | D\n      1 | 11 | 211\n      2 | 12 | 212\n      3 | 14 | 213\n      4 | 14 | 214\n    '''\n)\npw.debug.compute_and_print(t1.join_right(t2, t1.A == t2.C\n).select(t1.A, t2_C=t2.C, S=pw.require(pw.coalesce(t1.B,0) + t2.D,t1.id)),\ninclude_id=False)\n```\n::\nResult\n```\nA  | t2_C | S\n   | 14   |\n   | 14   |\n11 | 11   | 322\n12 | 12   | 324\n```\n::\n::\n\n* Returns\n\n    OuterJoinResult object\n\n\n"}
{"doc": "The `promise_universe_is_equal_to` function is used in the pathway framework to assert that the universe of a given object is a subset of the universe of another object. It is used when the framework cannot deduce one universe being a subset of another. This function returns none and works in place. An example is shown in Python code that imports the pathway framework, and uses the function with two tables to ensure that their universes are equal, and then prints the resulting table.\npromise_universe_is_equal_to(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the others.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: None\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | pet\n1 | Dog\n7 | Cat\n''')\nt2 = pw.debug.parse_to_table('''\n  | age\n1 | 10\n7 | 3\n''')\nt1 = t1.promise_universe_is_equal_to(t2)\nt3 = t1 + t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\npet | age\nCat | 3\nDog | 10\n```\n::\n::\n"}
{"doc": "The `promise_universe_is_subset_of(other)` function in Pathway framework is used to assert that the universe of the current table is a subset of the universe of another table. It is used in situations where Pathway cannot deduce one universe being a subset of another. The function returns the current table and works in place. An example is given in which two tables are created and the function is used to assert that the universe of one table is a subset of the other. The result of the operation is then printed.\npromise_universe_is_subset_of(other)\nAsserts to Pathway that an universe of self is a subset of universe of each of the other.\n\nSemantics: Used in situations where Pathway cannot deduce one universe being a subset of another.\n\nReturns: self\n\nNote: The assertion works in place.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 30\n''').promise_universe_is_subset_of(t1)\nt3 = t1 << t2\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 30\n```\n::\n::\n"}
{"doc": "The documentation describes the `promise_universes_are_disjoint()` method in the Pathway framework. This method is used to assert that the universe of one object is disjoint from another object's universe, in situations where Pathway cannot deduce this on its own. The method returns the object on which it was called and works in place. The documentation also includes a code example demonstrating the use of this method to combine two tables with disjoint universes.\npromise_universes_are_disjoint(other)\nAsserts to Pathway that an universe of self is disjoint from universe of other.\n\nSemantics: Used in situations where Pathway cannot deduce universes are disjoint.\n\nReturns: self\n\nNote: The assertion works in place.\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.parse_to_table('''\n  | age | owner | pet\n1 | 10  | Alice | 1\n2 | 9   | Bob   | 1\n3 | 8   | Alice | 2\n''')\nt2 = pw.debug.parse_to_table('''\n   | age | owner | pet\n11 | 11  | Alice | 30\n12 | 12  | Tom   | 40\n''').promise_universes_are_disjoint(t1)\nt3 = t1.concat(t2)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nage | owner | pet\n8   | Alice | 2\n9   | Bob   | 1\n10  | Alice | 1\n11  | Alice | 30\n12  | Tom   | 40\n```\n::\n::\n\n"}
{"doc": "This documentation explains how to use SQL commands with Pathway framework using the `pw.sql` function. It also specifies which SQL operations are compatible with Pathway and serves as a guide on how to execute SQL queries using Pathway. However, it is not an introduction to SQL.\n---\ntitle: SQL API\ndescription: 'Using SQL commands with Pathway using pw.sql function.'\nnotebook_export_path: documentation/sql_api.ipynb\n---\n<a href=\"https://colab.research.google.com/github/pathwaycom/pathway-examples/blob/main/documentation/sql_api.ipynb\" target=\"_parent\"><img src=\"https://pathway.com/assets/colab-badge.svg\" alt=\"Run In Colab\" class=\"inline\"/></a>&nbsp;&nbsp;<a href=\"https://github.com/pathwaycom/pathway-examples/blob/main/documentation/sql_api.ipynb\" target=\"_parent\"><img  src=\"https://pathway.com/assets/gh-badge.svg\" alt=\"View in Github\" class=\"inline\"/></a>\n\n# Using SQL with Pathway\nPerform SQL commands using Pathway's `pw.sql` function.\n\n---\n\nPathway provides a very simple way to use SQL commands directly in your Pathway application: the use of `pw.sql`.\nPathway is significantly different from a usual SQL database, and not all SQL operations are available in Pathway.\nIn the following, we present the SQL operations which are compatible with Pathway and how to use `pw.sql`.\n\nThis article is a summary of dos and don'ts on how to use Pathway to execute SQL queries, this is not an introduction to SQL.\n"}
{"doc": "This documentation describes how to execute SQL commands using the `pw.sql` function in the Pathway framework. You can pass an SQL query as an argument to the function and also specify the table to be used for the query. The function also allows you to pass an arbitrary number of table associations as keyword arguments.\nUsage\nYou can very easily execute a SQL command by doing the following:\n\n```python\npw.sql(query, tab=t)\n```\n\nThis will execute the SQL command `query` where the Pathway table `t` (Python local variable) can be referred to as  `tab` (SQL table name) inside `query`.\nMore generally, you can pass an arbitrary number of tables associations `name, table` using `kwargs`: `pw.sql(query, tab1=t1, tab2=t2,.., tabn=tn)`.\n"}
{"doc": "This piece of documentation shows an example of how to use the `table_from_markdown` function and the `sql` method in the Pathway framework. The `table_from_markdown` function is used to create a table from a markdown string, and the `sql` method is used to execute a SQL query on the table. The resulting table is then printed using the `compute_and_print` method.\nExample\n\n\n```python\nimport pathway as pw\n\nt = pw.debug.table_from_markdown(\n    \"\"\"\n    | a | b\n 1  | 1 | 2\n 2  | 4 | 3\n 3  | 4 | 7\n \"\"\"\n)\n\nret = pw.sql(\"SELECT * FROM tab WHERE a<b\", tab=t)\npw.debug.compute_and_print(ret)\n```\n\n                | a | b\n    ^YYY4HAB... | 1 | 2\n    ^3CZ78B4... | 4 | 7\n\n"}
{"doc": "This documentation pertains to the naming conventions for column names in the Pathway framework. It specifies that column names are not case sensitive in SQL when using `pw.sql` and encourages the use of standard Python naming conventions for column and table names. It warns against using special characters other than \"\\_\", alphanumeric characters, and starting with a number. Lastly, it advises against using spaces in column names as it may cause errors when using dot notation in Pathway, but provides an alternative syntax using square brackets.\nColumn names\nUnlike in Pathway, column names are not case sensitive in SQL so column names are NOT case sensitive when using `pw.sql`.\nTo improve the compatibility with Pathway, we encourage the use of the standard Python naming convention for column and table names: no special character other than \"\\_\", alphanumeric characters, and not starting with a number.\nUsing a space will work in the SQL layer (e.g. returning a column called `\"a column\"`), though it may be impractical afterwards, when using the dot notation in Pathway: `t.a column` will raise an error. You can still use the `t[\"a column\"]` syntax in Pathway.\n"}
{"doc": "This documentation describes the differences between the SQL standard and the Pathway framework. It highlights that not all SQL queries can be executed in Pathway due to its focus on processing streaming and dynamic data efficiently. Additionally, Pathway does not guarantee any row order, and operations such as `INSERT INTO` are not supported as Pathway tables are immutable. The documentation also mentions that some SQL keywords and functions are not supported yet or should not be used, and anonymous columns should be avoided.\nDifferences from the SQL standard\nFirst of all, not all SQL queries can be executed in Pathway.\nThis stems mainly from the fact that Pathway is built to process streaming and dynamic data efficiently.\n\n### No ordering\nIn Pathway, indexes are separately generated and maintained by the engine, which does not guarantee any row order: SQL operations like `LIMIT`, `ORDER BY` or `SELECT TOP` don't always make sense in this context. In the future, we will support an `ORDER BY ... LIMIT ...` keyword combination, which is typically meaningful in Pathway.\nThe column `id` is reserved and should not be used as a column name, this column is not captured by `*` expressions.\n\nFurthermore, there is no order on the columns and the column order used in a `SELECT` query need not be preserved.\n\n### Immutability\nPathway tables are immutable: operations such as `INSERT INTO` are not supported.\n\n### Limits\nCorrelated subqueries are currently not supported and keywords such as `LIKE`, `ANY`, `ALL`, or `EXISTS` are not supported.\n`COALESCE` and`IFNULL` are not supported but should be soon.\nWe strongly suggest not to use anonymous columns: they might work but we cannot guarantee their behavior.\n"}
{"doc": "This documentation explains how to use the `SELECT` function in Pathway framework to access different columns of a table. One can use `SELECT` with specified column names or the `*` notation to select all the columns. However, the `id` column is not captured by the `*` expression.\n`SELECT`\nUsing select, you can access the different columns of a table:\n\n\n```python\nresult_select = pw.sql(\"SELECT a FROM tab\", tab=t)\npw.debug.compute_and_print(result_select)\n```\n\n                | a\n    ^YYY4HAB... | 1\n    ^Z3QWT29... | 4\n    ^3CZ78B4... | 4\n\n\n\u26a0\ufe0f Pathway does not preserve the order of columns!\n\n#### Star notation\nPathway supports the star notation `*` to select all the columns:\n\n\n```python\nresult_star = pw.sql(\"SELECT * FROM tab\", tab=t)\npw.debug.compute_and_print(result_star)\n```\n\n                | a | b\n    ^YYY4HAB... | 1 | 2\n    ^Z3QWT29... | 4 | 3\n    ^3CZ78B4... | 4 | 7\n\n\n\u26a0\ufe0f Every Pathway table has a special column `id`: this column is NOT captured by `*` expressions in SQL.\n"}
{"doc": "This documentation is about the `GROUP BY` clause in SQL which is used to group rows with the same value for a given column and perform an aggregate function over those grouped rows. It also mentions that `GROUP BY` and `JOIN` should not be used together in a single `SELECT`. Additionally, the documentation lists the aggregation functions that can be used with `GROUP BY` and warns about the difference between Pathway reducers and traditional SQL aggregate functions in handling `NULL` values.\n`GROUP BY`\nYou can use `GROUP BY` to group rows with the same value for a given column, and to use an aggregate function over the grouped rows.\n\n\n```python\nresult_groupby = pw.sql(\"SELECT a, SUM(b) FROM tab GROUP BY a\", tab=t)\npw.debug.compute_and_print(result_groupby)\n```\n\n                | a | _col_1\n    ^YYY4HAB... | 1 | 2\n    ^3HN31E1... | 4 | 10\n\n\n\u26a0\ufe0f `GROUP BY` and `JOIN` should not be used together in a single `SELECT`.\n\n#### Aggregation functions\nWith `GROUP BY`, you can use the following aggregation functions:\n- `AVG`\n- `COUNT`\n- `MAX`\n- `MIN`\n- `SUM`\n\n\u26a0\ufe0f Pathway reducers (`pw.count`, `pw.sum`, etc.) aggregate over `None` values, while traditional SQL aggregate functions skip `NULL` values: be careful to remove all the undefined values before using an aggregate function.\n"}
{"doc": "The documentation describes the `AS` (alias) attribute in Pathway framework. It explains that this attribute supports two notations: `old_name as new_name` and `old_name new_name`. The example code provided shows how to use `AS` to rename a column in a SQL query and how it affects the resulting table. The first code block renames column `a` to `c` using `AS`, while the second code block achieves the same result without using `AS`.\n`AS` (alias)\nPathway supports both notations: `old_name as new_name` and `old_name new_name`.\n\n\n```python\nresult_alias = pw.sql(\"SELECT b, a AS c FROM tab\", tab=t)\npw.debug.compute_and_print(result_alias)\n```\n\n                | b | c\n    ^YYY4HAB... | 2 | 1\n    ^Z3QWT29... | 3 | 4\n    ^3CZ78B4... | 7 | 4\n\n\n\n```python\nresult_alias = pw.sql(\"SELECT b, a c FROM tab\", tab=t)\npw.debug.compute_and_print(result_alias)\n```\n\n                | b | c\n    ^YYY4HAB... | 2 | 1\n    ^Z3QWT29... | 3 | 4\n    ^3CZ78B4... | 7 | 4\n\n"}
{"doc": "The documentation is about the `UNION` SQL operator provided by the Pathway framework. It explains that `UNION` is used to combine the results of two or more SELECT statements into a single result set. It also mentions that the operator requires matching column names. The example code demonstrates the use of `UNION` with two tables and shows the resulting output.\n`UNION`\nPathway provides the standard `UNION` SQL operator.\nNote that `UNION` requires matching column names.\n\n\n```python\nt_union = pw.debug.table_from_markdown(\n    \"\"\"\n    | a | b\n 4  | 9 | 3\n 5  | 2 | 7\n \"\"\"\n)\n\nresult_union = pw.sql(\"SELECT * FROM tab UNION SELECT * FROM tab2\", tab=t, tab2=t_union)\npw.debug.compute_and_print(result_union)\n```\n\n                | a | b\n    ^KYCVNKF... | 1 | 2\n    ^856GZ16... | 2 | 7\n    ^H3J0A0V... | 4 | 3\n    ^GX1QVN0... | 4 | 7\n    ^7HC68KR... | 9 | 3\n\n"}
{"doc": "This documentation describes the usage of the `INTERSECT` SQL operator in Pathway Framework. It provides an example code snippet that uses the `INTERSECT` operator to return the intersection of two tables. The documentation also notes that `INTERSECT` does not support `INTERSECT ALL` currently.\n`INTERSECT`\nPathway provides the standard `INTERSECT` SQL operator.\nNote that `INTERSECT` requires matching column names.\n\n\n```python\nt_inter = pw.debug.table_from_markdown(\n    \"\"\"\n    | a | b\n 4  | 9 | 3\n 5  | 2 | 7\n 6  | 1 | 2\n \"\"\"\n)\n\nresult_inter = pw.sql(\n    \"SELECT * FROM tab INTERSECT SELECT * FROM tab2\", tab=t, tab2=t_inter\n)\npw.debug.compute_and_print(result_inter)\n```\n\n                | a | b\n    ^KYCVNKF... | 1 | 2\n\n\n\u26a0\ufe0f `INTERSECT` does not support `INTERSECT ALL` (coming soon).\n"}
{"doc": "The `JOIN` documentation in Pathway framework describes different types of join operations such as `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `SELF JOIN` and `CROSS JOIN`. It also provides an example code snippet using `INNER JOIN` to join two tables and warns against using `GROUP BY` and `JOIN` together in a single `SELECT`. Additionally, it states that `NATURAL JOIN` and `FULL JOIN` are not currently supported but may be available in the future.\n`JOIN`\nPathway provides different join operations: `INNER JOIN`, `LEFT JOIN` (or `LEFT OUTER JOIN`), `RIGHT JOIN` (or `RIGHT OUTER JOIN`), `SELF JOIN`, and `CROSS JOIN`.\n\n\n```python\nt_join = pw.debug.table_from_markdown(\n    \"\"\"\n    | b | c\n 4  | 4 | 9\n 5  | 3 | 4\n 6  | 7 | 5\n \"\"\"\n)\nresult_join = pw.sql(\n    \"SELECT * FROM left_table INNER JOIN right_table ON left_table.b==right_table.b\",\n    left_table=t,\n    right_table=t_join,\n)\npw.debug.compute_and_print(result_join)\n```\n\n                | a | b | c\n    ^J1AVR2S... | 4 | 3 | 4\n    ^8V184A9... | 4 | 7 | 5\n\n\n\u26a0\ufe0f `GROUP BY` and `JOIN` should not be used together in a single `SELECT`.\n\n\u26a0\ufe0f `NATURAL JOIN` and `FULL JOIN` are not supported (coming soon).\n"}
{"doc": "This documentation explains how to perform subqueries using the `WITH` keyword in the Pathway framework. It provides an example code snippet that demonstrates the usage of `WITH` keyword along with the `SELECT` statement and the `GROUP BY` clause to compute the sum of values in a table. The code also demonstrates the usage of `pw.debug.compute_and_print` to display the result.\n`WITH`\nIn addition to being placed inside a `WHERE` clause, subqueries can also be performed using the `WITH` keyword:\n\n\n```python\nresult_with = pw.sql(\n    \"WITH group_table (a, sumB) AS (SELECT a, SUM(b) FROM tab GROUP BY a) SELECT sumB FROM group_table\",\n    tab=t,\n)\npw.debug.compute_and_print(result_with)\n```\n\n                | sumB\n    ^YYY4HAB... | 2\n    ^3HN31E1... | 10\n\n"}
{"doc": "This documentation describes the use of boolean and arithmetic expressions in the Pathway framework. It provides examples of using these operators in SQL queries to filter data from tables. It also shows how to use subqueries in the WHERE clause to filter a table based on the subquery results. The documentation also mentions the limitation of only supporting single row result subqueries.\nBoolean and Arithmetic Expressions\nWith the `SELECT ...` and `WHERE ...` clauses, you can use the following operators:\n- boolean operators: `AND`, `OR`, `NOT`\n- arithmetic operators: `+`, `-`, `*`,  `/`, `DIV`, `MOD`, `==`, `!=`, `<`, `>`, `<=`, `>=`, `<>`\n- NULL\n\n\n```python\nresult_bool = pw.sql(\"SELECT a,b FROM tab WHERE b-a>0 AND a>3\", tab=t)\npw.debug.compute_and_print(result_bool)\n```\n\n                | a | b\n    ^3CZ78B4... | 4 | 7\n\n\nBoth `!=` and `<>` can be used to check non-equality.\n\n\n```python\nresult_neq = pw.sql(\"SELECT a,b FROM tab WHERE a != 4 OR b <> 3\", tab=t)\npw.debug.compute_and_print(result_neq)\n```\n\n                | a | b\n    ^YYY4HAB... | 1 | 2\n    ^3CZ78B4... | 4 | 7\n\n\n`NULL` can be used to filter out rows with missing values:\n\n\n```python\nt_null = pw.debug.table_from_markdown(\n    \"\"\"\n    | a | b\n 1  | 1 | 2\n 2  | 4 |\n 3  | 4 | 7\n \"\"\"\n)\n\nresult_null = pw.sql(\"SELECT a, b FROM tab WHERE b IS NOT NULL \", tab=t_null)\npw.debug.compute_and_print(result_null)\n```\n\n                | a | b\n    ^YYY4HAB... | 1 | 2\n    ^3CZ78B4... | 4 | 7\n\n\nYou can use single row result subqueries in the `WHERE` clause to filter a table based on the subquery results:\n\n\n```python\nt_subqueries = pw.debug.table_from_markdown(\n    \"\"\"\n    | employee | salary\n 1  | 1        | 10\n 2  | 2        | 11\n 3  | 3        | 12\n \"\"\"\n)\nresult_subqueries = pw.sql(\n    \"SELECT employee, salary FROM t WHERE salary >= (SELECT AVG(salary) FROM t)\",\n    t=t_subqueries,\n)\npw.debug.compute_and_print(result_subqueries)\n```\n\n                | employee | salary\n    ^Z3QWT29... | 2        | 11\n    ^3CZ78B4... | 3        | 12\n\n\n\u26a0\ufe0f For now, only single row result subqueries are supported.\nCorrelated subqueries and the associated operations `ANY`, `NONE`, and `EVERY` (or its alias `ALL`) are currently not supported.\n"}
{"doc": "This documentation describes the `pw.io.redpanda.write` function in the Pathway framework. It writes a given table to a topic on a Redpanda instance. It takes in the table, connection settings, topic name, and format of the input data. It only supports JSON format currently. The function returns `None`. The limitations are mentioned and an example is given to understand how to use the function.\npw.io.redpanda.write(table, rdkafka_settings, topic_name, \\*, format='json', \\*\\*kwargs)\nWrite a table to a given topic on a Redpanda instance.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 the table to output.\n\n    * rdkafka_settings (`dict`) \u2013 Connection settings in the format of librdkafka.\n\n\n    * topic_name (`str`) \u2013 name of topic in Redpanda to which the data should be sent.\n\n    * format (`str`) \u2013 format of the input data, only \u201cjson\u201d is currently supported.\n\n\n\n* Returns\n\n    None\n\n\nLimitations:\n\nFor future proofing, the format is configurable, but (for now) only JSON is available.\n\nExample:\n\nConsider there is a queue in Redpanda, running locally on port 9092. Our queue can\nuse SASL-SSL authentication over a SCRAM-SHA-256 mechanism. You can set up a queue\nwith similar parameters in Upstash. Settings for rdkafka\nwill look as follows:\n\n\n\nCode\n```python\nimport os\nrdkafka_settings = {\n```\n::\nResult\n```\n    \"bootstrap.servers\": \"localhost:9092\",\n    \"security.protocol\": \"sasl_ssl\",\n    \"sasl.mechanism\": \"SCRAM-SHA-256\",\n    \"sasl.username\": os.environ[\"KAFKA_USERNAME\"],\n    \"sasl.password\": os.environ[\"KAFKA_PASSWORD\"]\n}\n```\n::\n::\nYou want to send a Pathway table t to the Redpanda instance.\nTo connect to the topic \u201canimals\u201d and send messages, the connector must be used         as follows, depending on the format:\n\nJSON version:\n\n\n\nCode\n```python\nimport pathway as pw\nt = pw.io.redpanda.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    \"animals\",\n    format=\"json\",\n)\n```\n::\n::\nAll the updates of table t will be sent to the Redpanda instance.\n"}
{"doc": "The pw.io.redpanda.read() function in the Pathway framework reads data from one or more Redpanda topics and returns a table. It supports formats such as \"raw\", \"csv\", and \"json\". The function takes in parameters such as connection settings, topic names, format of the input data, value columns, data types, default values, and more. The returned table is different depending on the format used, with the \"raw\" format producing a single-column table named \"data\". An example of the rdkafka_settings parameter for a Redpanda instance is also provided.\npw.io.redpanda.read(rdkafka_settings, topic_names, format='raw', value_columns=None, primary_key=None, types=None, default_values=None, debug_data=None, autocommit_duration_ms=None, json_field_paths=None, parallel_readers=None, persistent_id=None)\nReads table from a set of topics in Redpanda.\nThere are three formats currently supported: \u201craw\u201d, \u201ccsv\u201d, and \u201cjson\u201d.\n\n\n* Parameters\n\n    * rdkafka_settings (`dict`) \u2013 Connection settings in the format of librdkafka.\n\n    * topic_names (`List`\\[`str`\\]) \u2013 Names of topics in Redpanda from which the data should be read.\n\n    * format \u2013 format of the input data, \u201craw\u201d, \u201ccsv\u201d, or \u201cjson\u201d\n\n    * value_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 Columns to extract for a table, required for format other than             \u201craw\u201d.\n\n    * primary_key (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated as uuid4.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (pw.Type) of the values of those columns. This parameter is optional, and if not provided the default type is pw.Type.ANY.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * json_field_paths (`Optional`\\[`Dict`\\[`str`, `str`\\]\\]) \u2013 If the format is JSON, this field allows to map field names\n        into path in the field. For the field which require such mapping, it should be\n        given in the format <field_name>: <path to be mapped>, where the path to\n        be mapped needs to be a JSON Pointer (RFC 6901).\n\n    * parallel_readers (`Optional`\\[`int`\\]) \u2013 number of copies of the reader to work in parallel. In case\n        the number is not specified, min{pathway_threads, total number of partitions}\n        will be taken. This number also can\u2019t be greater than the number of Pathway\n        engine threads, and will be reduced to the number of engine threads, if it\n        exceeds.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nWhen using the format \u201craw\u201d, the connector will produce a single-column table:\nall the data is saved into a column named data.\nFor other formats, the argument value_column is required and defines the columns.\n\nExample:\n\nConsider a simple instance of Redpanda without authentication. Settings for rdkafka\nwill look as follows:\n\n\n\n\n```python\nimport \nos\nrdkafka_settings = {\n```\n::\nResult\n```\n    \"bootstrap.servers\": \"localhost:9092\",\n    \"security.protocol\": \"plaintext\",\n    \"group.id\": \"$GROUP_NAME\",\n    \"session.timeout.ms\": \"60000\"\n}\n```\n::\n::\nTo connect to the topic \u201canimals\u201d and accept messages, the connector must be used         as follows, depending on the format:\n\nRaw version:\n\n\n\npathway as pw\nt = pw.io.redpanda.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"raw\",\n)\n```\n::\n::\nAll the data will be accessible in the column data.\n\nCSV version:\n\n\n\npathway as pw\nt = pw.io.redpanda.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"csv\",\n    value_columns=[\"owner\", \"pet\"],\n)\n```\n::\n::\nIn case of CSV format, the first message must be the header:\n\n\n```csv\nowner,pet\n```\nThen, simple data rows are expected. For example:\n\n\n```csv\nAlice,cat\nBob,dog\n```\nThis way, you get a table which looks as follows:\n\n\n\ng.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nowner pet\nAlice cat\n  Bob dog\n```\n::\n::\nJSON version:\n\n\n\npathway as pw\nt = pw.io.redpanda.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"json\",\n    value_columns=[\"owner\", \"pet\"],\n)\n```\n::\n::\nFor the JSON connector, you can send these two messages:\n\n\n```json\n{\"owner\": \"Alice\", \"pet\": \"cat\"}\n{\"owner\": \"Bob\", \"pet\": \"dog\"}\n```\nThis way, you get a table which looks as follows:\n\n\n\ng.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nowner pet\nAlice cat\n  Bob dog\n```\n::\n::\nNow consider that the data about pets come in a more sophisticated way. For instance\nyou have an owner, kind and name of an animal, along with some physical measurements.\n\nThe JSON payload in this case may look as follows:\n\n\n```json\n{\n    \"name\": \"Jack\",\n    \"pet\": {\n        \"animal\": \"cat\",\n        \"name\": \"Bob\",\n        \"measurements\": [100, 200, 300]\n    }\n}\n```\nSuppose you need to extract a name of the pet and the height, which is the 2nd\n(1-based) or the 1st (0-based) element in the array of measurements. Then, you\nuse JSON Pointer and do a connector, which gets the data as follows:\n\n\n\npathway as pw\nt = pw.io.redpanda.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"json\",\n    value_columns=[\"pet_name\", \"pet_height\"],\n    column_paths={\n        \"pet_name\": \"/pet/name\",\n        \"pet_height\": \"/pet/measurements/1\"\n    },\n)\n```\n::\n::\n"}
{"doc": "The documentation describes the `pw.io.http.read` function in the Pathway framework, which is used to read a table from an HTTP stream. It lists the various parameters that can be used with this function, including the URL, request method, payload, headers, response mapper, format, delimiter, retries, timeouts, and more. It also provides examples of how to use the function in different scenarios.\npw.io.http.read(url, \\*, method='GET', payload=None, headers=None, response_mapper=None, format='json', delimiter=None, n_retries=0, retry_policy=<pathway.io.http._common.RetryPolicy object>, connect_timeout_ms=None, request_timeout_ms=None, allow_redirects=True, retry_codes=(429, 500, 502, 503, 504), value_columns=None, primary_key=None, types=None, default_values=None, autocommit_duration_ms=10000, debug_data=None)\nReads a table from an HTTP stream.\n\n\n* Parameters\n\n    * url (`str`) \u2013 the full URL of streaming endpoint to fetch data from.\n\n    * method (`str`) \u2013 request method for streaming. It should be one of HTTP request methods.\n\n    * payload (`Optional`\\[`Any`\\]) \u2013 data to be send in the body of the request.\n\n    * headers (`Optional`\\[`Dict`\\[`str`, `str`\\]\\]) \u2013 request headers in the form of dict. Wildcards are allowed both, in\n        keys and in values.\n\n    * response_mapper (`Optional`\\[`Callable`\\[\\[`Union`\\[`str`, `bytes`\\]\\], `bytes`\\]\\]) \u2013 in case a response needs to be processed, this method can be\n        provided. It will be applied to each slice of a stream.\n\n    * format (`str`) \u2013 format of the data, \u201cjson\u201d or \u201craw\u201d. In case of a \u201craw\u201d format,\n        table with single \u201cdata\u201d column will be produced. For \u201cjson\u201d format, bytes\n        encoded json is expected.\n\n    * delimiter (`Union`\\[`str`, `bytes`, `None`\\]) \u2013 delimiter used to split stream into messages.\n\n    * n_retries (`int`) \u2013 how many times to retry the failed request.\n\n    * retry_policy (`RetryPolicy`) \u2013 policy of delays or backoffs for the retries.\n\n    * connect_timeout_ms (`Optional`\\[`int`\\]) \u2013 connection timeout, specified in milliseconds. In case\n        it\u2019s None, no restrictions on connection duration will be applied.\n\n    * request_timeout_ms (`Optional`\\[`int`\\]) \u2013 request timeout, specified in milliseconds. In case\n        it\u2019s None, no restrictions on request duration will be applied.\n\n    * allow_redirects (`bool`) \u2013 whether to allow redirects.\n\n    * retry_codes (`Optional`\\[`Tuple`\\]) \u2013 HTTP status codes that trigger retries.\n\n    * content_type \u2013 content type of the data to send. In case the chosen format is\n        JSON, it will be defaulted to \u201capplication/json\u201d.\n\n    * value_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 columns to extract for a table.\n\n    * primary_key (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 in case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated as uuid4.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 dictionary containing the mapping between the columns and the data types\n        (`pw.Type`) of the values of those columns. This parameter is optional, and\n        if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * autocommit_duration_ms (`int`) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * debug_data \u2013 static data replacing original one when debug mode is active.\n\n\nExamples:\n\nRaw format:\n\n\n```python\nimport pathway as pw\ntable = pw.io.http.read(\n  \"https://localhost:8000/stream\",\n  method=\"GET\",\n  headers={\"Authorization\": f\"Bearer {BEARER_TOKEN}\"},\n  format=\"raw\",\n)\n```\nJSON with response mapper:\n\nInput can be adjusted using a mapping function that will be applied to each\nslice of a stream. The mapping function should return bytes.\n\n\n```python\ndef mapper(msg: bytes) -> bytes:\n  result = json.loads(msg.decode())\n  return json.dumps({\"key\": result[\"id\"], \"text\": result[\"data\"]}).encode()\n```\n\n```python\nt = pw.io.http.read(\n  \"https://localhost:8000/stream\",\n  method=\"GET\",\n  headers={\"Authorization\": f\"Bearer {BEARER_TOKEN}\"},\n  value_columns=[\"key\", \"text\"],\n  response_mapper=mapper\n)\n```\n"}
{"doc": "The `pw.io.http.write()` function sends the stream of updates from a table to the specified HTTP API. The function takes parameters such as the `table` to be tracked, `url` of the endpoint to push data into, `method` for streaming, `format` of the payload, `request_payload_template`, `n_retries`, `retry_policy`, `connect_timeout_ms`, `request_timeout_ms`, `allow_redirects`, `retry_codes`, `content_type`, and `headers`. Wildcards are used for customizing HTTP requests and are resolved in the URL, request payload template, and headers. Examples are provided to demonstrate different ways to use the function.\npw.io.http.write(table, url, \\*, method='POST', format='json', request_payload_template=None, n_retries=0, retry_policy=<pathway.io.http._common.RetryPolicy object>, connect_timeout_ms=None, request_timeout_ms=None, content_type=None, headers=None, allow_redirects=True, retry_codes=(429, 500, 502, 503, 504))\nSends the stream of updates from the table to the specified HTTP API.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 table to be tracked.\n\n    * method (`str`) \u2013 request method for streaming. It should be one of HTTP request methods.\n\n\n    * url (`str`) \u2013 the full URL of the endpoint to push data into. Can contain wildcards.\n\n    * format (`str`) \u2013 the payload format, one of {\u201cjson\u201d, \u201ccustom\u201d}. If \u201cjson\u201d is specified, the plain JSON will be formed and sent. Otherwise, the contents of the field request_payload_template will be used.\n\n    * request_payload_template (`Optional`\\[`str`\\]) \u2013 the template to format and send in case \u201ccustom\u201d was specified in the format field. Can include wildcards.\n\n    * n_retries (`int`) \u2013 how many times to retry the failed request.\n\n    * retry_policy (`RetryPolicy`) \u2013 policy of delays or backoffs for the retries.\n\n    * connect_timeout_ms (`Optional`\\[`int`\\]) \u2013 connection timeout, specified in milliseconds. In case it\u2019s None, no restrictions on connection duration will be applied.\n\n    * request_timeout_ms (`Optional`\\[`int`\\]) \u2013 request timeout, specified in milliseconds. In case it\u2019s None, no restrictions on request duration will be applied.\n\n    * allow_redirects (`bool`) \u2013 Whether to allow redirects.\n\n    * retry_codes (`Optional`\\[`Tuple`\\]) \u2013 HTTP status codes that trigger retries.\n\n    * content_type (`Optional`\\[`str`\\]) \u2013 content type of the data to send. In case the chosen format is JSON, it will be defaulted to \u201capplication/json\u201d.\n\n    * headers (`Optional`\\[`Dict`\\[`str`, `str`\\]\\]) \u2013 request headers in the form of dict. Wildcards are allowed both, in keys and in values.\n\n\nWildcards:\n\nWildcards are the proposed way to customize the HTTP requests composed. The\nengine will replace all entries of `{table.<column_name>}` with a value from the\ncolumn `<column_name>` in the row sent. This wildcard resolving will happen in url,\nrequest payload template and headers.\n\nExamples:\n\nFor the sake of demonstation, let\u2019s try diffirent ways to send the stream of changes\non a table `pets`, containing data about pets and their owners. The table contains\njust two columns: the pet and the owner\u2019s name.\n\n\n\nCode\n```python\nimport pathway as pw\npw.debug.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nowner pet\nAlice cat\n  Bob dog\n```\n::\n::\nConsider that there is a need to send the stream of changes on such table to the\nexternal API endpoint (let\u2019s pick some exemplary URL for the sake of demonstation).\n\nTo keep things simple, we can suppose that this API accepts flat JSON objects, which\nare sent in POST requests. Then, the communication can be done with a simple code\nsnippet:\n\n\n```python\nt = pw.io.http.write(pets, \"http://www.example.com/api/event\")\n```\nNow let\u2019s do something more custom. Suppose that the API endpoint requires us to\ncommunicate via PUT method and to pass the values as CGI-parameters. In this case,\nwildcards are the way to go:\n\n\n```python\npw.io.http.write(\n    pets,\n    \"http://www.example.com/api/event?owner={table.owner}&pet={table.pet}\",\n    method=\"PUT\"\n)\n```\nA custom payload can also be formed from the outside. What if the endpoint requires\nthe data in tskv format in request body?\n\nFirst of all, let\u2019s form a template for the message body:\n\n\n```python\nmessage_template_tokens = [\n    \"owner={table.owner}\",\n    \"pet={table.pet}\",\n    \"time={table.time}\",\n    \"diff={table.diff}\",\n]\nmessage_template = \"\\t\".join(message_template_tokens)\n```\nNow, we can use this template and the custom format, this way:\n\n\n```python\npw.io.http.write(\n    pets,\n    \"http://www.example.com/api/event\",\n    method=\"POST\",\n    format=\"custom\",\n    request_payload_template=message_template\n)\n```\n"}
{"doc": "This documentation describes the `pw.io.elasticsearch.write` function in the Pathway framework. It takes a `Table` object, a host and port address of an Elasticsearch server, an authentication object, and an index name as input parameters. The function writes the contents of the table to the specified index in Elasticsearch. The function returns nothing. An example code snippet is also provided to demonstrate the usage of the function.\nFunctions\n\n### pw.io.elasticsearch.write(table, host, auth, index_name)\nWrite a table to a given index in ElasticSearch.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 the table to output.\n\n    * host (`str`) \u2013 the host and port, on which Elasticsearch server works.\n\n    * auth (`ElasticSearchAuth`) \u2013 credentials for Elasticsearch authorization.\n\n    * index_name (`str`) \u2013 name of the index, which gets the docs.\n\n\n\n* Returns\n\n    None\n\n\nExample:\n\nConsider there is an instance of Elasticsearch, running locally on a port 9200.\nThere we have an index \u201canimals\u201d, containing an information about pets and their\nowners.\n\nFor the sake of simplicity we will also consider that the cluster has a simple\nusername-password authentication having both username and password equal to \u201cadmin\u201d.\n\nNow suppose we want to send a Pathway table pets to this local instance of\nElasticsearch.\n\nIt can be done as follows:\n\n\n\nCode\n```python\nimport pathway as pw\nt = pw.io.elasticsearch.write(\n```\n::\nResult\n```\n    table=pets,\n    host=\"http://localhost:9200\",\n    auth=pw.io.elasticsearch.ElasticSearchAuth.basic(\"admin\", \"admin\"),\n    index_name=\"animals\",\n)\n```\n::\n::\nAll the updates of table t will be indexed to \u201canimals\u201d as well.\n"}
{"doc": "The `pw.io.postgres.write` function in Pathway Framework writes a table's stream of updates to a Postgres table. The function requires a dictionary of components for the Postgres connection string and the name of the target table. The table being written must contain time and diff columns of the integer type. The function does not return anything. An example is provided to show how to output a table to a Postgres database.\npw.io.postgres.write(table, postgres_settings, table_name)\nWrites `table`\u2019s stream of updates to a postgres table.\n\nIn order for write to be successful, it is required that the table contains `time`\nand `diff` columns of the integer type - you can refer to the article\n\u201cStreams of Updates and Snapshots\u201d\nto learn more about the reasoning behind it.\n\n\n* Parameters\n\n    * postgres_settings (`dict`) \u2013 Components for the connection string for Postgres.\n\n    * table_name (`str`) \u2013 Name of the target table.\n\n\n\n* Returns\n\n    None\n\n\nExample:\n\nConsider there\u2019s a need to output a stream of updates from a table in Pathway to\na table in Postgres. Let\u2019s see how this can be done with the connector.\n\nFirst of all, one needs to provide the required credentials for Postgres\nconnection string.\nWhile the connection string can include a wide variety of settings, such as SSL\nor connection timeouts, in this example we will keep it simple and provide the\nsmallest example possible. Suppose that the database is running locally on the standard\nport 5432, that it has the name `database` and is accessible under the username\n`user` with a password `pass`.\n\nIt gives us the following content for the connection string:\n\n\n```python\nconnection_string_parts = {\n    \"host\": \"localhost\",\n    \"port\": \"5432\",\n    \"dbname\": \"database\",\n    \"user\": \"user\",\n    \"password\": \"pass\",\n}\n```\nNow let\u2019s load a table, which we will output to the database:\n\n\n```python\nimport pathway as pw\nt = pw.debug.parse_to_table(\"age owner pet \\n 1 10 Alice 1 \\n 2 9 Bob 1 \\n 3 8 Alice 2\")\n```\nIn order to output the table, we will need to create a new table in the database. The table\nwould need to have all the columns that the output data has. Moreover it will need\ninteger columns `time` and `diff`, because these values are an essential part of the\noutput. Finally, it is also a good idea to create the sequential primary key for\nour changes so that we know the updates\u2019 order.\n\nTo sum things up, the table creation boils down to the following SQL command:\n\n\n```sql\nCREATE TABLE pets (\n    id SERIAL PRIMARY KEY,\n    time INTEGER NOT NULL,\n    diff INTEGER NOT NULL,\n    age INTEGER,\n    owner TEXT,\n    pet TEXT\n);\n```\nNow, having done all the preparation, one can simply call:\n\n\n\nCode\n```python\npw.io.postgres.write(\n```\n::\nResult\n```\n    t,\n    connection_string_parts,\n    \"pets\",\n)\n```\n::\n::\n"}
{"doc": "The `write_snapshot` function in the Pathway framework maintains a snapshot of a table within a Postgres table. It requires the `postgres_settings`, `table_name`, and `primary_key` as parameters. The table must contain `time` and `diff` columns of integer type for successful writing. The function does not return any value. An example is provided where a `stats` table is created in Pathway and a Postgres table is set up to maintain its snapshot using `write_snapshot`.\npw.io.postgres.write_snapshot(table, postgres_settings, table_name, primary_key)\nMaintains a snapshot of a table within a Postgres table.\n\nIn order for write to be successful, it is required that the table contains `time`\nand `diff` columns of the integer type - you can refer to the article\n\u201cStreams of Updates and Snapshots\u201d\nto understand the reasoning behind it.\n\n\n* Parameters\n\n    * postgres_settings (`dict`) \u2013 Components of the connection string for Postgres.\n\n    * table_name (`str`) \u2013 Name of the target table.\n\n    * primary_key (`List`\\[`str`\\]) \u2013 Names of the fields which serve as a primary key in the Postgres table.\n\n\n\n* Returns\n\n    None\n\n\nExample:\n\nConsider there is a table `stats` in Pathway, containing the average number of requests to some\nservice or operation per user, over some period of time. The number of requests\ncan be large, so we decide not to store the whole stream of changes, but to only store\na snapshot of the data, which can be actualized by Pathway.\n\nThe minimum set-up would require us to have a Postgres table with two columns: the ID\nof the user `user_id` and the number of requests across some period of time `number_of_requests`.\nIn order to maintain consistency, we also need two extra columns: `time` and `diff`.\n\nThe SQL for the creation of such table would look as follows:\n\n\n```sql\nCREATE TABLE user_stats (\n    user_id TEXT PRIMARY KEY,\n    number_of_requests INTEGER,\n    time INTEGER NOT NULL,\n    diff INTEGER NOT NULL\n);\n```\nAfter the table is created, all you need is just to set up the output connector:\n\n\n\nCode\n```python\nimport pathway as pw\npw.io.postgres.write_snapshot(\n```\n::\nResult\n```\n    stats,\n    {\n        \"host\": \"localhost\",\n        \"port\": \"5432\",\n        \"dbname\": \"database\",\n        \"user\": \"user\",\n        \"password\": \"pass\",\n    },\n    \"user_stats\",\n    [\"user_id\"],\n)\n```\n::\n::\n"}
{"doc": "This documentation lists the available connectors in the Pathway framework for different read and write operations. The connectors are grouped into three categories - read and write, read only, and write only. Each category lists the packages available for specific operations such as reading CSV files, writing to Elasticsearch, or reading from a Kafka stream.\nAvailable connectors\n\n### Read and write\n\n* pathway.io.csv package\n\n* pathway.io.fs package\n\n* pathway.io.http package\n\n* pathway.io.jsonlines package\n\n* pathway.io.kafka package\n\n* pathway.io.redpanda package\n\n\n### Read only\n\n* pathway.io.debezium package\n\n* pathway.io.plaintext package\n\n* pathway.io.python package\n\n* pathway.io.s3_csv package\n\n* pathway.io.minio package\n\n\n### Write only\n\n* pathway.io.elasticsearch package\n\n* pathway.io.logstash package\n\n* pathway.io.null package\n\n* pathway.io.postgres package\n\n\n"}
{"doc": "This is the documentation for the pw.io.subscribe function in the Pathway framework. The function is used to subscribe to a specific table and receive notifications on every change that occurs in that table. The function takes in the table to subscribe to, a callback function to be called on every change, and an optional callback function to be called when the stream of changes ends. The function returns None.\nFunctions\n\n### pw.io.subscribe(table, on_change, on_end=<function <lambda>>)\nCalls a callback function on_change on every change happening in table.\n\n\n* Parameters\n\n    * table \u2013 the table to subscribe.\n\n    * on_change (`OnChangeCallback`) \u2013 the callback function to be called on every change in the table. The\n        function is required to accept three parameters: the row changed, the time\n        of the change in microseconds and the flag stating if the change had been an\n        addition of the row. These parameters of the callback are expected to have\n        names row, time and is_addition respectively.\n\n    * on_end (`Callable`\\[\\[\\], `Any`\\]) \u2013 the callback function to be called when the stream of changes ends.\n        It will be called on each engine worker separately.\n\n\n\n* Returns\n\n    None\n"}
{"doc": "The pw.io.debezium.read() function is a connector that takes a topic in the format of Debezium and maintains a corresponding table in Pathway, on which you can perform all the table operations. The function has several parameters, including `rdkafka_settings`, `topic_name`, `value_columns`, `primary_key`, `debug_data`, `autocommit_duration_ms`, `types`, `default_values`, and `persistent_id`. The function returns a table that can be read. An example is given for streaming a Postgres database table to the Pathway engine using the function.\npw.io.debezium.read(rdkafka_settings, topic_name, value_columns, primary_key=None, debug_data=None, autocommit_duration_ms=None, types=None, default_values=None, persistent_id=None)\nConnector, which takes a topic in the format of Debezium\nand maintains a corresponding table in Pathway, on which you can do all the\ntable operations provided. In order to do that, you will need a Debezium connector.\n\n\n* Parameters\n\n    * rdkafka_settings (`dict`) \u2013 Connection settings in the format of librdkafka.\n\n    * topic_name (`str`) \u2013 Name of topic in Kafka to which the updates are streamed.\n\n    * value_columns (`List`\\[`str`\\]) \u2013 Columns to extract for a table.\n\n    * primary_key (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated randomly.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nExample:\n\nConsider there is a need to stream a database table along with its changes directly into\nthe Pathway engine. One of the standard well-known solutions for table streaming is Debezium:\nit supports streaming data from MySQL, Postgres, MongoDB and a few more databases directly to a\ntopic in Kafka. The streaming first sends a snapshot of the data and then streams\nchanges for the specific change (namely: inserted, updated or removed) rows.\n\nConsider there is a table in Postgres, which is\ncreated according to the following schema:\n\n\n```sql\nCREATE TABLE pets (\n    id SERIAL PRIMARY KEY,\n    age INTEGER,\n    owner TEXT,\n    pet TEXT\n);\n```\nThis table, by default, will be streamed to the topic with the same name. In order to\nread it,you need to set the settings for `rdkafka`. For the sake of demonstration,\nlet\u2019s take those from the example of the Kafka connector:\n\n\n\n\n```python\n\nimport os\nrdkafka_settings = {\n```\n::\nResult\n```\n    \"bootstrap.servers\": \"localhost:9092\",\n    \"security.protocol\": \"sasl_ssl\",\n    \"sasl.mechanism\": \"SCRAM-SHA-256\",\n    \"group.id\": \"$GROUP_NAME\",\n    \"session.timeout.ms\": \"60000\",\n    \"sasl.username\": os.environ[\"KAFKA_USERNAME\"],\n    \"sasl.password\": os.environ[\"KAFKA_PASSWORD\"]\n}\n```\n::\n::\nNow, using the settings you can set up a connector. It is as simple as:\n\n\n\nt = pw.io.debezium.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_name=\"pets\",\n    value_columns=[\"age\", \"owner\", \"pet\"],\n    primary_key=\"id\",\n)\n```\n::\n::\nAs a result, upon its start, the connector would provide the full snapshot of the\ntable `pets` into the table `t` in Pathway. The table `t` can then be operated as\nusual. Throughout the run time, the rows in the table `pets` can change. In this\ncase, the changes in the result will be provided in the output connectors by the\nStream of Updates mechanism.\n"}
{"doc": "This documentation describes two functions within the Pathway framework. The first, `pw.debug.table_from_parquet`, reads a Parquet file and converts it into a pandas DataFrame, which is then converted into a Pathway table. The second function, `pw.debug.table_to_parquet`, converts a Pathway table into a pandas DataFrame and writes it to a Parquet file.\nFunctions\n\n### pw.debug.table_from_parquet(path, id_from=None, unsafe_trusted_ids=False)\nReads a Parquet file into a pandas DataFrame and then converts that into a Pathway table.\n\n\n### pw.debug.table_to_parquet(table, filename)\nConverts a Pathway Table into a pandas DataFrame and then writes it to Parquet\n"}
{"doc": "This is a documentation for the SortedIndex class in the pw.stdlib.indexing module of the Pathway framework. It lists the methods available for the class, including clear(), copy(), fromkeys(), get(), items(), keys(), pop(), popitem(), setdefault(), update(), and values(). Each method is briefly described and explains its purpose.\nclass  pw.stdlib.indexing.SortedIndex()\n\n\n### clear(None.  Remove all items from D.)\n\n### copy(a shallow copy of D)\n\n### fromkeys(value=None, /)\nCreate a new dictionary with keys from iterable and values set to value.\n\n\n### get(key, default=None, /)\nReturn the value for key if key is in the dictionary, else default.\n\n\n### items(a set-like object providing a view on D's items)\n\n### keys(a set-like object providing a view on D's keys)\n\n### pop(k, v, remove specified key and return the corresponding value.)\nIf the key is not found, return the default if given; otherwise,\nraise a KeyError.\n\n\n### popitem()\nRemove and return a (key, value) pair as a 2-tuple.\n\nPairs are returned in LIFO (last-in, first-out) order.\nRaises KeyError if the dict is empty.\n\n\n### setdefault(key, default=None, /)\nInsert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.\n\n\n### update(\\*\\*FNone.  Update D from dict/iterable E and F.)\nIf E is present and has a .keys() method, then does:  for k in E: D\\[k\\] = E\\[k\\]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D\\[k\\] = v\nIn either case, this is followed by: for k in F:  D\\[k\\] = F\\[k\\]\n\n\n### values(an object providing a view on D's values)\n\n"}
{"doc": "This is the documentation for the class SortedIndex in the pathway framework. It includes several methods such as clear(), copy(), fromkeys(), get(), items(), keys(), pop(), popitem(), setdefault(), update(), and values(). Each method is briefly described with its parameters and what it does.\nclass  pw.stdlib.indexing.sorting.SortedIndex()\n\n\n### clear(None.  Remove all items from D.)\n\n### copy(a shallow copy of D)\n\n### fromkeys(value=None, /)\nCreate a new dictionary with keys from iterable and values set to value.\n\n\n### get(key, default=None, /)\nReturn the value for key if key is in the dictionary, else default.\n\n\n### items(a set-like object providing a view on D's items)\n\n### keys(a set-like object providing a view on D's keys)\n\n### pop(k, v, remove specified key and return the corresponding value.)\nIf the key is not found, return the default if given; otherwise,\nraise a KeyError.\n\n\n### popitem()\nRemove and return a (key, value) pair as a 2-tuple.\n\nPairs are returned in LIFO (last-in, first-out) order.\nRaises KeyError if the dict is empty.\n\n\n### setdefault(key, default=None, /)\nInsert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.\n\n\n### update(\\*\\*FNone.  Update D from dict/iterable E and F.)\nIf E is present and has a .keys() method, then does:  for k in E: D\\[k\\] = E\\[k\\]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D\\[k\\] = v\nIn either case, this is followed by: for k in F:  D\\[k\\] = F\\[k\\]\n\n\n### values(an object providing a view on D's values)\n\n"}
{"doc": "The `retrieve_prev_next_values` function in the Pathway framework takes in an ordered table with three columns: value, prev, and next. It returns a new table with two columns: prev_value and next_value. The function retrieves, for each row, a pointer to the first row in the ordered_table that contains a non-\"None\" value based on the orders defined by the prev and next columns. If `value` is not provided, the function assumes the column name is \"value\".\npw.stdlib.indexing.retrieve_prev_next_values(ordered_table, value=None)\nRetrieve, for each row, a pointer to the first row in the ordered_table that          contains a non-\u201cNone\u201d value, based on the orders defined by the prev and next columns.\n\n\n* Parameters\n\n    * ordered_table (*pw.Table*) \u2013 Table with three columns: value, prev, next.\n        The prev and next columns contain pointers to other rows.\n\n    * value (*Optional\\[pw.ColumnReference\\]*) \u2013 Column reference pointing to the column containing values.\n        If not provided, assumes the column name is \u201cvalue\u201d.\n\n\n\n* Returns\n\n    *pw.Table* \u2013\n\n    Table with two columns: prev_value and next_value.\n\n        The prev_value column contains the values of the first row, according                   to the order defined by the column next, with a value different from None.\n        The next_value column contains the values of the first row, according                   to the order defined by the column prev, with a value different from None.\n\n\n\n"}
{"doc": "The `sort` function in the Pathway framework sorts a given table by the specified keys. It takes three parameters: the table to be sorted, the primary key to sort by (can be None), and the secondary key to sort by (can be None). The function returns a sorted table with two additional columns (`prev` and `next`) containing pointers to the previous and next rows. An example usage is also provided.\npw.stdlib.indexing.sort(table, key=None, instance=None)\nSorts a table by the specified keys.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 pw.Table\n        The table to be sorted.\n\n    * key (`Optional`\\[`ColumnReference`\\]) \u2013 ColumnReference or None\n        The name of the primary key to sort by. If None, the table is sorted\n        based on the key column as primary key.\n\n    * instance (`Optional`\\[`ColumnReference`\\]) \u2013 ColumnReference or None\n        The name of the secondary key to sort by. If None, the field \u201cinstance\u201d is chosen\n        if it exists, otherwise only the primary key is used.\n\n\n\n* Returns\n\n    *pw.Table* \u2013 The sorted table. Contains two columns: `prev` and `next`, containing the pointers\n    to the previous and next rows.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\nname     | age | score\nAlice    | 25  | 80\nBob      | 20  | 90\nCharlie  | 30  | 80\n''')\ntable = table.with_id_from(pw.this.name)\ntable += sort(table, key=pw.this.age)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\nname    | age | score | next        | prev\nAlice   | 25  | 80    | ^DS9AT95... | ^EDPSSB1...\nBob     | 20  | 90    | ^GBSDEEW... |\nCharlie | 30  | 80    |             | ^GBSDEEW...\n```\n::\n::"}
{"doc": "This documentation describes a function called \"retrieve_prev_next_values\" in the Pathway framework. It takes an ordered table with three columns (value, prev, next) and returns a new table with two columns (prev_value and next_value). The function finds the first row in the ordered table that contains a non-\"None\" value based on the orders defined by the prev and next columns. If a column reference pointing to the column containing values is not provided, the function assumes the column name is \"value\".\npw.stdlib.indexing.sorting.retrieve_prev_next_values(ordered_table, value=None)\nRetrieve, for each row, a pointer to the first row in the ordered_table that          contains a non-\u201cNone\u201d value, based on the orders defined by the prev and next columns.\n\n\n* Parameters\n\n    * ordered_table (*pw.Table*) \u2013 Table with three columns: value, prev, next.\n        The prev and next columns contain pointers to other rows.\n\n    * value (*Optional\\[pw.ColumnReference\\]*) \u2013 Column reference pointing to the column containing values.\n        If not provided, assumes the column name is \u201cvalue\u201d.\n\n\n\n* Returns\n\n    *pw.Table* \u2013\n\n    Table with two columns: prev_value and next_value.\n\n        The prev_value column contains the values of the first row, according                   to the order defined by the column next, with a value different from None.\n        The next_value column contains the values of the first row, according                   to the order defined by the column prev, with a value different from None.\n\n\n\n"}
{"doc": "This is documentation for the `sort()` function in the `pw.stdlib.indexing.sorting` module of the Pathway framework. The function is used to sort a `Table` object by specified keys. It takes three arguments: the table to be sorted, the primary key to sort by, and the secondary key to sort by. If no secondary key is specified, the field \"instance\" is chosen if it exists. The function returns the sorted table as a `pw.Table` object with two columns containing pointers to the previous and next rows. An example usage of the function is provided in the documentation.\npw.stdlib.indexing.sorting.sort(table, key=None, instance=None)\nSorts a table by the specified keys.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 pw.Table\n        The table to be sorted.\n\n    * key (`Optional`\\[`ColumnReference`\\]) \u2013 ColumnReference or None\n        The name of the primary key to sort by. If None, the table is sorted\n        based on the key column as primary key.\n\n    * instance (`Optional`\\[`ColumnReference`\\]) \u2013 ColumnReference or None\n        The name of the secondary key to sort by. If None, the field \u201cinstance\u201d is chosen\n        if it exists, otherwise only the primary key is used.\n\n\n\n* Returns\n\n    *pw.Table* \u2013 The sorted table. Contains two columns: `prev` and `next`, containing the pointers\n    to the previous and next rows.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\nname     | age | score\nAlice    | 25  | 80\nBob      | 20  | 90\nCharlie  | 30  | 80\n''')\ntable = table.with_id_from(pw.this.name)\ntable += sort(table, key=pw.this.age)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\nname    | age | score | next        | prev\nAlice   | 25  | 80    | ^DS9AT95... | ^EDPSSB1...\nBob     | 20  | 90    | ^GBSDEEW... |\nCharlie | 30  | 80    |             | ^GBSDEEW...\n```\n::\n::\n"}
{"doc": "The `extended_to_full_clustering` function in the Pathway framework takes a set of vertices and a partial clustering and creates an extended clustering where any vertices not already assigned a cluster are placed in singleton clusters. The function returns the new clustering with the ID of the singleton cluster set to the ID of the vertex.\nFunctions\n\n### pw.stdlib.graphs.utils.extended_to_full_clustering(vertices, clustering)\nThis function, given a set of vertices and a partial clustering,\ni.e., a clustering in which not eery vertex has assigned a cluster,\ncreates extended clustering in which those vertices are in singleton clusters.\n\nThe id of the new singleton cluster is the same as id of vertex\n"}
{"doc": "This documentation describes a function called \"extended_to_full_clustering\" in the \"clusters\" module of the \"pathway\" framework. The function takes two inputs: a set of vertices and a partial clustering (which means not every vertex has a cluster assigned). It then creates an extended clustering where the vertices are in singleton clusters. The ID of each new singleton cluster is the same as the ID of the corresponding vertex.\npathway.stdlib.graphs.utils.clusters module\n\n\n### pw.stdlib.graphs.utils.clusters.extended_to_full_clustering(vertices, clustering)\nThis function, given a set of vertices and a partial clustering,\ni.e., a clustering in which not eery vertex has assigned a cluster,\ncreates extended clustering in which those vertices are in singleton clusters.\n\nThe id of the new singleton cluster is the same as id of vertex\n"}
{"doc": "The documentation describes the function `pw.io.csv.write()` in the Pathway framework. This function writes a given table to a file in delimiter-separated values format. The function takes two parameters: `table` (which is the Table to be written) and `filename` (which is the path to the target output file). The function returns `None`. The example provided shows how to use the function to output a stream of changes of a table to a CSV file. The output file contains columns for the data, time, and diff.\npw.io.csv.write(table, filename)\nWrites table\u2019s stream of updates to a file in delimiter-separated values format.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 Table to be written.\n\n    * filename (`str`) \u2013 Path to the target output file.\n\n\n\n* Returns\n\n    None\n\n\nExample:\n\nIn this simple example you can see how table output works.\nFirst, import Pathway and create a table:\n\n\n```python\nimport pathway as pw\nt = pw.debug.parse_to_table(\"age owner pet \\n 1 10 Alice dog \\n 2 9 Bob cat \\n 3 8 Alice cat\")\n```\nConsider you would want to output the stream of changes of this table. In order to do that\nyou simply do:\n\n\n```python\npw.io.csv.write(t, \"table.csv\")\n```\nNow, let\u2019s see what you have on the output:\n\n\n```bash\ncat table.csv\n```\n\n```csv\nage,owner,pet,time,diff\n10,\"Alice\",\"dog\",0,1\n9,\"Bob\",\"cat\",0,1\n8,\"Alice\",\"cat\",0,1\n```\nThe first three columns clearly represent the data columns you have. The column time\nrepresents the number of operations minibatch, in which each of the rows was read. In\nthis example, since the data is static: you have 0. The diff is another\nelement of this stream of updates. In this context, it is 1 because all three rows were read from\nthe input. All in all, the extra information in `time` and `diff` columns - in this case -\nshows us that in the initial minibatch (`time = 0`), you have read three rows and all of\nthem were added to the collection (`diff = 1`).\n"}
{"doc": "The `pw.io.csv.read` function in Pathway Framework reads a table from one or several files with delimiter-separated values. It requires the `path` to the file or folder with files, `value_columns` which are names of the columns to be extracted from the files, and an optional `id_columns` parameter used to generate a primary key for the table. Other optional parameters include `csv_settings`, `mode`, `types`, `default_values`, `autocommit_duration_ms`, `persistent_id`, and `debug_data`. The function returns the table read. An example usage of the function is provided for reading a dataset stored in the filesystem in CSV format. The function can also handle logs rotation in real-time systems.\npw.io.csv.read(path, value_columns, id_columns=None, csv_settings=None, mode='streaming', types=None, default_values=None, autocommit_duration_ms=None, persistent_id=None, debug_data=None, \\*\\*kwargs)\nReads a table from one or several files with delimiter-separated values.\n\nIn case the folder is passed to the engine, the order in which files from\nthe directory are processed is determined according to the modification time of\nfiles within this folder: they will be processed by ascending order of\nthe modification time.\n\n\n* Parameters\n\n    * path (`str`) \u2013 Path to the file or to the folder with files.\n\n    * value_columns (`List`\\[`str`\\]) \u2013 Names of the columns to be extracted from the files.\n\n    * id_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to a subset of its columns, the set of columns should be specified in this field. Otherwise, the primary key will be generated randomly.\n\n    * csv_settings (`Optional`\\[`CsvParserSettings`\\]) \u2013 Settings for the CSV parser.\n\n    * mode (`str`) \u2013 If set to \u201cstreaming\u201d, the engine will wait for the new input files in the directory. Set it to \u201cstatic\u201d, it will only consider the available data and ingest all of it in one commit. Default value is \u201cstreaming\u201d.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nExample:\n\nConsider you want to read a dataset, stored in the filesystem in a standard CSV\nformat. The dataset contains data about pets and their owners.\n\nFor the sake of demonstration, you can prepare a small dataset by creating a CSV file\nvia a unix command line tool:\n\n\n```bash\nprintf \"id,owner,pet\\n1,Alice,dog\\n2,Bob,dog\\n3,Alice,cat\\n4,Bob,dog\" > dataset.csv\n```\nIn order to read it into Pathway\u2019s table, you can first do the import and then\nuse the pw.io.csv.read method:\n\n\n```python\nimport pathway as pw\nt = pw.io.csv.read(\"dataset.csv\", [\"owner\", \"pet\"], mode=\"static\")\n```\nThen, you can output the table in order to check the correctness of the read:\n\n\n\nCode\n```python\npw.debug.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nowner pet\nAlice dog\n  Bob dog\nAlice cat\n  Bob dog\n```\n::\n::\nNow let\u2019s try something different. Consider you have site access logs stored in a\nseparate folder in several files. For the sake of simplicity, a log entry contains\nan access ID, an IP address and the login of the user.\n\nA dataset, corresponding to the format described above can be generated, thanks to the\nfollowing set of unix commands:\n\n\n```bash\nmkdir logs\nprintf \"id,ip,login\\n1,127.0.0.1,alice\\n2,8.8.8.8,alice\" > logs/part_1.csv\nprintf \"id,ip,login\\n3,8.8.8.8,bob\\n4,127.0.0.1,alice\" > logs/part_2.csv\n```\nNow, let\u2019s see how you can use the connector in order to read the content of this\ndirectory into a table:\n\n\n```python\nt = pw.io.csv.read(\"logs/\", [\"ip\", \"login\"], mode=\"static\")\n```\nThe only difference is that you specified the name of the directory instead of the\nfile name, as opposed to what you had done in the previous example. It\u2019s that simple!\n\nBut what if you are working with a real-time system, which generates logs all the time.\nThe logs are being written and after a while they get into the log directory (this is\nalso called \u201clogs rotation\u201d). Now, consider that there is a need to fetch the new files\nfrom this logs directory all the time. Would Pathway handle that? Sure!\n\nThe only difference would be in the usage of mode flag. So the code\nsnippet will look as follows:\n\n\n```python\nt = pw.io.csv.read(\"logs/\", [\"ip\", \"login\"], mode=\"streaming\")\n```\nWith this method, you obtain a table updated dynamically. The changes in the logs would incur\nchanges in the Business-Intelligence \u2018BI\u2019-ready data, namely, in the tables you would like to output. To see\nhow these changes are reported by Pathway, have a look at the\n\u201cStreams of Updates and Snapshots\u201d\narticle.\n\n"}
{"doc": "The documentation describes the `pw.io.logstash.write()` function in the Pathway Framework. This function sends a stream of updates from a specified table to the HTTP input of Logstash in the format of flat JSON objects. It takes in parameters such as the table to be tracked, the Logstash endpoint, the number of retries, the retry policy, and the connection and request timeouts. The documentation provides an example of how to use this function to send updates to a locally installed Logstash.\nFunctions\n\n### pw.io.logstash.write(table, endpoint, n_retries=0, retry_policy=<pathway.io.http._common.RetryPolicy object>, connect_timeout_ms=None, request_timeout_ms=None)\nSends the stream of updates from the table to HTTP input <https://www.elastic.co/guide/en/logstash/current/plugins-inputs-http.html>\nof Logstash. The data is sent in the format of flat JSON objects, with two extra\nfields for time and diff.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 table to be tracked;\n\n    * endpoint (`str`) \u2013 Logstash endpoint, accepting entries;\n\n    * n_retries (`int`) \u2013 number of retries in case of failure;\n\n    * retry_policy (`RetryPolicy`) \u2013 policy of delays or backoffs for the retries;\n\n    * connect_timeout_ms (`Optional`\\[`int`\\]) \u2013 connection timeout, specified in milliseconds. In case it\u2019s None, no restrictions on connection duration will be applied;\n\n    * request_timeout_ms (`Optional`\\[`int`\\]) \u2013 request timeout, specified in milliseconds. In case it\u2019s None, no restrictions on request duration will be applied.\n\n\nExample:\n\nSuppose that we need to send the stream of updates to locally installed Logstash.\nFor example, you can use docker-elk <https://github.com/deviantony/docker-elk>\nrepository in order to get the ELK stack up and running at your local machine in a\nfew minutes.\n\nIf Logstash stack is installed, you need to configure the input pipeline. The\nsimplest possible way to do this, is to add the following lines in the input plugins\nlist:\n\n\n```text\nhttp {\n    port => 8012\n}\n```\nThe port is specified for the sake of example and can be changed. Further, we will\nuse 8012 for clarity.\n\nNow, with the pipeline configured, you can stream the changed into Logstash as\nsimple as:\n\n\n```python\npw.io.logstash.write(table, \"http://localhost:8012\")\n```\n"}
{"doc": "The `pw.io.kafka.write()` function in the Pathway framework writes a given `Table` to a topic on a Kafka instance. It takes in the table, connection settings in the format of librdkafka, topic name, format of input data (currently only \"json\" and \"dsv\" are supported), and the field delimiter to be used in case of delimiter-separated values format. It returns nothing. One limitation is that only JSON format is available for now. The documentation provides an example of how to set up a queue with similar parameters and how to use the connector to send messages to the Kafka instance in JSON format.\npw.io.kafka.write(table, rdkafka_settings, topic_name, \\*, format='json', delimiter=',', \\*\\*kwargs)\nWrite a table to a given topic on a Kafka instance.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 the table to output.\n\n    * rdkafka_settings (`dict`) \u2013 Connection settings in the format of librdkafka.\n\n\n    * topic_name (`str`) \u2013 name of topic in Kafka to which the data should be sent.\n\n    * format (`str`) \u2013 format of the input data, currently \u201cjson\u201d and \u201cdsv\u201d are supported.\n\n    * delimiter (`str`) \u2013 field delimiter to be used in case of delimiter-separated values format.\n\n\n\n* Returns\n\n    None\n\n\nLimitations:\n\nFor future proofing, the format is configurable, but (for now) only JSON is available.\n\nExample:\n\nConsider there is a queue in Kafka, running locally on port 9092. Our queue can\nuse SASL-SSL authentication over a SCRAM-SHA-256 mechanism. You can set up a queue\nwith similar parameters in Upstash. Settings for rdkafka\nwill look as follows:\n\n\n\nCode\n```python\nimport os\nrdkafka_settings = {\n```\n::\nResult\n```\n    \"bootstrap.servers\": \"localhost:9092\",\n    \"security.protocol\": \"sasl_ssl\",\n    \"sasl.mechanism\": \"SCRAM-SHA-256\",\n    \"sasl.username\": os.environ[\"KAFKA_USERNAME\"],\n    \"sasl.password\": os.environ[\"KAFKA_PASSWORD\"]\n}\n```\n::\n::\nYou want to send a Pathway table t to the Kafka instance.\nTo connect to the topic \u201canimals\u201d and send messages, the connector must be used         as follows, depending on the format:\n\nJSON version:\n\n\n\nCode\n```python\nimport pathway as pw\nt = pw.io.kafka.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    \"animals\",\n    format=\"json\",\n)\n```\n::\n::\nAll the updates of table t will be sent to the Kafka instance.\n"}
{"doc": "The documentation describes a function `pw.io.kafka.read` in the Pathway framework that allows reading data from a set of topics in Kafka. It supports three formats: raw, csv, and json. The function takes various parameters such as connection settings, topic names, format, value columns, primary key, autocommit duration, and more. It returns a table that has been read from Kafka. An example is also provided for using the function with the raw version.\npw.io.kafka.read(rdkafka_settings, topic_names, format='raw', value_columns=None, primary_key=None, types=None, default_values=None, debug_data=None, autocommit_duration_ms=None, json_field_paths=None, parallel_readers=None, persistent_id=None)\nReads table from a set of topics in Kafka.\nThere are three formats currently supported: \u201craw\u201d, \u201ccsv\u201d, and \u201cjson\u201d.\n\n\n* Parameters\n\n    * rdkafka_settings (`dict`) \u2013 Connection settings in the format of librdkafka.\n\n    * topic_names (`List`\\[`str`\\]) \u2013 Names of topics in Kafka from which the data should be read.\n\n    * format \u2013 format of the input data, \u201craw\u201d, \u201ccsv\u201d, or \u201cjson\u201d\n\n    * value_columns (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 Columns to extract for a table, required for format other than             \u201craw\u201d.\n\n    * primary_key (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated randomly.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * json_field_paths (`Optional`\\[`Dict`\\[`str`, `str`\\]\\]) \u2013 If the format is JSON, this field allows to map field names\n        into path in the field. For the field which require such mapping, it should be\n        given in the format `<field_name>: <path to be mapped>`, where the path to\n        be mapped needs to be a JSON Pointer (RFC 6901).\n\n    * parallel_readers (`Optional`\\[`int`\\]) \u2013 number of copies of the reader to work in parallel. In case\n        the number is not specified, min{pathway_threads, total number of partitions}\n        will be taken. This number also can\u2019t be greater than the number of Pathway\n        engine threads, and will be reduced to the number of engine threads, if it\n        exceeds.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nWhen using the format \u201craw\u201d, the connector will produce a single-column table:\nall the data is saved into a column named `data`.\nFor other formats, the argument value_column is required and defines the columns.\n\nExample:\n\nConsider there is a queue in Kafka, running locally on port 9092. Our queue can\nuse SASL-SSL authentication over a SCRAM-SHA-256 mechanism. You can set up a queue\nwith similar parameters in Upstash. Settings for rdkafka\nwill look as follows:\n\n\n\n\n```python\nimport \nos\nrdkafka_settings = {\n```\n::\nResult\n```\n    \"bootstrap.servers\": \"localhost:9092\",\n    \"security.protocol\": \"sasl_ssl\",\n    \"sasl.mechanism\": \"SCRAM-SHA-256\",\n    \"group.id\": \"$GROUP_NAME\",\n    \"session.timeout.ms\": \"60000\",\n    \"sasl.username\": os.environ[\"KAFKA_USERNAME\"],\n    \"sasl.password\": os.environ[\"KAFKA_PASSWORD\"]\n}\n```\n::\n::\nTo connect to the topic \u201canimals\u201d and accept messages, the connector must be used         as follows, depending on the format:\n\nRaw version:\n\n\n\npathway as pw\nt = pw.io.kafka.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"raw\",\n)\n```\n::\n::\nAll the data will be accessible in the column data.\n\nCSV version:\n\n\n\npathway as pw\nt = pw.io.kafka.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"csv\",\n    value_columns=[\"owner\", \"pet\"],\n)\n```\n::\n::\nIn case of CSV format, the first message must be the header:\n\n\n```csv\nowner,pet\n```\nThen, simple data rows are expected. For example:\n\n\n```csv\nAlice,cat\nBob,dog\n```\nThis way, you get a table which looks as follows:\n\n\n\ng.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nowner pet\nAlice cat\n  Bob dog\n```\n::\n::\nJSON version:\n\n\n\npathway as pw\nt = pw.io.kafka.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"json\",\n    value_columns=[\"owner\", \"pet\"],\n)\n```\n::\n::\nFor the JSON connector, you can send these two messages:\n\n\n```json\n{\"owner\": \"Alice\", \"pet\": \"cat\"}\n{\"owner\": \"Bob\", \"pet\": \"dog\"}\n```\nThis way, you get a table which looks as follows:\n\n\n\ng.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nowner pet\nAlice cat\n  Bob dog\n```\n::\n::\nNow consider that the data about pets come in a more sophisticated way. For instance\nyou have an owner, kind and name of an animal, along with some physical measurements.\n\nThe JSON payload in this case may look as follows:\n\n\n```json\n{\n    \"name\": \"Jack\",\n    \"pet\": {\n        \"animal\": \"cat\",\n        \"name\": \"Bob\",\n        \"measurements\": [100, 200, 300]\n    }\n}\n```\nSuppose you need to extract a name of the pet and the height, which is the 2nd\n(1-based) or the 1st (0-based) element in the array of measurements. Then, you\nuse JSON Pointer and do a connector, which gets the data as follows:\n\n\n\npathway as pw\nt = pw.io.kafka.read(\n```\n::\nResult\n```\n    rdkafka_settings,\n    topic_names=[\"animals\"],\n    format=\"json\",\n    value_columns=[\"pet_name\", \"pet_height\"],\n    column_paths={\n        \"pet_name\": \"/pet/name\",\n        \"pet_height\": \"/pet/measurements/1\"\n    },\n)\n```\n::\n::\n"}
{"doc": "This piece of documentation explains how to use the `reducers` module in the Pathway framework to compute aggregated results obtained by a `groupby`. It provides an example of how to use the `my_reducer` function to calculate an aggregated result based on values in a specific column (`columnB`) of a table (`my_table`). The example code demonstrates how to apply this reducer to a `groupby` operation on `columnA` of the table `my_table`. It also provides a sample table `t` with two columns `colA` and `colB`, showing how the `groupby` and `reduce` functions can be used together to generate an aggregated result.\nUsage\nReducers are used in `reduce` to compute the aggregated results obtained by a `groupby`:\n\n\n```python\nmy_table.groupby(table.columnA).reduce(aggregated_result=pw.reducers.my_reducer(my_table.columnB))\n```\n\nWe use the following table `t` in the examples:\n\n        colA  colB\n    1   valA   -1\n    2   valA    1\n    3   valA    2\n"}
{"doc": "This documentation describes the subpackages and submodules in the pathway framework related to graphs. Specifically, it includes packages for implementing Bellman-Ford algorithm, Louvain communities, PageRank algorithm, and utility functions for clustering.\nSubpackages\n\n* pathway.stdlib.graphs.bellman_ford package\n\n    * Submodules\n\n    * pathway.stdlib.graphs.bellman_ford.impl module\n\n* pathway.stdlib.graphs.louvain_communities package\n\n    * Submodules\n\n    * pathway.stdlib.graphs.louvain_communities.impl module\n\n* pathway.stdlib.graphs.pagerank package\n\n    * Submodules\n\n    * pathway.stdlib.graphs.pagerank.impl module\n\n* pathway.stdlib.graphs.utils package\n\n    * Submodules\n\n    * pathway.stdlib.graphs.utils.clusters module\n\n"}
{"doc": "This is documentation for the `pw.io.plaintext.read()` function in the Pathway framework. It reads a table from a text file or a directory of text files and returns a `Table` object with a single column `data`. The function has multiple parameters such as `path`, `mode`, `persistent_id`, and `autocommit_duration_ms` which are explained in detail. An example usage is provided as well.\npw.io.plaintext.read(path, mode='streaming', persistent_id=None, autocommit_duration_ms=None, debug_data=None)\nReads a table from a text file or a directory of text files. The resulting table\nwill consist of a single column `data`, and have the number of rows equal to the number\nof lines in the file. Each cell will contain a single line from the file.\n\nIn case the folder is specified, and there are several files placed in the folder,\ntheir order is determined according to their modification times: the smaller the\nmodification time is, the earlier the file will be passed to the engine.\n\n\n* Parameters\n\n    * path (`str`) \u2013 Path to a file or to a folder.\n\n    * mode (`str`) \u2013 If set to \u201cstreaming\u201d, the engine will wait for the new input files in the directory. Set it to \u201cstatic\u201d, it will only consider the available data and ingest all of it in one commit. Default value is \u201cstreaming\u201d.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nExample:\n\n\n```python\nimport pathway as pw\nt = pw.io.plaintext.read(\"raw_dataset/lines.txt\")\n```\n"}
{"doc": "This documentation is describing a class called AsofJoinResult from the pw.stdlib.temporal module in the Pathway framework. This class is the result of an ASOF (As-Of) join of two tables, and it takes in parameters such as side_data, mode, defaults, and direction. An example is shown using the class to perform an ASOF join between two tables and selecting certain columns. The resulting table is printed as output.\nclass  pw.stdlib.temporal.AsofJoinResult(side_data, mode, defaults, direction)\n\nResult of an ASOF join of two tables\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\n\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\n\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    how=pw.JoinMode.LEFT,\n    defaults={t2.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 1  | 1        | -1        | 0\n0         | 4  | 2        | 6         | 8\n0         | 5  | 3        | 6         | 9\n0         | 6  | 4        | 6         | 10\n0         | 7  | 5        | 6         | 11\n0         | 11 | 6        | 9         | 15\n0         | 12 | 7        | 9         | 16\n1         | 5  | 8        | 7         | 15\n1         | 7  | 9        | 7         | 16\n```\n::\n::\n\n"}
{"doc": "The documentation describes the `IntervalJoinResult` class in the Pathway framework, which represents the result of an interval join between tables. It also provides an example of how to use the class and its `select()` method to create a table.\nclass  pw.stdlib.temporal.IntervalJoinResult(left_bucketed, right_bucketed, earlier_part_filtered, later_part_filtered, table_substitution, mode)\n\nResult of an interval join between tables.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\njoin_result = t1.interval_join_inner(t2, t1.t, t2.t, pw.temporal.interval(-2, 1))\nisinstance(join_result, pw.temporal.IntervalJoinResult)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n\nCode\n```python\npw.debug.compute_and_print(\n    join_result.select(left_t=t1.t, right_t=t2.t), include_id=False\n)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n\n### select(\\*args, \\*\\*kwargs)\nComputes a result of an interval join.\n\n\n* Parameters\n\n    * args (`ColumnReference`) \u2013 Column references.\n\n    * kwargs (`Any`) \u2013 Column expressions with their new assigned names.\n\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_inner(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n```\n::\n::\n\n"}
{"doc": "This documentation describes a function named \"check_joint_types\" in the \"pathway.stdlib.temporal.utils\" module of the Pathway framework. The function can be used to check whether all the parameters passed to a function have types that are compatible with the function. The documentation also provides an example of the types that are allowed for the parameters.\npathway.stdlib.temporal.utils module\n\n\n### pw.stdlib.temporal.utils.check_joint_types(parameters)\nChecks if all parameters have types that allow to execute a function.\nIf parameters are {\u2018a\u2019: (a, TimeEventType), \u2018b\u2019: (b, IntervalType)} then\nthe following pairs of types are allowed for (a, b): (int, int), (float, float),\n(datetime.datetime, datetime.timedelta)\n"}
{"doc": "This is a Python class in the Pathway framework called `WindowJoinResult` which represents the result of a window join between two tables. It contains information about the join, including the original and new versions of both tables. The documentation provides an example of using this class to perform a window join between two tables, and demonstrates how to work with the resulting `WindowJoinResult`.\nclass  pw.stdlib.temporal.WindowJoinResult(join_result, left_original, right_original, left_new, right_new)\n\nResult of a window join between tables.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\njoin_result = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.tumbling(2))\nisinstance(join_result, pw.temporal.WindowJoinResult)\n```\n::\nResult\n```\nTrue\n```\n::\n::\n\nCode\n```python\npw.debug.compute_and_print(\n    join_result.select(left_t=t1.t, right_t=t2.t), include_id=False\n)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n1      |\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n13     |\n```\n::\n::\n"}
{"doc": "The `select()` function is a method in the Pathway framework used after a window join operation. It computes the result of the join by selecting specific columns from the joined table. The function takes in `args` and `kwargs` parameters, where `args` are column references and `kwargs` are column expressions with their new assigned names. The function returns a created table that contains the selected columns. The documentation provides an example of how to use the function with sample input and output.\nselect(\\*args, \\*\\*kwargs)\nComputes a result of a window join.\n:type args: `ColumnReference`\n:param args: Column references.\n:type kwargs: `Any`\n:param kwargs: Column expressions with their new assigned names.\n\n\n* Returns\n\n    *Table* \u2013 Created table.\n\n\nExample:\n>>> import pathway as pw\n>>> t1 = pw.debug.table_from_markdown(\n\u2026     \u2018\u2019\u2019\n\u2026     | a | t\n\u2026   1 | 1 | 1\n\u2026   2 | 1 | 2\n\u2026   3 | 1 | 3\n\u2026   4 | 1 | 7\n\u2026   5 | 1 | 13\n\u2026   6 | 2 | 1\n\u2026   7 | 2 | 2\n\u2026   8 | 3 | 4\n\u2026 \u2018\u2019\u2019\n\u2026 )\n>>> t2 = pw.debug.table_from_markdown(\n\u2026     \u2018\u2019\u2019\n\u2026     | b | t\n\u2026   1 | 1 | 2\n\u2026   2 | 1 | 5\n\u2026   3 | 1 | 6\n\u2026   4 | 1 | 7\n\u2026   5 | 2 | 2\n\u2026   6 | 2 | 3\n\u2026   7 | 4 | 3\n\u2026 \u2018\u2019\u2019\n\u2026 )\n>>> t3 = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n\u2026     key=pw.coalesce(t1.a, t2.b), left_t=t1.t, right_t=t2.t\n\u2026 )\n>>> pw.debug.compute_and_print(t3, include_id=False)\nkey | left_t | right_t\n1   |        | 5\n1   | 1      |\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n1   | 13     |\n2   | 1      |\n2   | 2      | 2\n2   | 2      | 3\n3   | 4      |\n4   |        | 3\n\n\n"}
{"doc": "The `pw.stdlib.temporal.interval(lower_bound, upper_bound)` function in Pathway allows testing whether two times are within a certain distance. It takes in two parameters, `lower_bound` and `upper_bound`, as the lower and upper bounds on the difference between two times. It returns a `Window` object to pass as an argument to `.interval_join()`. This function is usually used as an argument of `.interval_join()`. An example usage of this function is provided in the documentation.\npw.stdlib.temporal.interval(lower_bound, upper_bound)\nAllows testing whether two times are within a certain distance.\n\nNOTE: Usually used as an argument of .interval_join().\n\n\n* Parameters\n\n    * lower_bound (`Union`\\[`int`, `float`, `timedelta`\\]) \u2013 a lower bound on other_time - self_time.\n\n    * upper_bound (`Union`\\[`int`, `float`, `timedelta`\\]) \u2013 an upper bound on other_time - self_time.\n\n\n\n* Returns\n\n    *Window* \u2013 object to pass as an argument to .interval_join()\n\n\nExamples:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n"}
{"doc": "The `pw.stdlib.temporal.session()` function is used to group together adjacent elements within a window based on a maximum time difference or a custom predicate, for ordered time-like data columns. It returns a Window object to pass as an argument to `.windowby()`. The function takes in two optional parameters: `predicate` and `max_gap`, where at least one of them must be provided. The `predicate` parameter takes a function that returns a boolean indicating whether to group two adjacent entries or not, and the `max_gap` parameter specifies the maximum time difference for grouping two adjacent entries. The function has an example provided, showing how it can be used with `.windowby()` to reduce a table.\npw.stdlib.temporal.session(\\*, predicate=None, max_gap=None)\nAllows grouping together elements within a window across ordered time-like\ndata column by locally grouping adjacent elements either based on a maximum time\ndifference or using a custom predicate.\n\nNOTE: Usually used as an argument of .windowby().\nExactly one of the arguments predicate or max_gap should be provided.\n\n\n* Parameters\n\n    * predicate (`Optional`\\[`Callable`\\[\\[`Any`, `Any`\\], `bool`\\]\\]) \u2013 function taking two adjacent entries that returns a boolean saying\n        whether the two entries should be grouped\n\n    * max_gap (`Union`\\[`int`, `float`, `timedelta`, `None`\\]) \u2013 Two adjacent entries will be grouped if b - a < max_gap\n\n\n\n* Returns\n\n    *Window* \u2013 object to pass as an argument to .windowby()\n\n\nExamples:\n>>> import pathway as pw\n>>> t = pw.debug.table_from_markdown(\n\u2026 \u2018\u2019\u2019\n\u2026     | shard |  t |  v\n\u2026 1   | 0     |  1 |  10\n\u2026 2   | 0     |  2 |  1\n\u2026 3   | 0     |  4 |  3\n\u2026 4   | 0     |  8 |  2\n\u2026 5   | 0     |  9 |  4\n\u2026 6   | 0     |  10|  8\n\u2026 7   | 1     |  1 |  9\n\u2026 8   | 1     |  2 |  16\n\u2026 \u2018\u2019\u2019)\n>>> result = t.windowby(\n\u2026     t.t, window=pw.temporal.session(predicate=lambda a, b: abs(a-b) <= 1), shard=t.shard\n\u2026 ).reduce(\n\u2026 pw.this._pw_shard,\n\u2026 pw.this._pw_window_start,\n\u2026 pw.this._pw_window_end,\n\u2026 min_t=pw.reducers.min(pw.this.t),\n\u2026 max_v=pw.reducers.max(pw.this.v),\n\u2026 count=pw.reducers.count(pw.this.t),\n\u2026 )\n>>> pw.debug.compute_and_print(result, include_id=False)\n_pw_shard | _pw_window_start | _pw_window_end | min_t | max_v | count\n0         | 1                | 2              | 1     | 10    | 2\n0         | 4                | 4              | 4     | 3     | 1\n0         | 8                | 10             | 8     | 8     | 3\n1         | 1                | 2              | 1     | 16    | 2\n\n"}
{"doc": "This is a documentation for the `tumbling` function in the `pw.stdlib.temporal` module of the Pathway framework. The function is used to group together elements within a window of a given length, tumbling across ordered time-like data column starting from a given offset. It takes two parameters, `duration` and `offset`, and returns a `Window` object that can be passed as an argument to the `windowby()` method. The documentation also includes an example of how to use the function with the `windowby()` method to reduce a table.\npw.stdlib.temporal.tumbling(duration, offset=None)\nAllows grouping together elements within a window of a given length tumbling\nacross ordered time-like data column starting from a given offset.\n\nNOTE: Usually used as an argument of .windowby().\n\n\n* Parameters\n\n    * duration (`Union`\\[`int`, `float`, `timedelta`\\]) \u2013 length of the window\n\n    * offset (`Union`\\[`int`, `float`, `datetime`, `None`\\]) \u2013 beginning of the first window\n\n\n\n* Returns\n\n    *Window* \u2013 object to pass as an argument to .windowby()\n\n\nExamples:\n>>> import pathway as pw\n>>> t = pw.debug.table_from_markdown(\n\u2026 \u2018\u2019\u2019\n\u2026        | shard | t\n\u2026    1   | 0     |  12\n\u2026    2   | 0     |  13\n\u2026    3   | 0     |  14\n\u2026    4   | 0     |  15\n\u2026    5   | 0     |  16\n\u2026    6   | 0     |  17\n\u2026    7   | 1     |  12\n\u2026    8   | 1     |  13\n\u2026 \u2018\u2019\u2019)\n>>> result = t.windowby(\n\u2026     t.t, window=pw.temporal.tumbling(duration=5), shard=t.shard\n\u2026 ).reduce(\n\u2026   pw.this._pw_shard,\n\u2026   pw.this._pw_window_start,\n\u2026   pw.this._pw_window_end,\n\u2026   min_t=pw.reducers.min(pw.this.t),\n\u2026   max_t=pw.reducers.max(pw.this.t),\n\u2026   count=pw.reducers.count(pw.this.t),\n\u2026 )\n>>> pw.debug.compute_and_print(result, include_id=False)\n_pw_shard | _pw_window_start | _pw_window_end | min_t | max_t | count\n0         | 10               | 15             | 12    | 14    | 3\n0         | 15               | 20             | 15    | 17    | 3\n1         | 10               | 15             | 12    | 13    | 2\n\n"}
{"doc": "The `windowby` function allows you to create a grouped table by windowing the original table based on a specified time expression and window type. The function has parameters for `time_expr` (a column expression used for windowing), `window` (the type of window to use), and an optional `shard` parameter that can be used as a shard key. The example provided demonstrates how to use `windowby` to create a grouped table and reduce the results.\npw.stdlib.temporal.windowby(self, time_expr, \\*, window, shard=None)\nCreate a GroupedTable by windowing the table (based on expr and window),\noptionally sharded with shard\n\n\n* Parameters\n\n    * time_expr (`ColumnExpression`) \u2013 Column expression used for windowing\n\n    * window (`Window`) \u2013 type window to use\n\n    * shard (`Optional`\\[`ColumnExpression`\\]) \u2013 optional column expression to act as a shard key\n\n\nExamples:\n\n\n\nCode\n```python\nimport pathway as pw\nt = pw.debug.table_from_markdown(\n'''\n    | shard |  t |  v\n1   | 0     |  1 |  10\n2   | 0     |  2 |  1\n3   | 0     |  4 |  3\n4   | 0     |  8 |  2\n5   | 0     |  9 |  4\n6   | 0     |  10|  8\n7   | 1     |  1 |  9\n8   | 1     |  2 |  16\n''')\nresult = t.windowby(\n    t.t, window=pw.temporal.session(predicate=lambda a, b: abs(a-b) <= 1), shard=t.shard\n).reduce(\npw.this.shard,\nmin_t=pw.reducers.min(pw.this.t),\nmax_v=pw.reducers.max(pw.this.v),\ncount=pw.reducers.count(pw.this.t),\n)\npw.debug.compute_and_print(result, include_id=False)\n```\n::\nResult\n```\nshard | min_t | max_v | count\n0     | 1     | 10    | 2\n0     | 4     | 3     | 1\n0     | 8     | 8     | 3\n1     | 1     | 16    | 2\n```\n::\n::"}
{"doc": "The `asof_join` function is used to perform an ASOF (As Of) join of two tables. It takes in two tables, self_time and other_time column expressions for the join, a list of columns to join on, a join mode, and a dictionary of default values for entries that do not have a predecessor in the join. The function returns a joined table that can be further manipulated using the `select` function. An example is provided to demonstrate the usage of the function.\npw.stdlib.temporal.asof_join(self, other, self_time, other_time, \\*on, how, defaults={}, direction=Direction.BACKWARD)\nPerform an ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * how (`JoinMode`) \u2013 mode of the join (LEFT, RIGHT, FULL)\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    how=pw.JoinMode.LEFT,\n    defaults={t2.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 1  | 1        | -1        | 0\n0         | 4  | 2        | 6         | 8\n0         | 5  | 3        | 6         | 9\n0         | 6  | 4        | 6         | 10\n0         | 7  | 5        | 6         | 11\n0         | 11 | 6        | 9         | 15\n0         | 12 | 7        | 9         | 16\n1         | 5  | 8        | 7         | 15\n1         | 7  | 9        | 7         | 16\n```\n::\n::\n"}
{"doc": "The `asof_join_left` function in Pathway framework performs a left ASOF join of two tables. It takes as input two tables, `self` and `other`, both containing a column `val`, and two time-like column expressions `self_time` and `other_time` to do the join against. A list of column expressions `on` can also be provided as a parameter. The function returns a resulting table with columns `shard_key`, `t`, `val_left`, `val_right`, and `sum`. The `defaults` parameter can be used to provide a dictionary column->default value, and `direction` specifies the direction of the join. An example showing the input and output of the function is also provided.\npw.stdlib.temporal.asof_join_left(self, other, self_time, other_time, \\*on, defaults={}, direction=Direction.BACKWARD)\nPerform a left ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n    * direction (`Direction`) \u2013 direction of the join, accepted values: Direction.BACKWARD,\n        Direction.FORWARD, Direction.NEAREST\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join_left(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    defaults={t2.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 1  | 1        | -1        | 0\n0         | 4  | 2        | 6         | 8\n0         | 5  | 3        | 6         | 9\n0         | 6  | 4        | 6         | 10\n0         | 7  | 5        | 6         | 11\n0         | 11 | 6        | 9         | 15\n0         | 12 | 7        | 9         | 16\n1         | 5  | 8        | 7         | 15\n1         | 7  | 9        | 7         | 16\n```\n::\n::\n"}
{"doc": "The `asof_join_outer` function in the pathway framework can perform an outer asof join of two tables. It takes in two tables, a time-like column expression for each table, a list of column expressions, a dictionary of column references to default values, and a direction for the join. The function returns a table that has columns from both input tables, joined based on the time-like columns and the list of column expressions. The resulting table may have rows with default values if there is no matching predecessor in the join. An example usage of the function is also provided.\npw.stdlib.temporal.asof_join_outer(self, other, self_time, other_time, \\*on, defaults={}, direction=Direction.BACKWARD)\nPerform an outer ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n    * direction (`Direction`) \u2013 direction of the join, accepted values: Direction.BACKWARD,\n        Direction.FORWARD, Direction.NEAREST\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join_outer(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    defaults={t1.val: -1, t2.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 1  | 1        | -1        | 0\n0         | 2  | 1        | 0         | 1\n0         | 3  | 1        | 6         | 7\n0         | 4  | 2        | 6         | 8\n0         | 5  | 3        | 6         | 9\n0         | 6  | 4        | 6         | 10\n0         | 7  | 5        | 2         | 7\n0         | 7  | 5        | 6         | 11\n0         | 8  | 5        | 3         | 8\n0         | 9  | 5        | 9         | 14\n0         | 11 | 6        | 9         | 15\n0         | 12 | 7        | 9         | 16\n0         | 13 | 7        | 7         | 14\n0         | 14 | 7        | 4         | 11\n1         | 2  | -1       | 7         | 6\n1         | 5  | 8        | 7         | 15\n1         | 7  | 9        | 7         | 16\n1         | 8  | 9        | 3         | 12\n```\n::\n::\n"}
{"doc": "The `asof_join_right` function performs a right ASOF (as of) join of two tables based on their time-like column expressions to join against. The function accepts parameters such as the other table to join with, the time-like column expressions to do the join against, a list of column expressions to join on, default values for entries in the resulting table that do not have a predecessor in the join, and direction of the join. The given example demonstrates how to use the function to join two tables and select specific columns from the resulting table.\npw.stdlib.temporal.asof_join_right(self, other, self_time, other_time, \\*on, defaults={}, direction=Direction.BACKWARD)\nPerform a right ASOF join of two tables.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 Table to join with self, both must contain a column val\n\n    * self_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * other_time (`ColumnExpression`) \u2013 time-like column expression to do the join against\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level operation\n        and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * defaults (`Dict`\\[`ColumnReference`, `Any`\\]) \u2013 dictionary column-> default value. Entries in the resulting table that\n        not have a predecessor in the join will be set to this default value. If no\n        default is provided, None will be used.\n\n    * direction (`Direction`) \u2013 direction of the join, accepted values: Direction.BACKWARD,\n        Direction.FORWARD, Direction.NEAREST\n\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n        | K | val |  t\n    1   | 0 | 1   |  1\n    2   | 0 | 2   |  4\n    3   | 0 | 3   |  5\n    4   | 0 | 4   |  6\n    5   | 0 | 5   |  7\n    6   | 0 | 6   |  11\n    7   | 0 | 7   |  12\n    8   | 1 | 8   |  5\n    9   | 1 | 9   |  7\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n         | K | val | t\n    21   | 1 | 7  | 2\n    22   | 1 | 3  | 8\n    23   | 0 | 0  | 2\n    24   | 0 | 6  | 3\n    25   | 0 | 2  | 7\n    26   | 0 | 3  | 8\n    27   | 0 | 9  | 9\n    28   | 0 | 7  | 13\n    29   | 0 | 4  | 14\n    '''\n)\nres = t1.asof_join_right(\n    t2,\n    t1.t,\n    t2.t,\n    t1.K == t2.K,\n    defaults={t1.val: -1},\n).select(\n    pw.this.shard_key,\n    pw.this.t,\n    val_left=t1.val,\n    val_right=t2.val,\n    sum=t1.val + t2.val,\n)\npw.debug.compute_and_print(res, include_id=False)\n```\n::\nResult\n```\nshard_key | t  | val_left | val_right | sum\n0         | 2  | 1        | 0         | 1\n0         | 3  | 1        | 6         | 7\n0         | 7  | 5        | 2         | 7\n0         | 8  | 5        | 3         | 8\n0         | 9  | 5        | 9         | 14\n0         | 13 | 7        | 7         | 14\n0         | 14 | 7        | 4         | 11\n1         | 2  | -1       | 7         | 6\n1         | 8  | 9        | 3         | 12\n```\n::\n::\n"}
{"doc": "The documentation describes the function `interval_join` in the Pathway framework. It performs an interval join between two tables using time expressions and join conditions. The function takes several parameters such as the two tables to join, time expressions, lower and upper bounds on time difference, join conditions, and the type of join to perform. The function returns an `IntervalJoinResult` object that can be further processed with the `select` method to extract relevant columns. The documentation also provides an example usage of the function with sample input and output.\npw.stdlib.temporal.interval_join(self, other, self_time, other_time, interval, \\*on, how=JoinMode.INNER)\nPerforms an interval join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * how (`JoinMode`) \u2013 decides whether to run interval_join_inner, interval_join_left, interval_join_right\n        or interval_join_outer. Default is INNER.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b, how=pw.JoinMode.INNER\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n```\n::\n::\n"}
{"doc": "The function `interval_join_inner` in the Pathway framework performs an interval join of two tables based on a time difference and join expressions. It takes in two tables, time expressions for each table, lower and upper bounds on the time difference, and a list of column expressions. The function returns an `IntervalJoinResult` object, which can be further processed using the `select()` method to extract relevant columns from the join result. The documentation includes an example usage of the function.\npw.stdlib.temporal.interval_join_inner(self, other, self_time, other_time, interval, \\*on)\nPerforms an interval join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_inner(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_inner(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n```\n::\n::\n"}
{"doc": "The `interval_join_left` function is a method of the `Table` class in the Pathway framework. It performs a left join operation between `self` and `other` tables based on time difference and specified join conditions. The result is a `IntervalJoinResult` object which can be further manipulated using the `select()` method. The function takes in parameters such as `self_time`, `other_time`, `lower_bound`, `upper_bound`, and `on` to specify the time and join conditions. The documentation also provides a code example to illustrate how the function can be used.\npw.stdlib.temporal.interval_join_left(self, other, self_time, other_time, interval, \\*on)\nPerforms an interval left join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined. Rows from the left\nside that haven\u2019t been matched with the right side are returned with missing\nvalues on the right side replaced with None.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of the join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_left(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n11     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_left(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n1 | 11     |\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n3 | 4      |\n```\n::\n::\n"}
{"doc": "The `interval_join_outer` function in Pathway Framework performs an interval outer join of two tables using time expressions and join expressions. The join is based on a time difference between the two tables, and returns any rows that haven't been matched on either side with missing values on the other side replaced with `None`. The function takes in a `Table` object as the right side of the join, two time expressions (one for each table), a lower and upper bound on time difference, and a list of column expressions. The function returns an `IntervalJoinResult` object, which can be manipulated further by calling the `select()` method to extract relevant columns from the join result. An example is provided to illustrate how to use this function.\npw.stdlib.temporal.interval_join_outer(self, other, self_time, other_time, interval, \\*on)\nPerforms an interval outer join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined. Rows that haven\u2019t\nbeen matched with the other side are returned with missing values on the other\nside replaced with None.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of the join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_outer(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 0\n       | 7\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n11     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_outer(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n  |        | 0\n  |        | 2\n  |        | 7\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n1 | 11     |\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n3 | 4      |\n```\n::\n::\n"}
{"doc": "The documentation describes the `interval_join_right` function in the Pathway framework, which performs an interval right join of two tables based on a specified time difference and join expressions. It takes in parameters such as the two tables, time expressions, time bounds, and join conditions. The function returns an `IntervalJoinResult` object which can be further processed using the `select` method. An example usage of the function is also provided.\npw.stdlib.temporal.interval_join_right(self, other, self_time, other_time, interval, \\*on)\nPerforms an interval right join of self with other using a time difference\nand join expressions. If self_time + lower_bound <=\nother_time <= self_time + upper_bound\nand conditions in on are satisfied, the rows are joined. Rows from the right\nside that haven\u2019t been matched with the left side are returned with missing\nvalues on the left side replaced with None.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of the join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * lower_bound \u2013 a lower bound on time difference between other_time\n        and self_time.\n\n    * upper_bound \u2013 an upper bound on time difference between other_time\n        and self_time.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == as the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *IntervalJoinResult* \u2013 a result of the interval join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 3\n  2 | 4\n  3 | 5\n  4 | 11\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 0\n  2 | 1\n  3 | 4\n  4 | 7\n'''\n)\nt3 = t1.interval_join_right(t2, t1.t, t2.t, pw.temporal.interval(-2, 1)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 0\n       | 7\n3      | 1\n3      | 4\n4      | 4\n5      | 4\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 3\n  2 | 1 | 4\n  3 | 1 | 5\n  4 | 1 | 11\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 0\n  2 | 1 | 1\n  3 | 1 | 4\n  4 | 1 | 7\n  5 | 2 | 0\n  6 | 2 | 2\n  7 | 4 | 2\n'''\n)\nt3 = t1.interval_join_right(\n    t2, t1.t, t2.t, pw.temporal.interval(-2, 1), t1.a == t2.b\n).select(t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\na | left_t | right_t\n  |        | 0\n  |        | 2\n  |        | 7\n1 | 3      | 1\n1 | 3      | 4\n1 | 4      | 4\n1 | 5      | 4\n2 | 2      | 0\n2 | 2      | 2\n2 | 3      | 2\n```\n::\n::\n"}
{"doc": "The `pw.stdlib.temporal.sliding` function from the Pathway framework allows grouping elements within a window of a given length sliding across ordered time-like data column. It takes in hop, duration, ratio, and offset as parameters and returns a window object to pass as an argument to `.windowby()`. The function is usually used as an argument of `.windowby()`. The hop and ratio parameters are mutually exclusive, and only one of them should be provided. The function is demonstrated with an example.\npw.stdlib.temporal.sliding(hop, duration=None, ratio=None, offset=None)\nAllows grouping together elements within a window of a given length sliding\nacross ordered time-like data column according to a specified interval (hop)\nstarting from a given offset.\n\nNOTE: Usually used as an argument of .windowby().\nExactly one of the arguments hop or ratio should be provided.\n\n\n* Parameters\n\n    * hop (`Union`\\[`int`, `float`, `timedelta`\\]) \u2013 frequency of a window\n\n    * duration (`Union`\\[`int`, `float`, `timedelta`, `None`\\]) \u2013 length of the window\n\n    * ratio (`Optional`\\[`int`\\]) \u2013 used as an alternative way to specify duration as hop \\* ratio\n\n    * offset (`Union`\\[`int`, `float`, `datetime`, `None`\\]) \u2013 beginning of the first window\n\n\n\n* Returns\n\n    *Window* \u2013 object to pass as an argument to .windowby()\n\n\nExamples:\n>>> import pathway as pw\n>>> t = pw.debug.table_from_markdown(\n\u2026 \u2018\u2019\u2019\n\u2026        | shard | t\n\u2026    1   | 0     |  12\n\u2026    2   | 0     |  13\n\u2026    3   | 0     |  14\n\u2026    4   | 0     |  15\n\u2026    5   | 0     |  16\n\u2026    6   | 0     |  17\n\u2026    7   | 1     |  10\n\u2026    8   | 1     |  11\n\u2026 \u2018\u2019\u2019)\n>>> result = t.windowby(\n\u2026     t.t, window=pw.temporal.sliding(duration=10, hop=3), shard=t.shard\n\u2026 ).reduce(\n\u2026   pw.this._pw_shard,\n\u2026   pw.this._pw_window_start,\n\u2026   pw.this._pw_window_end,\n\u2026   min_t=pw.reducers.min(pw.this.t),\n\u2026   max_t=pw.reducers.max(pw.this.t),\n\u2026   count=pw.reducers.count(pw.this.t),\n\u2026 )\n>>> pw.debug.compute_and_print(result, include_id=False)\n_pw_shard | _pw_window_start | _pw_window_end | min_t | max_t | count\n0         | 3                | 13             | 12    | 12    | 1\n0         | 6                | 16             | 12    | 15    | 4\n0         | 9                | 19             | 12    | 17    | 6\n0         | 12               | 22             | 12    | 17    | 6\n0         | 15               | 25             | 15    | 17    | 3\n1         | 3                | 13             | 10    | 11    | 2\n1         | 6                | 16             | 10    | 11    | 2\n1         | 9                | 19             | 10    | 11    | 2\n\n"}
{"doc": "This documentation describes a function called `window_join` in the pathway framework, which performs a window join of two tables using a window and join expressions. The function takes several parameters such as the other table, self_time, other_time, window, on, and how. It returns a WindowJoinResult, which can be further filtered using the .select() method. An example is also given to illustrate how the function works.\npw.stdlib.temporal.window_join(self, other, self_time, other_time, window, \\*on, how=JoinMode.INNER)\nPerforms a window join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n    * how (`JoinMode`) \u2013 decides whether to run window_join_inner, window_join_left, window_join_right\n        or window_join_outer. Default is INNER.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n```\n::\n::\n\nt4 = t1.window_join(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      | 2\n2      | 2\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t1.a, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n2   | 2      | 2\n2   | 2      | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n```\n::\n::\n"}
{"doc": "The `window_join_inner` function in the Pathway framework performs a window join of the given table with another table using a window and join expressions. The function takes in the right table, time expressions for both tables, a window, and a list of join expressions, and returns a result object that can be used to extract relevant columns from the join. The function also supports sliding windows and session windows. The documentation includes an example usage of the function.\npw.stdlib.temporal.window_join_inner(self, other, self_time, other_time, window, \\*on)\nPerforms a window join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_inner(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n```\n::\n::\n\nt4 = t1.window_join_inner(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      | 2\n2      | 2\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_inner(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t1.a, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n2   | 2      | 2\n2   | 2      | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_inner(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_inner(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n```\n::\n::\n"}
{"doc": "The `window_join_left` function in the Pathway framework performs a window left join of a table with another table using a window and join expressions. It returns a result of the window join and a method .select() can be called on it to extract relevant columns from the result of a join. It takes in parameters such as the other table, time expression in self, time expression in other, window, and on. There are also examples provided for better understanding.\npw.stdlib.temporal.window_join_left(self, other, self_time, other_time, window, \\*on)\nPerforms a window left join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\nRows from the left side that didn\u2019t match with any record on the right side in\na given window, are returned with missing values on the right side replaced\nwith None. The multiplicity of such rows equals the number of windows they\nbelong to and don\u2019t have a match in them.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_left(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      |\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n13     |\n```\n::\n::\n\nt4 = t1.window_join_left(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n1      |\n1      | 2\n2      | 2\n2      | 2\n3      |\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n13     |\n13     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_left(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t1.a, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      |\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n1   | 13     |\n2   | 1      |\n2   | 2      | 2\n2   | 2      | 3\n3   | 4      |\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_left(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n10     |\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_left(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t1.a, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n2   | 7      |\n3   | 4      |\n```\n::\n::\n"}
{"doc": "The `window_join_outer()` function in the Pathway framework performs a window outer join of two tables using a window and join expressions. If two records belong to the same window and meet the conditions specified in the on clause, they will be joined. Rows from both sides that didn\u2019t match with any record on the other side in a given window, are returned with missing values on the other side replaced with None. The function takes in the following parameters: `other` (the right side of join), `self_time` (time expression in self), `other_time` (time expression in other), `window` (a window to use), `on` (a list of column expressions), and returns a `WindowJoinResult`. An example is also provided.\npw.stdlib.temporal.window_join_outer(self, other, self_time, other_time, window, \\*on)\nPerforms a window outer join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\nRows from both sides that didn\u2019t match with any record on the other side in\na given window, are returned with missing values on the other side replaced\nwith None. The multiplicity of such rows equals the number of windows they\nbelong to and don\u2019t have a match in them.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n1      |\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n13     |\n```\n::\n::\n\nt4 = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n       | 5\n       | 6\n1      |\n1      | 2\n2      | 2\n2      | 2\n3      |\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n13     |\n13     |\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_outer(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=pw.coalesce(t1.a, t2.b), left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   |        | 5\n1   | 1      |\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n1   | 13     |\n2   | 1      |\n2   | 2      | 2\n2   | 2      | 3\n3   | 4      |\n4   |        | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_outer(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | -3\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n10     |\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_outer(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=pw.coalesce(t1.a, t2.b), left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   |        | 10\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n2   | 7      |\n3   | 4      |\n4   |        | 3\n```\n::\n::\n"}
{"doc": "The `window_join_right()` function in the Pathway framework performs a window right join of a table with another table using specific conditions. It returns a result table that can be further manipulated using the `.select()` method. The function includes parameters for the other table, time expressions for both tables, a window, and a list of column expressions. The documentation includes an example that demonstrates how to use the function.\npw.stdlib.temporal.window_join_right(self, other, self_time, other_time, window, \\*on)\nPerforms a window right join of self with other using a window and join expressions.\nIf two records belong to the same window and meet the conditions specified in\nthe on clause, they will be joined. Note that if a sliding window is used and\nthere are pairs of matching records that appear in more than one window,\nthey will be included in the result multiple times (equal to the number of\nwindows they appear in).\n\nWhen using a session window, the function creates sessions by concatenating\nrecords from both sides of a join. Only pairs of records that meet\nthe conditions specified in the on clause can be part of the same session.\nThe result of a given session will include all records from the left side of\na join that belong to this session, joined with all records from the right\nside of a join that belong to this session.\n\nRows from the right side that didn\u2019t match with any record on the left side in\na given window, are returned with missing values on the left side replaced\nwith None. The multiplicity of such rows equals the number of windows they\nbelong to and don\u2019t have a match in them.\n\n\n* Parameters\n\n    * other (`Table`) \u2013 the right side of a join.\n\n    * self_time (`ColumnExpression`) \u2013 time expression in self.\n\n    * other_time (`ColumnExpression`) \u2013 time expression in other.\n\n    * window (`Window`) \u2013 a window to use.\n\n    * on (`ColumnExpression`) \u2013 a list of column expressions. Each must have == on the top level\n        operation and be of the form LHS: ColumnReference == RHS: ColumnReference.\n\n\n\n* Returns\n\n    *WindowJoinResult* \u2013 a result of the window join. A method .select()\n    can be called on it to extract relevant columns from the result of a join.\n\n\nExamples:\n\n\n\n\n```python\n\nimport pathway as pw\nt1 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 1\n  2 | 2\n  3 | 3\n  4 | 7\n  5 | 13\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | t\n  1 | 2\n  2 | 5\n  3 | 6\n  4 | 7\n'''\n)\nt3 = t1.window_join_right(t2, t1.t, t2.t, pw.temporal.tumbling(2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n```\n::\n::\n\nt4 = t1.window_join_right(t2, t1.t, t2.t, pw.temporal.sliding(1, 2)).select(\n    left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t4, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | 5\n       | 5\n       | 6\n1      | 2\n2      | 2\n2      | 2\n3      | 2\n7      | 6\n7      | 7\n7      | 7\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 2\n  3 | 1 | 3\n  4 | 1 | 7\n  5 | 1 | 13\n  6 | 2 | 1\n  7 | 2 | 2\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | 2\n  2 | 1 | 5\n  3 | 1 | 6\n  4 | 1 | 7\n  5 | 2 | 2\n  6 | 2 | 3\n  7 | 4 | 3\n'''\n)\nt3 = t1.window_join_right(t2, t1.t, t2.t, pw.temporal.tumbling(2), t1.a == t2.b).select(\n    key=t2.b, left_t=t1.t, right_t=t2.t\n)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   |        | 5\n1   | 2      | 2\n1   | 3      | 2\n1   | 7      | 6\n1   | 7      | 7\n2   | 2      | 2\n2   | 2      | 3\n4   |        | 3\n```\n::\n::\n\n\nt1 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | 0\n    1 | 5\n    2 | 10\n    3 | 15\n    4 | 17\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n      | t\n    0 | -3\n    1 | 2\n    2 | 3\n    3 | 6\n    4 | 16\n'''\n)\nt3 = t1.window_join_right(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2)\n).select(left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nleft_t | right_t\n       | -3\n0      | 2\n0      | 3\n0      | 6\n5      | 2\n5      | 3\n5      | 6\n15     | 16\n17     | 16\n```\n::\n::\n\nt1 = pw.debug.table_from_markdown(\n    '''\n    | a | t\n  1 | 1 | 1\n  2 | 1 | 4\n  3 | 1 | 7\n  4 | 2 | 0\n  5 | 2 | 3\n  6 | 2 | 4\n  7 | 2 | 7\n  8 | 3 | 4\n'''\n)\nt2 = pw.debug.table_from_markdown(\n    '''\n    | b | t\n  1 | 1 | -1\n  2 | 1 | 6\n  3 | 2 | 2\n  4 | 2 | 10\n  5 | 4 | 3\n'''\n)\nt3 = t1.window_join_right(\n    t2, t1.t, t2.t, pw.temporal.session(predicate=lambda a, b: abs(a - b) <= 2), t1.a == t2.b\n).select(key=t2.b, left_t=t1.t, right_t=t2.t)\npw.debug.compute_and_print(t3, include_id=False)\n```\n::\nResult\n```\nkey | left_t | right_t\n1   | 1      | -1\n1   | 4      | 6\n1   | 7      | 6\n2   |        | 10\n2   | 0      | 2\n2   | 3      | 2\n2   | 4      | 2\n4   |        | 3\n```\n::\n::\n"}
{"doc": "The `pw.io.jsonlines.write` function in the Pathway framework writes a `Table` object's stream of updates to a file in jsonlines format. It takes in two parameters: the `Table` to be written and the path to the target output file. The function returns `None`. An example is given to show how to use the function and what the output looks like.\npw.io.jsonlines.write(table, filename)\nWrites `table`\u2019s stream of updates to a file in jsonlines format.\n\n\n* Parameters\n\n    * table (`Table`) \u2013 Table to be written.\n\n    * filename (`str`) \u2013 Path to the target output file.\n\n\n\n* Returns\n\n    None\n\n\nExample:\n\nIn this simple example you can see how table output works.\nFirst, import Pathway and create a table:\n\n\n```python\nimport pathway as pw\nt = pw.debug.parse_to_table(\"age owner pet \\n 1 10 Alice dog \\n 2 9 Bob cat \\n 3 8 Alice cat\")\n```\nConsider you would want to output the stream of changes of this table. In order to do that\nyou simply do:\n\n\n```python\npw.io.jsonlines.write(t, \"table.jsonlines\")\n```\nNow, let\u2019s see what you have on the output:\n\n\n```bash\ncat table.jsonlines\n```\n\n```json\n{\"age\":10,\"owner\":\"Alice\",\"pet\":\"dog\",\"diff\":1,\"time\":0}\n{\"age\":9,\"owner\":\"Bob\",\"pet\":\"cat\",\"diff\":1,\"time\":0}\n{\"age\":8,\"owner\":\"Alice\",\"pet\":\"cat\",\"diff\":1,\"time\":0}\n```\nThe columns age, owner and pet clearly represent the data columns you have. The\ncolumn time represents the number of operations minibatch, in which each of the\nrows was read. In this example, since the data is static: you have 0. The diff is\nanother element of this stream of updates. In this context, it is 1 because all\nthree rows were read from the input. All in all, the extra information in `time` and\n`diff` columns - in this case - shows us that in the initial minibatch (`time = 0`),\nyou have read three rows and all of them were added to the collection (`diff = 1`).\n"}
{"doc": "The `pw.io.jsonlines.read` function reads a table from one or several files in jsonlines format and returns the table read. The function takes in parameters such as `path` (path to the file or folder with files), `value_columns` (names of the columns to be extracted from the files), `primary_key` (set of columns to generate a primary key), `mode` (static or streaming), `types` (mapping between columns and data types), and `default_values` (default values for columns). The function also allows for autocommitting and persistent ID. Examples of how to use the function are provided.\npw.io.jsonlines.read(path, value_columns, \\*, primary_key=None, mode='streaming', types=None, default_values=None, json_field_paths=None, autocommit_duration_ms=None, persistent_id=None, debug_data=None)\nReads a table from one or several files in jsonlines format.\n\nIn case the folder is passed to the engine, the order in which files from\nthe directory are processed is determined according to the modification time of\nfiles within this folder: they will be processed by ascending order of\nthe modification time.\n\n\n* Parameters\n\n    * path (`str`) \u2013 Path to the file or to the folder with files.\n\n    * value_columns (`List`\\[`str`\\]) \u2013 Names of the columns to be extracted from the files.\n\n    * primary_key (`Optional`\\[`List`\\[`str`\\]\\]) \u2013 In case the table should have a primary key generated according to\n        a subset of its columns, the set of columns should be specified in this field.\n        Otherwise, the primary key will be generated randomly.\n\n    * mode (`str`) \u2013 If set to \u201cstreaming\u201d, the engine will wait for the new input files in the directory. Set it to \u201cstatic\u201d, it will only consider the available data and ingest all of it in one commit. Default value is \u201cstreaming\u201d.\n\n    * types (`Optional`\\[`Dict`\\[`str`, `PathwayType`\\]\\]) \u2013 Dictionary containing the mapping between the columns and the data types (`pw.Type`) of the values of those columns. This parameter is optional, and if not provided the default type is `pw.Type.ANY`.\n\n    * default_values (`Optional`\\[`Dict`\\[`str`, `Any`\\]\\]) \u2013 dictionary containing default values for columns replacing\n        blank entries. The default value of the column must be specified explicitly,\n        otherwise there will be no default value.\n\n    * json_field_paths (`Optional`\\`Dict`\\[`str`, `str`\\]\\]) \u2013 This field allows to map field names into path in the field. For the field which require such mapping, it should be given in the format `<field_name>: <path to be mapped>`, where the path to be mapped needs to be a [JSON Pointer (RFC 6901).\n\n    * autocommit_duration_ms (`Optional`\\[`int`\\]) \u2013 the maximum time between two commits. Every\n        autocommit_duration_ms milliseconds, the updates received by the connector are\n        committed and pushed into Pathway\u2019s computation graph.\n\n    * persistent_id (`Optional`\\[`int`\\]) \u2013 (unstable) An identifier, under which the state of the table will be persisted or `None`, if there is no need to persist the state of this table. When a program restarts, it restores the state for all input tables according to what was saved for their `persistent_id`. This way it\u2019s possible to configure the start of computations from the moment they were terminated last time.\n\n    * debug_data \u2013 Static data replacing original one when debug mode is active.\n\n\n\n* Returns\n\n    *Table* \u2013 The table read.\n\n\nExample:\n\nConsider you want to read a dataset, stored in the filesystem in a jsonlines\nformat. The dataset contains data about pets and their owners.\n\nFor the sake of demonstration, you can prepare a small dataset by creating a jsonlines\nfile via a unix command line tool:\n\n\n```bash\nprintf \"{\\\"id\\\":1,\\\"owner\\\":\\\"Alice\\\",\\\"pet\\\":\\\"dog\\\"}\n{\\\"id\\\":2,\\\"owner\\\":\\\"Bob\\\",\\\"pet\\\":\\\"dog\\\"}\n{\\\"id\\\":3,\\\"owner\\\":\\\"Bob\\\",\\\"pet\\\":\\\"cat\\\"}\n{\\\"id\\\":4,\\\"owner\\\":\\\"Bob\\\",\\\"pet\\\":\\\"cat\\\"}\" > dataset.jsonlines\n```\nIn order to read it into Pathway\u2019s table, you can first do the import and then\nuse the `pw.io.jsonlines.read` method:\n\n\n```python\nimport pathway as pw\nt = pw.io.jsonlines.read(\"dataset.jsonlines\", [\"id\", \"owner\", \"pet\"], mode=\"static\")\n```\nThen, you can output the table in order to check the correctness of the read:\n\n\n\nCode\n```python\npw.debug.compute_and_print(t, include_id=False)\n```\n::\nResult\n```\nid | owner | pet\n1  | Alice | dog\n2  | Bob   | dog\n3  | Bob   | cat\n4  | Bob   | cat\n```\n::\n::\nNow let\u2019s try something different. Consider you have site access logs stored in a\nseparate folder in several files. For the sake of simplicity, a log entry contains\nan access ID, an IP address and the login of the user.\n\nA dataset, corresponding to the format described above can be generated, thanks to the\nfollowing set of unix commands:\n\n\n```bash\nmkdir logs\nprintf \"{\\\"id\\\":1,\\\"ip\\\":\\\"127.0.0.1\\\",\\\"login\\\":\\\"alice\\\"}\n{\\\"id\\\":2,\\\"ip\\\":\\\"8.8.8.8\\\",\\\"login\\\":\\\"alice\\\"}\" > logs/part_1.jsonlines\nprintf \"{\\\"id\\\":3,\\\"ip\\\":\\\"8.8.8.8\\\",\\\"login\\\":\\\"bob\\\"}\n{\\\"id\\\":4,\\\"ip\\\":\\\"127.0.0.1\\\",\\\"login\\\":\\\"alice\\\"}\" > logs/part_2.jsonlines\n```\nNow, let\u2019s see how you can use the connector in order to read the content of this\ndirectory into a table:\n\n\n```python\nt = pw.io.jsonlines.read(\"logs/\", [\"ip\", \"login\"], mode=\"static\")\n```\nThe only difference is that you specified the name of the directory instead of the\nfile name, as opposed to what you had done in the previous example. It\u2019s that simple!\n\nBut what if you are working with a real-time system, which generates logs all the time.\nThe logs are being written and after a while they get into the log directory (this is\nalso called \u201clogs rotation\u201d). Now, consider that there is a need to fetch the new files\nfrom this logs directory all the time. Would Pathway handle that? Sure!\n\nThe only difference would be in the usage of `mode` flag. So the code\nsnippet will look as follows:\n\n\n```python\nt = pw.io.jsonlines.read(\"logs/\", [\"ip\", \"login\"], mode=\"streaming\")\n```\nWith this method, you obtain a table updated dynamically. The changes in the logs would incur\nchanges in the Business-Intelligence \u2018BI\u2019-ready data, namely, in the tables you would like to output. To see\nhow these changes are reported by Pathway, have a look at the\n\u201cStreams of Updates and Snapshots\u201d\narticle.\n\n"}
{"doc": "This documentation describes a function `diff` in the `pw.stdlib.ordered` module of the Pathway framework. The `diff` function computes the difference between the values in the `values` columns and the previous values according to the order defined by the column `timestamp`. It takes two parameters, `timestamp` and `*values`, and returns a new table where each column is replaced with a new column containing the difference and whose name is the concatenation of `diff_` and the former name. It raises a `ValueError` if the columns are not `ColumnReference`. An example usage of the function is also provided.\nFunctions\n\n### pw.stdlib.ordered.diff(self, timestamp, \\*values)\nCompute the difference between the values in the `values` columns and the previous values\naccording to the order defined by the column `timestamp`.\n\n\n* Parameters\n\n    * timestamp (*-*) \u2013 The column reference to the `timestamp` column on\n        which the order is computed.\n\n    * \\*values (*-*) \u2013 Variable-length argument representing the column\n        references to the `values` columns.\n\n\n\n* Returns\n\n    `Table` \u2013 A new table where each column is replaced with a new column containing\n    the difference and whose name is the concatenation of diff_ and the former name.\n\n\n\n* Raises\n\n    ValueError \u2013 If the columns are not ColumnReference.\n\n\nNOTE: * The value of the \u201cfirst\u201d value (the row with the lower value\n\n        in the `timestamp` column) is `None`.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\ntimestamp | values\n1         | 1\n2         | 2\n3         | 4\n4         | 7\n5         | 11\n6         | 16\n''')\ntable += table.diff(pw.this.timestamp, pw.this.values)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\ntimestamp | values | diff_values\n1         | 1      |\n2         | 2      | 1\n3         | 4      | 2\n4         | 7      | 3\n5         | 11     | 4\n6         | 16     | 5\n```\n::\n::"}
{"doc": "This documentation is about the `diff` function in the `pw.stdlib.ordered.diff` module of the Pathway framework. The function computes the difference between the values in the specified columns and their previous values, according to the order defined by the `timestamp` column. It returns a new table with the difference values and raises a `ValueError` if the columns are not ColumnReference. The documentation also includes an example code snippet and its output.\npathway.stdlib.ordered.diff module\n\n\n### pw.stdlib.ordered.diff.diff(self, timestamp, \\*values)\nCompute the difference between the values in the `values` columns and the previous values\naccording to the order defined by the column `timestamp`.\n\n\n* Parameters\n\n    * timestamp (*-*) \u2013 The column reference to the `timestamp` column on\n        which the order is computed.\n\n    * \\*values (*-*) \u2013 Variable-length argument representing the column\n        references to the `values` columns.\n\n\n\n* Returns\n\n    `Table` \u2013 A new table where each column is replaced with a new column containing\n    the difference and whose name is the concatenation of diff_ and the former name.\n\n\n\n* Raises\n\n    ValueError \u2013 If the columns are not ColumnReference.\n\n\nNOTE: * The value of the \u201cfirst\u201d value (the row with the lower value\n\n        in the `timestamp` column) is `None`.\n\nExample:\n\n\n\nCode\n```python\nimport pathway as pw\ntable = pw.debug.table_from_markdown('''\ntimestamp | values\n1         | 1\n2         | 2\n3         | 4\n4         | 7\n5         | 11\n6         | 16\n''')\ntable += table.diff(pw.this.timestamp, pw.this.values)\npw.debug.compute_and_print(table, include_id=False)\n```\n::\nResult\n```\ntimestamp | values | diff_values\n1         | 1      |\n2         | 2      | 1\n3         | 4      | 2\n4         | 7      | 3\n5         | 11     | 4\n6         | 16     | 5\n```\n::\n::\n"}
{"doc": "The `pw.io.null.write(table)` function writes the stream of updates from the specified table to an empty sink, which means the data is not actually written anywhere. This function is useful when benchmarking a Pathway program and simplifying the input/output part as much as possible. It takes a single parameter, the `table` to be written, and returns nothing (None). An example usage of this function is provided in the documentation.\nFunctions\n\n### pw.io.null.write(table)\nWrites `table`\u2019s stream of updates to the empty sink.\n\nInside this routine, the data is formatted into the empty object, and then doesn\u2019t\nget written anywhere.\n\n\n* Parameters\n\n    table (`Table`) \u2013 Table to be written.\n\n\n\n* Returns\n\n    None\n\n\nExample:\n\nOne (of a very few) examples, where you can probably need this kind of functionality\nif the case when a Pathway program is benchmarked and the IO part needs to be\nsimplified as much as possible.\n\nIf the table is `table`, the null output can be configured in the following way:\n\n\n```python\npw.io.null.write(table)\n```\n"}